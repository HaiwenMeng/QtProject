///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////
#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Deep Learning / Object Detection and Instance Segmentation
void area_iou (HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType, HTuple hv_ResultSortIndices, 
    HTuple *hv_SampleArea, HTuple *hv_ResultArea, HTuple *hv_IoU);
// Chapter: Deep Learning / Model
// Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
void calculate_evaluation_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Calculate anomaly measures based on RunningMeasures. 
void calculate_image_anomaly_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: Deep Learning / Classification
// Short Description: Calculate image classification measures based on RunningMeasures. 
void calculate_image_classification_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Calculate instance measures based on RunningMeasures. 
void calculate_instance_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: OCR / Deep OCR
// Short Description: Computes the ocr_detection relevant evaluation measures. 
void calculate_ocr_detection_measures (HTuple hv_DetectionEvaluationResult, HTuple *hv_EvaluationResult);
// Chapter: OCR / Deep OCR
// Short Description: Calculate OCR recognition measures based on RunningMeasures. 
void calculate_ocr_recognition_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Calculate pixel measures based on RunningMeasures. 
void calculate_pixel_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, HTuple *hv_EvaluationResult);
// Chapter: Deep Learning / Model
// Short Description: Calculate region measures based on running measure values. 
void calculate_region_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Calculate 3D gripping point measures based on RunningMeasures. 
void calculate_running_gripping_point_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Initialize and check parameter for the generation of 3D gripping points and poses. 
void check_dl_3d_gripping_points_and_poses_params (HTuple hv_DLGrippingPointParams);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Check if scores of a Global Context Anomaly Detection model have been normalized 
void check_dl_gc_anomaly_scores_normalization (HTuple hv_DLModelHandle, HTuple hv_GenParam);
// Chapter: Deep Learning / Classification
// Short Description: Calculate top-K error. 
void compute_top_k_error (HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions, HTuple hv_K, 
    HTuple *hv_TopKError);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Compute a pose from a 3D point and orientation. 
void convert_dl_3d_gripping_point_to_pose (HTuple hv_X, HTuple hv_Y, HTuple hv_Z, 
    HTuple hv_NX, HTuple hv_NY, HTuple hv_NZ, HTuple *hv_Pose);
// Chapter: OCR / Deep OCR
// Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
void convert_ocr_detection_result_to_object_detection (HTuple hv_OcrResults, HTuple *hv_DetectionResults);
// Chapter: Deep Learning / Model
// Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
void create_evaluation_default_param (HTuple hv_EvaluationType, HTuple hv_ClassIDsModel, 
    HTuple *hv_EvalParams);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Develop
// Short Description: Resize a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit);
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'. 
void dev_update_off ();
// Chapter: System / Operating System
// Short Description: Estimate the remaining time for a task given the current progress. 
void estimate_progress (HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent, 
    HTuple hv_ProgressMax, HTuple *hv_SecondsElapsed, HTuple *hv_SecondsRemaining, 
    HTuple *hv_ProgressPercent, HTuple *hv_ProgressPerSecond);
// Chapter: Deep Learning / Model
// Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
void evaluate_dl_model (HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod, 
    HTuple hv_SampleSelectValues, HTuple hv_GenParam, HTuple *hv_EvaluationResult, 
    HTuple *hv_EvalParams);
// Chapter: Deep Learning / Model
// Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, HTuple hv_Mode, 
    HTuple *hv_SampleIndices);
// Chapter: Deep Learning / Classification
// Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
void gen_confusion_matrix (HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, HTuple *hv_ConfusionMatrix);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Generate gripping points for connected regions of high gripping confidence. 
void gen_dl_3d_gripping_point_image_coord (HObject ho_GrippingMap, HObject *ho_Regions, 
    HTuple hv_MinAreaSize, HTuple *hv_Rows, HTuple *hv_Columns);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Extract gripping points based on a 3D gripping point detection model output. 
void gen_dl_3d_gripping_points_and_poses (HTuple hv_DLSampleBatch, HTuple hv_DLGrippingPointParams, 
    HTuple hv_DLResultBatch);
// Chapter: Deep Learning / Model
// Short Description: Generate NumColors distinct colors 
void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
    HTuple hv_EndColor, HTuple *hv_Colors);
// Chapter: Deep Learning / Model
// Short Description: Return all pixel measures from a specified list of measures. 
void get_requested_pixel_measures (HTuple hv_Measures, HTuple hv_EvaluationType, 
    HTuple *hv_PixelMeasures);
// Chapter: Deep Learning / Model
// Short Description: Returns the list of available pixel evaluation measures for the specified type. 
void get_valid_pixel_measures (HTuple hv_EvaluationType, HTuple *hv_EvaluationMeasures);
// Chapter: Deep Learning / Model
// Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
void init_running_evaluation_measures (HTuple hv_EvalParams, HTuple *hv_RunningMeasures);
// Chapter: Deep Learning / Model
// Short Description: Read the dictionaries DLSamples from files. 
void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple *hv_DLSampleBatch);
// Chapter: File / Misc
// Short Description: Remove a directory recursively. 
void remove_dir_recursively (HTuple hv_DirName);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant);
// Chapter: System / Operating System
// Short Description: Create a formatted string of a time span. 
void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, HTuple *hv_TimeString);
// Chapter: Tuple / Element Order
// Short Description: Sort the elements of a tuple randomly. 
void tuple_shuffle (HTuple hv_Tuple, HTuple *hv_Shuffled);
// Chapter: Tuple / Arithmetic
// Short Description: Calculate the cross product of two vectors of length 3. 
void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC);
// Chapter: Deep Learning / Model
// Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
void update_running_evaluation_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Update running measures for 3D gripping points. 
void update_running_gripping_point_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Update running measures for an anomaly detection or Global Context Anomaly Detection evaluation. 
void update_running_image_anomaly_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures);
// Chapter: Deep Learning / Classification
// Short Description: Update running measures for an image classification evaluation. 
void update_running_image_classification_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Update running measures for an instance-based evaluation. 
void update_running_instance_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures);
// Chapter: OCR / Deep OCR
// Short Description: Update running measures for an OCR recognition evaluation. 
void update_running_ocr_recognition_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Update running measures for a pixel-based evaluation. 
void update_running_pixel_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures);
// Chapter: Deep Learning / Model
// Short Description: Update running measures for a region-based evaluation. 
void update_running_region_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures);
// Chapter: Deep Learning / Model
// Short Description: Check that all given entries in EvalParams are valid. 
void validate_evaluation_param (HTuple hv_EvalParams, HTuple *hv_Valid, HTuple *hv_Exception);
// Local procedures 
// Short Description: Local example procedure for cleaning up files written by example script. 
void clean_up_output (HTuple hv_OutputDir, HTuple hv_RemoveResults);
// Short Description: This procedure displays the accuracy comparison of 2 models. 
void dev_display_evaluation_comparison (HTuple hv_ModelNames, HTuple hv_EvaluationResults, 
    HTuple hv_WindowColumn, HTuple *hv_WindowHandle);
// Short Description: Evaluates a Deep OCR detection model on a given dataset split. 
void evaluate_ocr_detection (HTuple hv_DLModelHandle, HTuple hv_DLDevice, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple hv_BatchSize, HTuple hv_DLDataset, HTuple hv_EvaluationSplit, 
    HTuple hv_MaxNumSamples, HTuple *hv_EvaluationResult);
// Short Description: This procedure prepares the comparison visualization. 
void prepare_detailed_comparison_visualization (HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
    HTuple *hv_VisualizationDict);

// Procedures 
// External procedures 
// Chapter: Deep Learning / Object Detection and Instance Segmentation
void area_iou (HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType, HTuple hv_ResultSortIndices, 
    HTuple *hv_SampleArea, HTuple *hv_ResultArea, HTuple *hv_IoU)
{

  // Local iconic variables
  HObject  ho_GtMask, ho_ResMask, ho_CurrentGtMask;
  HObject  ho_ValidResMask, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_GtRow1, hv_GtCol1, hv_GtRow2, hv_GtCol2;
  HTuple  hv_ResRow1, hv_ResCol1, hv_ResRow2, hv_ResCol2;
  HTuple  hv_GtIdx, hv_Height, hv_Width, hv_ValidIdxs, hv_Intersection;
  HTuple  hv_Union, hv_GtRow, hv_GtCol, hv_GtLength1, hv_GtLength2;
  HTuple  hv_GtPhi, hv_ResRow, hv_ResCol, hv_ResLength1, hv_ResLength2;
  HTuple  hv_ResPhi, hv__, hv_NumGt, hv_NumRes;

  //
  //Compute the intersection over union (IoU) between
  //the ground truth and the inferred bounding box or instance
  //segmentation mask of the object instances.
  //The instance type is determined over the InstanceType.
  //
  if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
  {
    //Get bounding box coordinates.
    GetDictTuple(hv_Sample, "bbox_row1", &hv_GtRow1);
    GetDictTuple(hv_Sample, "bbox_col1", &hv_GtCol1);
    GetDictTuple(hv_Sample, "bbox_row2", &hv_GtRow2);
    GetDictTuple(hv_Sample, "bbox_col2", &hv_GtCol2);
    GetDictTuple(hv_Result, "bbox_row1", &hv_ResRow1);
    GetDictTuple(hv_Result, "bbox_col1", &hv_ResCol1);
    GetDictTuple(hv_Result, "bbox_row2", &hv_ResRow2);
    GetDictTuple(hv_Result, "bbox_col2", &hv_ResCol2);
    //
    //Sort the results.
    hv_ResRow1 = HTuple(hv_ResRow1[hv_ResultSortIndices]);
    hv_ResCol1 = HTuple(hv_ResCol1[hv_ResultSortIndices]);
    hv_ResRow2 = HTuple(hv_ResRow2[hv_ResultSortIndices]);
    hv_ResCol2 = HTuple(hv_ResCol2[hv_ResultSortIndices]);
    //
    //Compute areas.
    (*hv_SampleArea) = (hv_GtRow2-hv_GtRow1)*(hv_GtCol2-hv_GtCol1);
    (*hv_ResultArea) = (hv_ResRow2-hv_ResRow1)*(hv_ResCol2-hv_ResCol1);
    //
    //Compute IoUs.
    (*hv_IoU) = HTuple((hv_GtRow1.TupleLength())*(hv_ResRow1.TupleLength()),0);
    if (0 != (int(((*hv_IoU).TupleLength())>0)))
    {
      {
      HTuple end_val30 = (hv_GtRow1.TupleLength())-1;
      HTuple step_val30 = 1;
      for (hv_GtIdx=0; hv_GtIdx.Continue(end_val30, step_val30); hv_GtIdx += step_val30)
      {
        hv_Height = (HTuple(hv_GtRow2[hv_GtIdx]).TupleMin2(hv_ResRow2))-(HTuple(hv_GtRow1[hv_GtIdx]).TupleMax2(hv_ResRow1));
        hv_Width = (HTuple(hv_GtCol2[hv_GtIdx]).TupleMin2(hv_ResCol2))-(HTuple(hv_GtCol1[hv_GtIdx]).TupleMax2(hv_ResCol1));
        hv_ValidIdxs = HTuple((hv_Height.TupleGreaterElem(0)).TupleAnd(hv_Width.TupleGreaterElem(0))).TupleFind(1);
        if (0 != (int(hv_ValidIdxs>-1)))
        {
          hv_Intersection = HTuple(hv_Height[hv_ValidIdxs])*HTuple(hv_Width[hv_ValidIdxs]);
          hv_Union = (HTuple((*hv_SampleArea)[hv_GtIdx])+HTuple((*hv_ResultArea)[hv_ValidIdxs]))-hv_Intersection;
          (*hv_IoU)[(hv_GtIdx*(hv_ResRow1.TupleLength()))+hv_ValidIdxs] = (hv_Intersection.TupleReal())/hv_Union;
        }
      }
      }
    }
  }
  else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
  {
    //Get bounding box coordinates.
    GetDictTuple(hv_Sample, "bbox_row", &hv_GtRow);
    GetDictTuple(hv_Sample, "bbox_col", &hv_GtCol);
    GetDictTuple(hv_Sample, "bbox_length1", &hv_GtLength1);
    GetDictTuple(hv_Sample, "bbox_length2", &hv_GtLength2);
    GetDictTuple(hv_Sample, "bbox_phi", &hv_GtPhi);
    GetDictTuple(hv_Result, "bbox_row", &hv_ResRow);
    GetDictTuple(hv_Result, "bbox_col", &hv_ResCol);
    GetDictTuple(hv_Result, "bbox_length1", &hv_ResLength1);
    GetDictTuple(hv_Result, "bbox_length2", &hv_ResLength2);
    GetDictTuple(hv_Result, "bbox_phi", &hv_ResPhi);
    //
    //Sort results.
    hv_ResRow = HTuple(hv_ResRow[hv_ResultSortIndices]);
    hv_ResCol = HTuple(hv_ResCol[hv_ResultSortIndices]);
    hv_ResLength1 = HTuple(hv_ResLength1[hv_ResultSortIndices]);
    hv_ResLength2 = HTuple(hv_ResLength2[hv_ResultSortIndices]);
    hv_ResPhi = HTuple(hv_ResPhi[hv_ResultSortIndices]);
    //
    //Compute Areas.
    (*hv_SampleArea) = (4.0*hv_GtLength1)*hv_GtLength2;
    (*hv_ResultArea) = (4.0*hv_ResLength1)*hv_ResLength2;
    //
    //Compute IoUs.
    (*hv_IoU) = HTuple((hv_GtRow.TupleLength())*(hv_ResRow.TupleLength()),0);
    if (0 != (int(((*hv_IoU).TupleLength())>0)))
    {
      {
      HTuple end_val68 = (hv_GtRow.TupleLength())-1;
      HTuple step_val68 = 1;
      for (hv_GtIdx=0; hv_GtIdx.Continue(end_val68, step_val68); hv_GtIdx += step_val68)
      {
        hv_ValidIdxs = HTuple((HTuple((*hv_SampleArea)[hv_GtIdx]).TupleGreaterElem(0)).TupleAnd((*hv_ResultArea).TupleGreaterElem(0))).TupleFind(1);
        if (0 != (int(hv_ValidIdxs>-1)))
        {
          AreaIntersectionRectangle2(HTuple(hv_GtRow[hv_GtIdx]), HTuple(hv_GtCol[hv_GtIdx]), 
              HTuple(hv_GtPhi[hv_GtIdx]), HTuple(hv_GtLength1[hv_GtIdx]), HTuple(hv_GtLength2[hv_GtIdx]), 
              HTuple(hv_ResRow[hv_ValidIdxs]), HTuple(hv_ResCol[hv_ValidIdxs]), HTuple(hv_ResPhi[hv_ValidIdxs]), 
              HTuple(hv_ResLength1[hv_ValidIdxs]), HTuple(hv_ResLength2[hv_ValidIdxs]), 
              &hv_Intersection);
          hv_Union = (HTuple((*hv_SampleArea)[hv_GtIdx])+HTuple((*hv_ResultArea)[hv_ValidIdxs]))-hv_Intersection;
          (*hv_IoU)[(hv_GtIdx*(hv_ResRow.TupleLength()))+hv_ValidIdxs] = (hv_Intersection.TupleReal())/hv_Union;
        }
      }
      }
    }
  }
  else if (0 != (int(hv_InstanceType==HTuple("mask"))))
  {
    //Get the ground truth mask.
    GetDictObject(&ho_GtMask, hv_Sample, "mask");
    //
    //Get the result mask.
    GetDictObject(&ho_ResMask, hv_Result, "mask");
    //
    //Sort the results.
    SelectObj(ho_ResMask, &ho_ResMask, hv_ResultSortIndices+1);
    //
    //Compute Areas.
    AreaCenter(ho_GtMask, &(*hv_SampleArea), &hv__, &hv__);
    AreaCenter(ho_ResMask, &(*hv_ResultArea), &hv__, &hv__);
    //
    //Compute IoUs.
    CountObj(ho_GtMask, &hv_NumGt);
    CountObj(ho_ResMask, &hv_NumRes);
    (*hv_IoU) = HTuple(hv_NumGt*hv_NumRes,0);
    if (0 != (int(((*hv_IoU).TupleLength())>0)))
    {
      {
      HTuple end_val96 = hv_NumGt-1;
      HTuple step_val96 = 1;
      for (hv_GtIdx=0; hv_GtIdx.Continue(end_val96, step_val96); hv_GtIdx += step_val96)
      {
        hv_ValidIdxs = HTuple((HTuple((*hv_SampleArea)[hv_GtIdx]).TupleGreaterElem(0)).TupleAnd((*hv_ResultArea).TupleGreaterElem(0))).TupleFind(1);
        if (0 != (int(hv_ValidIdxs>-1)))
        {
          SelectObj(ho_GtMask, &ho_CurrentGtMask, hv_GtIdx+1);
          SelectObj(ho_ResMask, &ho_ValidResMask, hv_ValidIdxs+1);
          Intersection(ho_ValidResMask, ho_CurrentGtMask, &ho_RegionIntersection);
          AreaCenter(ho_RegionIntersection, &hv_Intersection, &hv__, &hv__);
          hv_Union = (HTuple((*hv_SampleArea)[hv_GtIdx])+HTuple((*hv_ResultArea)[hv_ValidIdxs]))-hv_Intersection;
          (*hv_IoU)[(hv_GtIdx*hv_NumRes)+hv_ValidIdxs] = (hv_Intersection.TupleReal())/hv_Union;
        }
      }
      }
    }
  }
  else
  {
    throw HException(("Instance type '"+hv_InstanceType)+"' is not supported");
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
void calculate_evaluation_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_EvaluationType, hv_EvaluationResultTmp;
  HTuple  hv_PixelMeasures, hv_PixelMeasureValues, hv_ResultKeys;
  HTuple  hv_KeyIndex, hv___Tmp_Ctrl_Type;

  //
  //This procedure calculates the final measures depending on the evaluation type.
  //
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
  if (0 != (HTuple(int(hv_EvaluationType==HTuple("anomaly_detection"))).TupleOr(int(hv_EvaluationType==HTuple("gc_anomaly_detection")))))
  {
    calculate_image_anomaly_measures(hv_RunningMeasures, hv_EvalParams, &(*hv_EvaluationResult));
  }
  else if (0 != (int(hv_EvaluationType==HTuple("classification"))))
  {
    calculate_image_classification_measures(hv_RunningMeasures, hv_EvalParams, &(*hv_EvaluationResult));
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("detection"))).TupleOr(int(hv_EvaluationType==HTuple("ocr_detection")))))
  {
    calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, &(*hv_EvaluationResult));
    if (0 != (int(hv_EvaluationType==HTuple("ocr_detection"))))
    {
      calculate_ocr_detection_measures((*hv_EvaluationResult), &(*hv_EvaluationResult));
    }
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("segmentation"))).TupleOr(int(hv_EvaluationType==HTuple("3d_gripping_point_detection")))))
  {
    calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, &(*hv_EvaluationResult));
    if (0 != (int(hv_EvaluationType==HTuple("3d_gripping_point_detection"))))
    {
      calculate_region_measures(hv_RunningMeasures, hv_EvalParams, &hv_EvaluationResultTmp);
      //Only report requested pixel and region measures.
      get_requested_pixel_measures(hv_EvalParams.TupleGetDictTuple("measures"), hv_EvaluationType, 
          &hv_PixelMeasures);
      GetDictTuple((*hv_EvaluationResult), hv_PixelMeasures, &hv_PixelMeasureValues);
      SetDictTuple(hv_EvaluationResultTmp, hv_PixelMeasures, hv_PixelMeasureValues);
      (*hv_EvaluationResult) = hv_EvaluationResultTmp;
      calculate_running_gripping_point_measures(hv_RunningMeasures, hv_EvalParams, 
          &hv_EvaluationResultTmp);
      GetDictParam(hv_EvaluationResultTmp, "keys", HTuple(), &hv_ResultKeys);
      {
      HTuple end_val24 = (hv_ResultKeys.TupleLength())-1;
      HTuple step_val24 = 1;
      for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val24, step_val24); hv_KeyIndex += step_val24)
      {
        GetDictParam(hv_EvaluationResultTmp, "key_data_type", HTuple(hv_ResultKeys[hv_KeyIndex]), 
            &hv___Tmp_Ctrl_Type);
        if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
        {
          SetDictObject(hv_EvaluationResultTmp.TupleGetDictObject(HTuple(hv_ResultKeys[hv_KeyIndex])), 
              (*hv_EvaluationResult), HTuple(hv_ResultKeys[hv_KeyIndex]));
        }
        else
        {
          SetDictTuple((*hv_EvaluationResult), HTuple(hv_ResultKeys[hv_KeyIndex]), 
              hv_EvaluationResultTmp.TupleGetDictTuple(HTuple(hv_ResultKeys[hv_KeyIndex])));
        }
      }
      }
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_recognition"))))
  {
    calculate_ocr_recognition_measures(hv_RunningMeasures, hv_EvalParams, &(*hv_EvaluationResult));
  }
  //
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Calculate anomaly measures based on RunningMeasures. 
void calculate_image_anomaly_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CalcAnomalyHistogram, hv_CalcPrecision;
  HTuple  hv_CalcRecall, hv_CalcAbsoluteConfusionMatrix, hv_CalcRelativeConfusionMatrix;
  HTuple  hv_MeasuresExists, hv_Measures, hv_M, hv_AnomalyClassificationThresholdExists;
  HTuple  hv_AnomalyClassificationThreshold, hv_ImageIDs;
  HTuple  hv_AnomalyLabelIDs, hv_AnomalyScores, hv_OKIndices;
  HTuple  hv_NOKIndices, hv_HistoOKXValues, hv_HistoOKYValues;
  HTuple  hv_NumOKEvalData, hv_ImageLevelScoresOK, hv_HistoNOKXValues;
  HTuple  hv_HistoNOKYValues, hv_NumNOKEvalData, hv_ImageLevelScoresNOK;
  HTuple  hv_ScoreHistogram, hv_NumClasses, hv_ClassIDs, hv_AllPredictions;
  HTuple  hv_IndThreshold, hv_CurrentThresholdValue, hv_CurrentThresholdKey;
  HTuple  hv_Predictions, hv_AbsoluteConfustionMatrices, hv_AbsoluteConfusionMatrix;
  HTuple  hv_Rows, hv_Columns, hv_Value, hv_AbsoluteConfusionMatrixDictionary;
  HTuple  hv_RelativeConfustionMatrices, hv_RelativeConfusionMatrix;
  HTuple  hv_RelativeConfusionMatrixDictionary, hv_GlobalEvaluation;
  HTuple  hv_AllClassPrecisions, hv_AllMeanPrecisions, hv_AbsoluteConfusionMatrices;
  HTuple  hv_ClassPrecisions, hv_MatrixRowSumID, hv_MatrixColumnSumID;
  HTuple  hv_Index, hv_TruePositive, hv_SumPredictedClass;
  HTuple  hv_SumLabel, hv_ClassPrecision, hv_ValidClassPrecisions;
  HTuple  hv_MeanPrecision, hv_AllClassRecalls, hv_AllMeanRecalls;
  HTuple  hv_ClassRecalls, hv_ClassRecall, hv_ValidClassRecalls;
  HTuple  hv_MeanRecall;

  //
  //This procedure calculates the final summarizing image anomaly measures based on the running measures.
  //
  hv_CalcAnomalyHistogram = 1;
  hv_CalcPrecision = 0;
  hv_CalcRecall = 0;
  hv_CalcAbsoluteConfusionMatrix = 0;
  hv_CalcRelativeConfusionMatrix = 0;
  GetDictParam(hv_EvalParams, "key_exists", "measures", &hv_MeasuresExists);
  if (0 != hv_MeasuresExists)
  {
    GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
    {
    HTuple end_val11 = (hv_Measures.TupleLength())-1;
    HTuple step_val11 = 1;
    for (hv_M=0; hv_M.Continue(end_val11, step_val11); hv_M += step_val11)
    {
      if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("anomaly_score_histogram"))))
      {
        //The default, just here for consistency.
        hv_CalcAnomalyHistogram = 1;
      }
      else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("precision"))))
      {
        hv_CalcPrecision = 1;
        hv_CalcAbsoluteConfusionMatrix = 1;
      }
      else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("recall"))))
      {
        hv_CalcRecall = 1;
        hv_CalcAbsoluteConfusionMatrix = 1;
      }
      else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("absolute_confusion_matrix"))))
      {
        hv_CalcAbsoluteConfusionMatrix = 1;
      }
      else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("relative_confusion_matrix"))))
      {
        hv_CalcRelativeConfusionMatrix = 1;
      }
      else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("all"))))
      {
        hv_CalcPrecision = 1;
        hv_CalcRecall = 1;
        hv_CalcAbsoluteConfusionMatrix = 1;
        hv_CalcRelativeConfusionMatrix = 1;
      }
      else
      {
        throw HException(("Unknown Measure: "+HTuple(hv_Measures[hv_M]))+".");
      }
    }
    }
  }
  //
  GetDictParam(hv_EvalParams, "key_exists", "anomaly_classification_thresholds", 
      &hv_AnomalyClassificationThresholdExists);
  if (0 != hv_AnomalyClassificationThresholdExists)
  {
    GetDictTuple(hv_EvalParams, "anomaly_classification_thresholds", &hv_AnomalyClassificationThreshold);
  }
  else if (0 != (hv_CalcRelativeConfusionMatrix.TupleOr(hv_CalcAbsoluteConfusionMatrix)))
  {
    throw HException("A threshold value is needed to calculate a confusion matrix.");
  }
  //
  //Get and check values in RunningMeasures.
  //
  //Get image ids.
  GetDictTuple(hv_RunningMeasures, "image_ids", &hv_ImageIDs);
  //Get anomaly ids.
  GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", &hv_AnomalyLabelIDs);
  //Get image scores.
  GetDictTuple(hv_RunningMeasures, "anomaly_scores", &hv_AnomalyScores);
  //
  //Calculate histograms.
  //
  //Find scores of 'ok' and 'nok' images.
  hv_OKIndices = hv_AnomalyLabelIDs.TupleFind(0);
  hv_NOKIndices = hv_AnomalyLabelIDs.TupleFind(1);
  if (0 != (HTuple(int(hv_OKIndices==-1)).TupleAnd(int(hv_NOKIndices==-1))))
  {
    throw HException("No data available for evaluation");
  }
  //
  //Calculate histogram for 'ok' images.
  hv_HistoOKXValues = HTuple();
  hv_HistoOKYValues = HTuple();
  hv_NumOKEvalData = 0;
  if (0 != (int(hv_OKIndices!=-1)))
  {
    hv_NumOKEvalData = hv_OKIndices.TupleLength();
    hv_ImageLevelScoresOK = HTuple(hv_AnomalyScores[hv_OKIndices]);
    hv_HistoOKXValues = hv_ImageLevelScoresOK.TupleSort();
    hv_HistoOKYValues = (HTuple::TupleGenSequence(hv_ImageLevelScoresOK.TupleLength(),1,-1).TupleReal())/(hv_ImageLevelScoresOK.TupleLength());
  }
  //
  //Calculate histogram for 'nok' images.
  hv_HistoNOKXValues = HTuple();
  hv_HistoNOKYValues = HTuple();
  hv_NumNOKEvalData = 0;
  if (0 != (int(hv_NOKIndices!=-1)))
  {
    hv_NumNOKEvalData = hv_NOKIndices.TupleLength();
    hv_ImageLevelScoresNOK = HTuple(hv_AnomalyScores[hv_NOKIndices]);
    hv_HistoNOKXValues = hv_ImageLevelScoresNOK.TupleSort();
    hv_HistoNOKYValues = (HTuple::TupleGenSequence(1,hv_ImageLevelScoresNOK.TupleLength(),1).TupleReal())/(hv_ImageLevelScoresNOK.TupleLength());
  }
  //
  //Create dictionary for the score histogram.
  CreateDict(&hv_ScoreHistogram);
  SetDictTuple(hv_ScoreHistogram, "ok_x", hv_HistoOKXValues);
  SetDictTuple(hv_ScoreHistogram, "ok_y", hv_HistoOKYValues);
  SetDictTuple(hv_ScoreHistogram, "nok_x", hv_HistoNOKXValues);
  SetDictTuple(hv_ScoreHistogram, "nok_y", hv_HistoNOKYValues);
  //
  //Set the score histogram in the results dictionary.
  CreateDict(&(*hv_EvaluationResult));
  SetDictTuple((*hv_EvaluationResult), "anomaly_score_histogram", hv_ScoreHistogram);
  //
  //Get Predictions according to given Threshold value(s).
  //Remember, precision and recall base on the absolute confusion matrix.
  if (0 != (hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)))
  {
    GetDictTuple(hv_EvalParams, "num_classes", &hv_NumClasses);
    GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
    CreateDict(&hv_AllPredictions);
    {
    HTuple end_val100 = (hv_AnomalyClassificationThreshold.TupleLength())-1;
    HTuple step_val100 = 1;
    for (hv_IndThreshold=0; hv_IndThreshold.Continue(end_val100, step_val100); hv_IndThreshold += step_val100)
    {
      hv_CurrentThresholdValue = HTuple(hv_AnomalyClassificationThreshold[hv_IndThreshold]);
      hv_CurrentThresholdKey = hv_IndThreshold.TupleString(".3d");
      hv_Predictions = hv_AnomalyScores.TupleGreaterEqualElem(hv_CurrentThresholdValue);
      SetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, hv_Predictions);
    }
    }
  }
  //
  //Calculate absolute confusion matrix.
  if (0 != hv_CalcAbsoluteConfusionMatrix)
  {
    hv_AbsoluteConfustionMatrices = HTuple();
    {
    HTuple end_val111 = (hv_AnomalyClassificationThreshold.TupleLength())-1;
    HTuple step_val111 = 1;
    for (hv_IndThreshold=0; hv_IndThreshold.Continue(end_val111, step_val111); hv_IndThreshold += step_val111)
    {
      hv_CurrentThresholdValue = HTuple(hv_AnomalyClassificationThreshold[hv_IndThreshold]);
      hv_CurrentThresholdKey = hv_IndThreshold.TupleString(".3d");
      GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, &hv_Predictions);
      gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (HTuple("display_matrix").Append("return_matrix")), 
          (HTuple("none").Append("absolute")), HTuple(), &hv_AbsoluteConfusionMatrix);
      GetSizeMatrix(hv_AbsoluteConfusionMatrix, &hv_Rows, &hv_Columns);
      if (0 != (HTuple(HTuple(int(hv_NumOKEvalData<=0)).TupleOr(int(hv_NumNOKEvalData<=0))).TupleAnd(HTuple(int(hv_Rows<2)).TupleOr(int(hv_Columns<2)))))
      {
        //Patch matrix to 2x2 in case only 'ok' or only 'nok'
        //data is used for evaluation.
        GetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, &hv_Value);
        CreateMatrix(2, 2, 0, &hv_AbsoluteConfusionMatrix);
        if (0 != (int(hv_NumOKEvalData<=0)))
        {
          SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 1, (hv_Predictions.TupleLength())-hv_Value);
          SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 1, hv_Value);
        }
        if (0 != (int(hv_NumNOKEvalData<=0)))
        {
          SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, hv_Value);
          SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 0, (hv_Predictions.TupleLength())-hv_Value);
        }
      }
      CreateDict(&hv_AbsoluteConfusionMatrixDictionary);
      SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix", hv_AbsoluteConfusionMatrix);
      SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "threshold", hv_CurrentThresholdValue);
      hv_AbsoluteConfustionMatrices[hv_IndThreshold] = hv_AbsoluteConfusionMatrixDictionary;
    }
    }
    SetDictTuple((*hv_EvaluationResult), "absolute_confusion_matrix", hv_AbsoluteConfustionMatrices);
  }
  //
  //Calculate relative confusion matrix.
  if (0 != hv_CalcRelativeConfusionMatrix)
  {
    hv_RelativeConfustionMatrices = HTuple();
    {
    HTuple end_val142 = (hv_AnomalyClassificationThreshold.TupleLength())-1;
    HTuple step_val142 = 1;
    for (hv_IndThreshold=0; hv_IndThreshold.Continue(end_val142, step_val142); hv_IndThreshold += step_val142)
    {
      hv_CurrentThresholdValue = HTuple(hv_AnomalyClassificationThreshold[hv_IndThreshold]);
      hv_CurrentThresholdKey = hv_IndThreshold.TupleString(".3d");
      GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, &hv_Predictions);
      gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (HTuple("display_matrix").Append("return_matrix")), 
          (HTuple("none").Append("relative")), HTuple(), &hv_RelativeConfusionMatrix);
      GetSizeMatrix(hv_RelativeConfusionMatrix, &hv_Rows, &hv_Columns);
      if (0 != (HTuple(HTuple(int(hv_NumOKEvalData<=0)).TupleOr(int(hv_NumNOKEvalData<=0))).TupleAnd(HTuple(int(hv_Rows<2)).TupleOr(int(hv_Columns<2)))))
      {
        //Patch matrix to 2x2 in case only 'ok' or only 'nok'
        //data is used for evaluation.
        GetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, &hv_Value);
        CreateMatrix(2, 2, 0, &hv_RelativeConfusionMatrix);
        if (0 != (int(hv_NumOKEvalData<=0)))
        {
          SetValueMatrix(hv_RelativeConfusionMatrix, 0, 1, 1.0-hv_Value);
          SetValueMatrix(hv_RelativeConfusionMatrix, 1, 1, hv_Value);
        }
        if (0 != (int(hv_NumNOKEvalData<=0)))
        {
          SetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, hv_Value);
          SetValueMatrix(hv_RelativeConfusionMatrix, 1, 0, 1.0-hv_Value);
        }
      }
      CreateDict(&hv_RelativeConfusionMatrixDictionary);
      SetDictTuple(hv_RelativeConfusionMatrixDictionary, "confusion_matrix", hv_RelativeConfusionMatrix);
      SetDictTuple(hv_RelativeConfusionMatrixDictionary, "threshold", hv_CurrentThresholdValue);
      hv_RelativeConfustionMatrices[hv_IndThreshold] = hv_RelativeConfusionMatrixDictionary;
    }
    }
    SetDictTuple((*hv_EvaluationResult), "relative_confusion_matrix", hv_RelativeConfustionMatrices);
  }
  //
  if (0 != (hv_CalcPrecision.TupleOr(hv_CalcRecall)))
  {
    CreateDict(&hv_GlobalEvaluation);
  }
  //Calculate precision.
  if (0 != hv_CalcPrecision)
  {
    hv_AllClassPrecisions = HTuple();
    hv_AllMeanPrecisions = HTuple();
    GetDictTuple((*hv_EvaluationResult), "absolute_confusion_matrix", &hv_AbsoluteConfusionMatrices);
    {
    HTuple end_val178 = (hv_AbsoluteConfusionMatrices.TupleLength())-1;
    HTuple step_val178 = 1;
    for (hv_IndThreshold=0; hv_IndThreshold.Continue(end_val178, step_val178); hv_IndThreshold += step_val178)
    {
      hv_AbsoluteConfusionMatrixDictionary = HTuple(hv_AbsoluteConfusionMatrices[hv_IndThreshold]);
      GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix", &hv_AbsoluteConfusionMatrix);
      hv_ClassPrecisions = HTuple();
      SumMatrix(hv_AbsoluteConfusionMatrix, "rows", &hv_MatrixRowSumID);
      SumMatrix(hv_AbsoluteConfusionMatrix, "columns", &hv_MatrixColumnSumID);
      {
      HTuple end_val184 = hv_NumClasses-1;
      HTuple step_val184 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val184, step_val184); hv_Index += step_val184)
      {
        //Compute the precision for every selected class.
        GetValueMatrix(hv_AbsoluteConfusionMatrix, HTuple(hv_ClassIDs[hv_Index]), 
            HTuple(hv_ClassIDs[hv_Index]), &hv_TruePositive);
        GetValueMatrix(hv_MatrixRowSumID, HTuple(hv_ClassIDs[hv_Index]), 0, &hv_SumPredictedClass);
        GetValueMatrix(hv_MatrixColumnSumID, 0, HTuple(hv_ClassIDs[hv_Index]), &hv_SumLabel);
        if (0 != (int(hv_SumLabel<=0)))
        {
          //Invalid per-class precision.
          hv_ClassPrecision = -1.0;
        }
        else if (0 != (int(hv_SumPredictedClass==0)))
        {
          hv_ClassPrecision = 0.0;
        }
        else
        {
          hv_ClassPrecision = hv_TruePositive/hv_SumPredictedClass;
        }
        hv_ClassPrecisions = hv_ClassPrecisions.TupleConcat(hv_ClassPrecision);
      }
      }
      TupleSelectMask(hv_ClassPrecisions, hv_ClassPrecisions.TupleGreaterEqualElem(0.0), 
          &hv_ValidClassPrecisions);
      hv_MeanPrecision = hv_ValidClassPrecisions.TupleMean();
      hv_AllClassPrecisions = hv_AllClassPrecisions.TupleConcat(hv_ClassPrecisions);
      hv_AllMeanPrecisions = hv_AllMeanPrecisions.TupleConcat(hv_MeanPrecision);
      ClearMatrix(hv_MatrixRowSumID);
    }
    }
    SetDictTuple(hv_GlobalEvaluation, "precision_per_class", hv_AllClassPrecisions);
    SetDictTuple(hv_GlobalEvaluation, "mean_precision", hv_AllMeanPrecisions);
  }
  //
  //Calculate recall.
  if (0 != hv_CalcRecall)
  {
    hv_AllClassRecalls = HTuple();
    hv_AllMeanRecalls = HTuple();
    GetDictTuple((*hv_EvaluationResult), "absolute_confusion_matrix", &hv_AbsoluteConfustionMatrices);
    {
    HTuple end_val214 = (hv_AbsoluteConfustionMatrices.TupleLength())-1;
    HTuple step_val214 = 1;
    for (hv_IndThreshold=0; hv_IndThreshold.Continue(end_val214, step_val214); hv_IndThreshold += step_val214)
    {
      hv_AbsoluteConfusionMatrixDictionary = HTuple(hv_AbsoluteConfustionMatrices[hv_IndThreshold]);
      GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix", &hv_AbsoluteConfusionMatrix);
      hv_ClassRecalls = HTuple();
      SumMatrix(hv_AbsoluteConfusionMatrix, "columns", &hv_MatrixColumnSumID);
      {
      HTuple end_val219 = hv_NumClasses-1;
      HTuple step_val219 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val219, step_val219); hv_Index += step_val219)
      {
        //Compute the recall for every selected class.
        GetValueMatrix(hv_AbsoluteConfusionMatrix, HTuple(hv_ClassIDs[hv_Index]), 
            HTuple(hv_ClassIDs[hv_Index]), &hv_TruePositive);
        GetValueMatrix(hv_MatrixColumnSumID, 0, HTuple(hv_ClassIDs[hv_Index]), &hv_SumLabel);
        if (0 != (int(hv_SumLabel==0)))
        {
          //Invalid per-class recall.
          hv_ClassRecall = -1.0;
        }
        else
        {
          hv_ClassRecall = hv_TruePositive/hv_SumLabel;
        }
        hv_ClassRecalls = hv_ClassRecalls.TupleConcat(hv_ClassRecall);
      }
      }
      TupleSelectMask(hv_ClassRecalls, hv_ClassRecalls.TupleGreaterEqualElem(0.0), 
          &hv_ValidClassRecalls);
      hv_MeanRecall = hv_ValidClassRecalls.TupleMean();
      hv_AllClassRecalls = hv_AllClassRecalls.TupleConcat(hv_ClassRecalls);
      hv_AllMeanRecalls = hv_AllMeanRecalls.TupleConcat(hv_MeanRecall);
      ClearMatrix(hv_MatrixColumnSumID);
      //
    }
    }
    SetDictTuple(hv_GlobalEvaluation, "recall_per_class", hv_AllClassRecalls);
    SetDictTuple(hv_GlobalEvaluation, "mean_recall", hv_AllMeanRecalls);
  }
  //
  if (0 != (hv_CalcPrecision.TupleOr(hv_CalcRecall)))
  {
    SetDictTuple((*hv_EvaluationResult), "global_evaluation", hv_GlobalEvaluation);
  }
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Calculate image classification measures based on RunningMeasures. 
void calculate_image_classification_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_TopKErrorKs, hv_CalcPrecision, hv_CalcRecall;
  HTuple  hv_CalcFScore, hv_CalcAbsoluteConfusionMatrix, hv_CalcRelativeConfusionMatrix;
  HTuple  hv_Measures, hv_RegExpTopKError, hv_M, hv_ComputeTopKError;
  HTuple  hv_K, hv_ClassIDs, hv_KeyExists, hv_ClassesToEvaluate;
  HTuple  hv_ClassIDsToEvaluate, hv_ClassNames, hv_Index;
  HTuple  hv_Position, hv_ImageIDs, hv_ImageLabelIDs, hv_Predictions;
  HTuple  hv_TopKPredictions, hv_EvalIndex, hv_CurrentEvalClass;
  HTuple  hv_IndexClass, hv_EvaluatedSamples, hv_ConfusionMatrix;
  HTuple  hv_RelativeConfusionMatrix, hv_EvalClassID, hv_KIndex;
  HTuple  hv_Indices, hv_TopKError, hv_NumClasses, hv_ClassPrecisions;
  HTuple  hv_MatrixRowSumID, hv_TruePositive, hv_SumPredictedClass;
  HTuple  hv_ClassPrecision, hv_Precision, hv_ClassRecalls;
  HTuple  hv_MatrixColumnSumID, hv_SumLabel, hv_ClassRecall;
  HTuple  hv_Recall, hv_ClassFScores, hv_SumPrecisionRecall;
  HTuple  hv_PositiveIndices, hv_FScore, hv_KeyName;

  //
  //This procedure calculates the final summarizing image classification measures based on the running measures.
  //
  //Set default values.
  hv_TopKErrorKs = HTuple();
  hv_CalcPrecision = 0;
  hv_CalcRecall = 0;
  hv_CalcFScore = 0;
  hv_CalcAbsoluteConfusionMatrix = 0;
  hv_CalcRelativeConfusionMatrix = 0;
  //
  //Check which measures are to be calculated.
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  hv_RegExpTopKError = "top([0-9]+)_error";
  {
  HTuple end_val14 = (hv_Measures.TupleLength())-1;
  HTuple step_val14 = 1;
  for (hv_M=0; hv_M.Continue(end_val14, step_val14); hv_M += step_val14)
  {
    hv_ComputeTopKError = HTuple(hv_Measures[hv_M]).TupleRegexpTest("top([0-9]+)_error");
    if (0 != hv_ComputeTopKError)
    {
      hv_K = (HTuple(hv_Measures[hv_M]).TupleRegexpMatch(hv_RegExpTopKError)).TupleNumber();
      hv_TopKErrorKs = (hv_TopKErrorKs.TupleConcat(hv_K)).TupleSort();
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("precision"))))
    {
      hv_CalcPrecision = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("recall"))))
    {
      hv_CalcRecall = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("f_score"))))
    {
      hv_CalcFScore = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("absolute_confusion_matrix"))))
    {
      hv_CalcAbsoluteConfusionMatrix = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("relative_confusion_matrix"))))
    {
      hv_CalcRelativeConfusionMatrix = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("all"))))
    {
      hv_TopKErrorKs = (hv_TopKErrorKs.TupleConcat(1)).TupleSort();
      hv_CalcPrecision = 1;
      hv_CalcRecall = 1;
      hv_CalcFScore = 1;
      hv_CalcAbsoluteConfusionMatrix = 1;
      hv_CalcRelativeConfusionMatrix = 1;
    }
    else
    {
      throw HException("Unknown image classification measure: "+HTuple(hv_Measures[hv_M]));
    }
  }
  }
  //
  //Initialize output dictionary and get necessary evaluation parameters.
  CreateDict(&(*hv_EvaluationResult));
  GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
  GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate", &hv_KeyExists);
  if (0 != hv_KeyExists)
  {
    GetDictTuple(hv_EvalParams, "class_names_to_evaluate", &hv_ClassesToEvaluate);
    hv_ClassIDsToEvaluate = HTuple();
    GetDictTuple(hv_EvalParams, "class_names", &hv_ClassNames);
    {
    HTuple end_val49 = (hv_ClassesToEvaluate.TupleLength())-1;
    HTuple step_val49 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val49, step_val49); hv_Index += step_val49)
    {
      hv_Position = ((HTuple("global").TupleConcat(hv_ClassNames)).TupleEqualElem(HTuple(hv_ClassesToEvaluate[hv_Index]))).TupleFind(1);
      if (0 != (HTuple(int(hv_Position==-1)).TupleOr(int(hv_Position==HTuple()))))
      {
        throw HException("Invalid entry in  'class_names_to_evaluate': "+HTuple((HTuple("global").TupleConcat(hv_ClassesToEvaluate))[hv_Index]));
      }
      hv_ClassIDsToEvaluate = hv_ClassIDsToEvaluate.TupleConcat(HTuple((HTuple("global").TupleConcat(hv_ClassIDs))[hv_Position]));
    }
    }
    SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
  }
  GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", &hv_ClassIDsToEvaluate);
  //
  //Get and check values in RunningMeasures.
  GetDictTuple(hv_RunningMeasures, "image_ids", &hv_ImageIDs);
  GetDictTuple(hv_RunningMeasures, "image_label_ids", &hv_ImageLabelIDs);
  GetDictTuple(hv_RunningMeasures, "top1_predictions", &hv_Predictions);
  GetDictTuple(hv_RunningMeasures, "topk_predictions", &hv_TopKPredictions);
  //
  //Check if needed classes appear in image label IDs.
  //For the confusion matrices, all classes need to be represented.
  hv_CalcAbsoluteConfusionMatrix = HTuple(HTuple(hv_CalcPrecision.TupleOr(hv_CalcRecall)).TupleOr(hv_CalcFScore)).TupleOr(hv_CalcAbsoluteConfusionMatrix);
  hv_CalcRelativeConfusionMatrix = HTuple(HTuple(hv_CalcPrecision.TupleOr(hv_CalcRecall)).TupleOr(hv_CalcFScore)).TupleOr(hv_CalcRelativeConfusionMatrix);
  if (0 != (hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)))
  {
    if (0 != (int(((hv_ImageLabelIDs.TupleSort()).TupleUniq())!=(hv_ClassIDs.TupleSort()))))
    {
      throw HException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
    }
  }
  //For top-K errors, the evaluated classes need to be represented.
  if (0 != (int(hv_TopKErrorKs!=HTuple())))
  {
    {
    HTuple end_val77 = (hv_ClassIDsToEvaluate.TupleLength())-1;
    HTuple step_val77 = 1;
    for (hv_EvalIndex=0; hv_EvalIndex.Continue(end_val77, step_val77); hv_EvalIndex += step_val77)
    {
      hv_CurrentEvalClass = HTuple(hv_ClassIDsToEvaluate[hv_EvalIndex]);
      if (0 != (int(hv_CurrentEvalClass!=HTuple("global"))))
      {
        hv_IndexClass = hv_ImageLabelIDs.TupleFind(hv_CurrentEvalClass);
        if (0 != (HTuple(int(hv_IndexClass==-1)).TupleOr(int(hv_IndexClass==HTuple()))))
        {
          throw HException(("The evaluated class ID "+hv_CurrentEvalClass)+" is not represented in the ground truth labels.");
        }
      }
    }
    }
  }
  //
  //Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.
  CreateDict(&hv_EvaluatedSamples);
  SetDictTuple(hv_EvaluatedSamples, "image_ids", hv_ImageIDs);
  SetDictTuple(hv_EvaluatedSamples, "image_label_ids", hv_ImageLabelIDs);
  SetDictTuple(hv_EvaluatedSamples, "top1_predictions", hv_Predictions);
  SetDictTuple((*hv_EvaluationResult), "evaluated_samples", hv_EvaluatedSamples);
  //
  //Calculate absolute confusion matrix if needed and set it to EvaluationResult.
  if (0 != hv_CalcAbsoluteConfusionMatrix)
  {
    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, "display_matrix", "none", 
        HTuple(), &hv_ConfusionMatrix);
    SetDictTuple((*hv_EvaluationResult), "absolute_confusion_matrix", hv_ConfusionMatrix);
  }
  //
  //Calculate relative confusion matrix.
  if (0 != hv_CalcRelativeConfusionMatrix)
  {
    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (HTuple("display_matrix").Append("return_matrix")), 
        (HTuple("none").Append("relative")), HTuple(), &hv_RelativeConfusionMatrix);
    SetDictTuple((*hv_EvaluationResult), "relative_confusion_matrix", hv_RelativeConfusionMatrix);
  }
  //
  // Calculate measures for every class to be evaluated.
  {
  HTuple end_val108 = (hv_ClassIDsToEvaluate.TupleLength())-1;
  HTuple step_val108 = 1;
  for (hv_EvalIndex=0; hv_EvalIndex.Continue(end_val108, step_val108); hv_EvalIndex += step_val108)
  {
    hv_CurrentEvalClass = HTuple(hv_ClassIDsToEvaluate[hv_EvalIndex]);
    CreateDict(&hv_EvalClassID);
    //
    //Calculate top-K errors.
    {
    HTuple end_val113 = (hv_TopKErrorKs.TupleLength())-1;
    HTuple step_val113 = 1;
    for (hv_KIndex=0; hv_KIndex.Continue(end_val113, step_val113); hv_KIndex += step_val113)
    {
      hv_K = HTuple(hv_TopKErrorKs[hv_KIndex]);
      if (0 != (int(hv_CurrentEvalClass==HTuple("global"))))
      {
        hv_Indices = HTuple::TupleGenSequence(0,(hv_ImageLabelIDs.TupleLength())-1,1);
      }
      else
      {
        hv_Indices = hv_ImageLabelIDs.TupleFind(hv_CurrentEvalClass);
      }
      compute_top_k_error(HTuple(hv_ImageLabelIDs[hv_Indices]), HTuple(hv_TopKPredictions[hv_Indices]), 
          hv_K, &hv_TopKError);
      SetDictTuple(hv_EvalClassID, ("top"+hv_K)+"_error", hv_TopKError);
    }
    }
    //
    if (0 != (int(hv_CurrentEvalClass==HTuple("global"))))
    {
      //Compute the mean of the measures for all classes.
      hv_NumClasses = hv_ClassIDs.TupleLength();
      hv_IndexClass = hv_ClassIDs;
    }
    else
    {
      //Compute the measures for a certain class.
      hv_NumClasses = 1;
      hv_IndexClass = hv_ClassIDs.TupleFind(hv_CurrentEvalClass);
    }
    //
    //Calculate prediction.
    if (0 != (hv_CalcPrecision.TupleOr(hv_CalcFScore)))
    {
      hv_ClassPrecisions = HTuple();
      SumMatrix(hv_ConfusionMatrix, "rows", &hv_MatrixRowSumID);
      {
      HTuple end_val138 = hv_NumClasses-1;
      HTuple step_val138 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val138, step_val138); hv_Index += step_val138)
      {
        //Compute the precision for every selected class.
        GetValueMatrix(hv_ConfusionMatrix, HTuple(hv_IndexClass[hv_Index]), HTuple(hv_IndexClass[hv_Index]), 
            &hv_TruePositive);
        GetValueMatrix(hv_MatrixRowSumID, HTuple(hv_IndexClass[hv_Index]), 0, &hv_SumPredictedClass);
        if (0 != (int(hv_SumPredictedClass==0)))
        {
          hv_ClassPrecision = 0;
        }
        else
        {
          hv_ClassPrecision = hv_TruePositive/hv_SumPredictedClass;
        }
        hv_ClassPrecisions = hv_ClassPrecisions.TupleConcat(hv_ClassPrecision);
      }
      }
      hv_Precision = hv_ClassPrecisions.TupleMean();
      ClearMatrix(hv_MatrixRowSumID);
      if (0 != (int(hv_NumClasses==1)))
      {
        SetDictTuple(hv_EvalClassID, "precision", hv_Precision);
      }
      else
      {
        SetDictTuple(hv_EvalClassID, "mean_precision", hv_Precision);
        SetDictTuple(hv_EvalClassID, "precision_per_class", hv_ClassPrecisions);
      }
    }
    //
    //Calculate recall.
    if (0 != (hv_CalcRecall.TupleOr(hv_CalcFScore)))
    {
      hv_ClassRecalls = HTuple();
      SumMatrix(hv_ConfusionMatrix, "columns", &hv_MatrixColumnSumID);
      {
      HTuple end_val163 = hv_NumClasses-1;
      HTuple step_val163 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val163, step_val163); hv_Index += step_val163)
      {
        //Compute the recall for every class.
        GetValueMatrix(hv_ConfusionMatrix, HTuple(hv_IndexClass[hv_Index]), HTuple(hv_IndexClass[hv_Index]), 
            &hv_TruePositive);
        GetValueMatrix(hv_MatrixColumnSumID, 0, HTuple(hv_IndexClass[hv_Index]), 
            &hv_SumLabel);
        hv_ClassRecall = hv_TruePositive/hv_SumLabel;
        hv_ClassRecalls = hv_ClassRecalls.TupleConcat(hv_ClassRecall);
      }
      }
      hv_Recall = hv_ClassRecalls.TupleMean();
      ClearMatrix(hv_MatrixColumnSumID);
      if (0 != (int(hv_NumClasses==1)))
      {
        SetDictTuple(hv_EvalClassID, "recall", hv_Recall);
      }
      else
      {
        SetDictTuple(hv_EvalClassID, "mean_recall", hv_Recall);
        SetDictTuple(hv_EvalClassID, "recall_per_class", hv_ClassRecalls);
      }
    }
    //
    //Calculate F-score.
    if (0 != hv_CalcFScore)
    {
      TupleGenConst(hv_ClassPrecisions.TupleLength(), 0.0, &hv_ClassFScores);
      hv_SumPrecisionRecall = hv_ClassPrecisions+hv_ClassRecalls;
      hv_PositiveIndices = (hv_SumPrecisionRecall.TupleNotEqualElem(0.0)).TupleFind(1);
      if (0 != (HTuple(int(hv_PositiveIndices!=-1)).TupleAnd(int(hv_PositiveIndices!=HTuple()))))
      {
        hv_ClassFScores[hv_PositiveIndices] = ((2*HTuple(hv_ClassPrecisions[hv_PositiveIndices]))*HTuple(hv_ClassRecalls[hv_PositiveIndices]))/HTuple(hv_SumPrecisionRecall[hv_PositiveIndices]);
      }
      hv_FScore = hv_ClassFScores.TupleMean();
      if (0 != (int(hv_NumClasses==1)))
      {
        SetDictTuple(hv_EvalClassID, "f_score", hv_FScore);
      }
      else
      {
        SetDictTuple(hv_EvalClassID, "mean_f_score", hv_FScore);
        SetDictTuple(hv_EvalClassID, "f_score_per_class", hv_ClassFScores);
      }
    }
    //
    //Set evaluation results for current class ID.
    hv_KeyName = HTuple(hv_ClassIDsToEvaluate[hv_EvalIndex]);
    if (0 != (int(HTuple(hv_ClassIDsToEvaluate[hv_EvalIndex])!=HTuple("global"))))
    {
      hv_KeyName = "class_id_"+hv_KeyName;
    }
    SetDictTuple((*hv_EvaluationResult), hv_KeyName, hv_EvalClassID);
  }
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Calculate instance measures based on RunningMeasures. 
void calculate_instance_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CalcClassAP, hv_CalcMeanAP, hv_CalcSoAP;
  HTuple  hv_EvalType, hv_InstanceType, hv_Measures, hv_M;
  HTuple  hv_ClassIDs, hv_NumClasses, hv_MaxNumDetections;
  HTuple  hv_AreaRanges, hv_IoUThresholds, hv_DetailedEvaluation;
  HTuple  hv_InterpolatePRCurves, hv_KeyExists, hv_AreaNames;
  HTuple  hv_MinAreas, hv_MaxAreas, hv_RecThreshs, hv_MDIdx;
  HTuple  hv_MaxNum, hv_MaxNumStr, hv_CurrentRunningMeasures;
  HTuple  hv_PerMaxNumEvaluationResult, hv_AreaIdx, hv_MinArea;
  HTuple  hv_MaxArea, hv_AreaName, hv_AreaRunningMeasures;
  HTuple  hv_PerClassNumGt, hv_PerClassNumPred, hv_PerClassConfidence;
  HTuple  hv_PerClassNumGtIgnore, hv_CurrentEvaluationResult;
  HTuple  hv_ITIdx, hv_PerIoUAP, hv_PerIoUSoAP, hv_PerIoUDetailedEvaluation;
  HTuple  hv_ClsIdx, hv_PerClassDetailedEvaluation, hv_DetectionConfusionMatrix;
  HTuple  hv_PerIoUMeasure, hv_NumImgIDsWithFN, hv_NumImgIDsWithFP;
  HTuple  hv_ImgIDsWithFN, hv_ImgIDsWithFP, hv_ClassMAPDict;
  HTuple  hv_ClassMSoAPDict, hv_ClassesWithGt, hv_PerClassMAP;
  HTuple  hv_PerIoUMAP, hv_PerClassMSoAP, hv_PerIoUMSoAP;
  HTuple  hv_PerIoUNumClassesWithTP, hv_PerIoUTP, hv_PerIoUFN;
  HTuple  hv_PerIoUFP, hv_PerIoUFPClass, hv_PerIoUFPBackground;
  HTuple  hv_PerIoUFPLocalization, hv_PerIoUFPDuplicate, hv_PerIoUFPMultiple;
  HTuple  hv_PerIoUSoAPClass, hv_PerIoUSoAPLocalization, hv_PerIoUSoAPDuplicate;
  HTuple  hv_PerIoUSoAPMultiple, hv_PerIoUNumClassesWithFPClass;
  HTuple  hv_PerIoUNumClassesWithFPLocalization, hv_PerIoUNumClassesWithFPDuplicate;
  HTuple  hv_PerIoUNumClassesWithFPMultiple, hv_ClassAPPerIoU;
  HTuple  hv_ClassSoAPPerIoU, hv_NumGt, hv_NumGtIgnore, hv_NumPred;
  HTuple  hv_Confidences, hv_SortIdxs, hv_CurrentClassMeasures;
  HTuple  hv_IsTP, hv_Ignore, hv_NoIgnoreIdxs, hv_IsFP, hv_AccumulatedIsTP;
  HTuple  hv_AccumulatedIsFP, hv_Recall, hv_Precision, hv_InterpolatedPrecision;
  HTuple  hv_PIdx, hv_PrecisionAtRecThreshs, hv_RTIdx, hv_RecQuantile;
  HTuple  hv_AOD, hv_IdxsTP, hv_IsFPClass, hv_IsFPBackground;
  HTuple  hv_IsFPLocalization, hv_IsFPDuplicate, hv_IsFPMultiple;
  HTuple  hv_NumTP, hv_NumFP, hv_NumFN, hv_NumFPClass, hv_NumFPBackground;
  HTuple  hv_NumFPLocalization, hv_NumFPDuplicate, hv_NumFPMultiple;
  HTuple  hv_IndicesWithClassConfusion, hv_IsFPClassIdxs;
  HTuple  hv_ClassIdxsConfused, hv_Idx, hv_NumConfusedThisIdx;
  HTuple  hv_AODClass, hv_IdxsClass, hv_ResSoAPClass, hv_AODLocalization;
  HTuple  hv_IdxsLocalization, hv_ResSoAPLocalization, hv_AODDuplicate;
  HTuple  hv_IdxsDuplicate, hv_ResSoAPDuplicate, hv_AODMultiple;
  HTuple  hv_IdxsMultiple, hv_ResSoAPMultiple, hv_SoAPIoUIdxsPositive;
  HTuple  hv_MeanClassAP, hv_MeanClassSoAP, hv_MAP, hv_MSoAP;
  HTuple  hv_IoUsWithTP, hv_MSoAPAll, hv_NumSoAPAll, hv_IoUsWithFPClass;
  HTuple  hv_IoUsWithFPLocalization, hv_IoUsWithFPDuplicate;
  HTuple  hv_IoUsWithFPMultiple;

  //
  //This procedure calculates the final summarizing instance measures based on the running measures.
  //
  //Set default values.
  hv_CalcClassAP = 0;
  hv_CalcMeanAP = 0;
  hv_CalcSoAP = 0;
  //Check which measures are to be calculated.
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvalType);
  GetDictTuple(hv_EvalParams, "instance_type", &hv_InstanceType);
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  {
  HTuple end_val11 = (hv_Measures.TupleLength())-1;
  HTuple step_val11 = 1;
  for (hv_M=0; hv_M.Continue(end_val11, step_val11); hv_M += step_val11)
  {
    if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("mean_ap"))))
    {
      hv_CalcMeanAP = 1;
      //As we need to calculate the class APs anyway, we also write them out.
      hv_CalcClassAP = 1;
    }
    else if (0 != (HTuple(int(HTuple(hv_Measures[hv_M])==HTuple("soap"))).TupleAnd(int(hv_InstanceType==HTuple("rectangle2")))))
    {
      hv_CalcSoAP = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("all"))))
    {
      hv_CalcClassAP = 1;
      hv_CalcMeanAP = 1;
      if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
      {
        hv_CalcSoAP = 1;
      }
    }
    else
    {
      if (0 != (HTuple(int(hv_EvalType==HTuple("ocr_detection"))).TupleAnd(HTuple(HTuple(int(HTuple(hv_Measures[hv_M])==HTuple("recall"))).TupleOr(int(HTuple(hv_Measures[hv_M])==HTuple("precision")))).TupleOr(int(HTuple(hv_Measures[hv_M])==HTuple("f_score"))))))
      {
        hv_CalcMeanAP = 1;
        hv_CalcClassAP = 1;
        continue;
      }
      else
      {
        throw HException("Unknown Instance Measure: "+HTuple(hv_Measures[hv_M]));
      }
    }
  }
  }
  //*
  //Dependencies of measures:
  //
  //Recall (per-class)       *                   --> AP per class --> mAP
  //Precision (per-class)  /
  //
  //*
  //Initialize output dictionary and get necessary evaluation parameters.
  CreateDict(&(*hv_EvaluationResult));
  GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
  GetDictTuple(hv_EvalParams, "num_classes", &hv_NumClasses);
  GetDictTuple(hv_EvalParams, "max_num_detections", &hv_MaxNumDetections);
  GetDictTuple(hv_EvalParams, "area_ranges", &hv_AreaRanges);
  GetDictTuple(hv_EvalParams, "iou_threshold", &hv_IoUThresholds);
  //Check if a detailed evaluation should be done and if PR-curves should be interpolated.
  hv_DetailedEvaluation = 0;
  hv_InterpolatePRCurves = 0;
  GetDictParam(hv_EvalParams, "key_exists", (HTuple("detailed_evaluation").Append("interpolate_pr_curves")), 
      &hv_KeyExists);
  if (0 != (HTuple(hv_KeyExists[0])))
  {
    GetDictTuple(hv_EvalParams, "detailed_evaluation", &hv_DetailedEvaluation);
  }
  if (0 != (HTuple(hv_KeyExists[1])))
  {
    GetDictTuple(hv_EvalParams, "interpolate_pr_curves", &hv_InterpolatePRCurves);
  }
  //
  //Get information about area ranges.
  GetDictTuple(hv_AreaRanges, "name", &hv_AreaNames);
  GetDictTuple(hv_AreaRanges, "min", &hv_MinAreas);
  GetDictTuple(hv_AreaRanges, "max", &hv_MaxAreas);
  //
  //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
  hv_RecThreshs = HTuple::TupleGenSequence(0.0,1.0,0.01);
  //Start with calculation.
  if (0 != (HTuple(hv_CalcClassAP.TupleOr(hv_CalcMeanAP)).TupleOr(hv_CalcSoAP)))
  {
    //Loop over maximal number of detections.
    {
    HTuple end_val69 = (hv_MaxNumDetections.TupleLength())-1;
    HTuple step_val69 = 1;
    for (hv_MDIdx=0; hv_MDIdx.Continue(end_val69, step_val69); hv_MDIdx += step_val69)
    {
      //
      //Get corresponding running measures.
      hv_MaxNum = HTuple(hv_MaxNumDetections[hv_MDIdx]);
      hv_MaxNumStr = ""+hv_MaxNum;
      if (0 != (int(hv_MaxNum==-1)))
      {
        hv_MaxNumStr = "all";
      }
      GetDictTuple(hv_RunningMeasures, "max_num_detections_"+hv_MaxNumStr, &hv_CurrentRunningMeasures);
      //
      //Initialize output dictionary.
      CreateDict(&hv_PerMaxNumEvaluationResult);
      //
      //Loop over area ranges.
      {
      HTuple end_val83 = (hv_AreaNames.TupleLength())-1;
      HTuple step_val83 = 1;
      for (hv_AreaIdx=0; hv_AreaIdx.Continue(end_val83, step_val83); hv_AreaIdx += step_val83)
      {
        //Get area thresholds.
        hv_MinArea = HTuple(hv_MinAreas[hv_AreaIdx]);
        hv_MaxArea = HTuple(hv_MaxAreas[hv_AreaIdx]);
        hv_AreaName = HTuple(hv_AreaNames[hv_AreaIdx]);
        //
        GetDictTuple(hv_CurrentRunningMeasures, "area_"+hv_AreaName, &hv_AreaRunningMeasures);
        //
        GetDictTuple(hv_AreaRunningMeasures, "num_gt", &hv_PerClassNumGt);
        GetDictTuple(hv_AreaRunningMeasures, "num_pred", &hv_PerClassNumPred);
        GetDictTuple(hv_AreaRunningMeasures, "confidence", &hv_PerClassConfidence);
        GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", &hv_PerClassNumGtIgnore);
        //
        //Initialize output dictionary.
        CreateDict(&hv_CurrentEvaluationResult);
        {
        HTuple end_val98 = (hv_IoUThresholds.TupleLength())-1;
        HTuple step_val98 = 1;
        for (hv_ITIdx=0; hv_ITIdx.Continue(end_val98, step_val98); hv_ITIdx += step_val98)
        {
          CreateDict(&hv_PerIoUAP);
          SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
              hv_PerIoUAP);
          if (0 != hv_CalcSoAP)
          {
            CreateDict(&hv_PerIoUSoAP);
            SetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                hv_PerIoUSoAP);
          }
          if (0 != hv_DetailedEvaluation)
          {
            //Initialize detailed measures.
            CreateDict(&hv_PerIoUDetailedEvaluation);
            {
            HTuple end_val108 = hv_NumClasses-1;
            HTuple step_val108 = 1;
            for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val108, step_val108); hv_ClsIdx += step_val108)
            {
              CreateDict(&hv_PerClassDetailedEvaluation);
              //Initialize with zeros in case there is no ground truth for this class.
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp", 0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn", 0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp", 0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class", 0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background", 0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate", 0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization", 
                  0);
              SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple", 0);
              if (0 != hv_CalcSoAP)
              {
                SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class", -1);
                SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate", 
                    -1);
                SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization", 
                    -1);
                SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple", -1);
              }
              SetDictTuple(hv_PerIoUDetailedEvaluation, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                  hv_PerClassDetailedEvaluation);
            }
            }
            CreateMatrix(hv_NumClasses+1, hv_NumClasses+4, 0, &hv_DetectionConfusionMatrix);
            SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix", 
                hv_DetectionConfusionMatrix);
            //
            //Get and set image IDs with false negatives and false positives.
            GetDictTuple(hv_AreaRunningMeasures, "iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                &hv_PerIoUMeasure);
            //Get image IDs with false negatives and false positives, respectively.
            GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives", 
                &hv_NumImgIDsWithFN);
            GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives", 
                &hv_NumImgIDsWithFP);
            GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives", &hv_ImgIDsWithFN);
            GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives", &hv_ImgIDsWithFP);
            //Set in current output.
            SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives", 
                hv_ImgIDsWithFN.TupleSelectRange(0,hv_NumImgIDsWithFN-1));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives", 
                hv_ImgIDsWithFP.TupleSelectRange(0,hv_NumImgIDsWithFP-1));
            //
            //Set output for this IoU.
            SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                hv_PerIoUDetailedEvaluation);
          }
        }
        }
        CreateDict(&hv_ClassMAPDict);
        SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap", hv_ClassMAPDict);
        if (0 != hv_CalcSoAP)
        {
          CreateDict(&hv_ClassMSoAPDict);
          SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp", hv_ClassMSoAPDict);
        }
        //
        //Check which classes have ground truth annotations.
        hv_ClassesWithGt = ((hv_PerClassNumGt-hv_PerClassNumGtIgnore).TupleGreaterElem(0)).TupleFind(1);
        if (0 != (int(hv_ClassesWithGt==-1)))
        {
          hv_ClassesWithGt = HTuple();
        }
        //
        //Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.
        hv_PerClassMAP = HTuple(hv_NumClasses,-1.0);
        //
        //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
        hv_PerIoUMAP = HTuple(hv_IoUThresholds.TupleLength(),0.0);
        //
        if (0 != hv_CalcSoAP)
        {
          //Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.
          hv_PerClassMSoAP = HTuple(hv_NumClasses,-1.0);
          //Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.
          hv_PerIoUMSoAP = HTuple(hv_IoUThresholds.TupleLength(),0.0);
          //Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occurred.
          hv_PerIoUNumClassesWithTP = HTuple(hv_IoUThresholds.TupleLength(),0);
        }
        //
        if (0 != hv_DetailedEvaluation)
        {
          //Initialize overall num_fn, num_tp, ...
          hv_PerIoUTP = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFN = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFP = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFPClass = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFPBackground = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFPLocalization = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFPDuplicate = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_PerIoUFPMultiple = HTuple(hv_IoUThresholds.TupleLength(),0);
          if (0 != hv_CalcSoAP)
          {
            hv_PerIoUSoAPClass = HTuple(hv_IoUThresholds.TupleLength(),-1);
            hv_PerIoUSoAPLocalization = HTuple(hv_IoUThresholds.TupleLength(),-1);
            hv_PerIoUSoAPDuplicate = HTuple(hv_IoUThresholds.TupleLength(),-1);
            hv_PerIoUSoAPMultiple = HTuple(hv_IoUThresholds.TupleLength(),-1);
            hv_PerIoUNumClassesWithFPClass = HTuple(hv_IoUThresholds.TupleLength(),0);
            hv_PerIoUNumClassesWithFPLocalization = HTuple(hv_IoUThresholds.TupleLength(),0);
            hv_PerIoUNumClassesWithFPDuplicate = HTuple(hv_IoUThresholds.TupleLength(),0);
            hv_PerIoUNumClassesWithFPMultiple = HTuple(hv_IoUThresholds.TupleLength(),0);
          }
        }
        //Loop over all classes.
        {
        HTuple end_val195 = hv_NumClasses-1;
        HTuple step_val195 = 1;
        for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val195, step_val195); hv_ClsIdx += step_val195)
        {
          //
          //Initialize per-class AP per IoU-threshold (only for one class).
          hv_ClassAPPerIoU = HTuple(hv_IoUThresholds.TupleLength(),-1.0);
          //
          if (0 != hv_CalcSoAP)
          {
            hv_ClassSoAPPerIoU = HTuple(hv_IoUThresholds.TupleLength(),-1.0);
          }
          //Get results for this class.
          hv_NumGt = HTuple(hv_PerClassNumGt[hv_ClsIdx]);
          hv_NumGtIgnore = HTuple(hv_PerClassNumGtIgnore[hv_ClsIdx]);
          if (0 != (int((hv_NumGt-hv_NumGtIgnore)>0)))
          {
            hv_NumPred = HTuple(hv_PerClassNumPred[hv_ClsIdx]);
            GetDictTuple(hv_PerClassConfidence, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                &hv_Confidences);
            //
            //Sort the confidences in descending order and
            //only take the first NumPred ones due to block allocation.
            hv_SortIdxs = (-(hv_Confidences.TupleSelectRange(0,hv_NumPred-1))).TupleSortIndex();
            hv_Confidences = HTuple(hv_Confidences[hv_SortIdxs]);
          }
          //
          //Loop over IoU thresholds.
          {
          HTuple end_val217 = (hv_IoUThresholds.TupleLength())-1;
          HTuple step_val217 = 1;
          for (hv_ITIdx=0; hv_ITIdx.Continue(end_val217, step_val217); hv_ITIdx += step_val217)
          {
            //
            //Check if there are ground truth labels for this class.
            if (0 != (int((hv_NumGt-hv_NumGtIgnore)>0)))
            {
              //
              //Get results for this class and IoU-threshold.
              GetDictTuple(hv_AreaRunningMeasures, "iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                  &hv_PerIoUMeasure);
              GetDictTuple(hv_PerIoUMeasure, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                  &hv_CurrentClassMeasures);
              GetDictTuple(hv_CurrentClassMeasures, "is_tp", &hv_IsTP);
              GetDictTuple(hv_CurrentClassMeasures, "ignore", &hv_Ignore);
              //
              //Sort the arrays IsTP and Ignore according to the confidence values.
              hv_IsTP = HTuple(hv_IsTP[hv_SortIdxs]);
              hv_Ignore = HTuple(hv_Ignore[hv_SortIdxs]);
              //
              //Sort out the ignored results.
              if (0 != (int((hv_IsTP.TupleLength())>0)))
              {
                hv_NoIgnoreIdxs = hv_Ignore.TupleFind(0);
                if (0 != (int(hv_NoIgnoreIdxs!=-1)))
                {
                  hv_IsTP = HTuple(hv_IsTP[hv_NoIgnoreIdxs]);
                  hv_IsFP = hv_IsTP.TupleNot();
                }
                else
                {
                  hv_IsTP = HTuple();
                  hv_IsFP = HTuple();
                }
              }
              else
              {
                hv_IsFP = HTuple();
              }
              //
              //Accumulate IsTP and IsFP.
              hv_AccumulatedIsTP = hv_IsTP.TupleCumul();
              hv_AccumulatedIsFP = hv_IsFP.TupleCumul();
              //
              //Compute recall.
              //The recall is computed with respect to all ground truth instances,
              //independent of MaxNum.
              hv_Recall = (hv_AccumulatedIsTP.TupleReal())/(hv_NumGt-hv_NumGtIgnore);
              //
              //Compute precision.
              hv_Precision = (hv_AccumulatedIsTP.TupleReal())/(hv_AccumulatedIsTP+hv_AccumulatedIsFP);
              //
              //(Optionally) smooth precision-recall curve.
              hv_InterpolatedPrecision = hv_Precision;
              if (0 != hv_InterpolatePRCurves)
              {
                for (hv_PIdx=hv_NumPred-2; hv_PIdx>=0; hv_PIdx+=-1)
                {
                  hv_InterpolatedPrecision[hv_PIdx] = HTuple(hv_InterpolatedPrecision[hv_PIdx]).TupleMax2(HTuple(hv_InterpolatedPrecision[hv_PIdx+1]));
                }
              }
              //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
              hv_PrecisionAtRecThreshs = HTuple(hv_RecThreshs.TupleLength(),0.);
              {
              HTuple end_val267 = (hv_RecThreshs.TupleLength())-1;
              HTuple step_val267 = 1;
              for (hv_RTIdx=0; hv_RTIdx.Continue(end_val267, step_val267); hv_RTIdx += step_val267)
              {
                hv_RecQuantile = (hv_Recall.TupleGreaterEqualElem(HTuple(hv_RecThreshs[hv_RTIdx]))).TupleFindFirst(1);
                if (0 != (int(hv_RecQuantile>-1)))
                {
                  hv_PrecisionAtRecThreshs[hv_RTIdx] = HTuple(hv_InterpolatedPrecision[hv_RecQuantile]);
                }
              }
              }
              //
              //Calculate AP as mean of precision at equidistant recall values.
              hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean();
              //
              //Accumulate AP over classes.
              hv_PerIoUMAP[hv_ITIdx] = HTuple(hv_PerIoUMAP[hv_ITIdx])+HTuple(hv_ClassAPPerIoU[hv_ITIdx]);
              //
              if (0 != hv_CalcSoAP)
              {
                //Calculate SoAP out of the mean over absolute orientation differences.
                GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff", &hv_AOD);
                hv_IdxsTP = hv_IsTP.TupleFind(1);
                if (0 != (HTuple(int((hv_IdxsTP.TupleLength())>0)).TupleAnd(int(hv_IdxsTP!=-1))))
                {
                  hv_ClassSoAPPerIoU[hv_ITIdx] = 1.0-((HTuple(hv_AOD[HTuple(hv_SortIdxs[HTuple(hv_NoIgnoreIdxs[hv_IdxsTP])])]).TupleMean())/(HTuple(180).TupleRad()));
                  //Accumulate SoAP over classes.
                  hv_PerIoUMSoAP[hv_ITIdx] = HTuple(hv_PerIoUMSoAP[hv_ITIdx])+HTuple(hv_ClassSoAPPerIoU[hv_ITIdx]);
                }
                //Update PerIoUNumClassesWithTP.
                if (0 != (int((hv_AccumulatedIsTP.TupleLength())>0)))
                {
                  hv_PerIoUNumClassesWithTP[hv_ITIdx] = HTuple(hv_PerIoUNumClassesWithTP[hv_ITIdx])+(HTuple(hv_AccumulatedIsTP[(hv_AccumulatedIsTP.TupleLength())-1]).TupleGreaterElem(0));
                }
              }
              //
              if (0 != hv_DetailedEvaluation)
              {
                //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                //
                //Get the necessary running measures.
                GetDictTuple(hv_CurrentClassMeasures, "is_fp_class", &hv_IsFPClass);
                GetDictTuple(hv_CurrentClassMeasures, "is_fp_background", &hv_IsFPBackground);
                GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization", &hv_IsFPLocalization);
                GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate", &hv_IsFPDuplicate);
                GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple", &hv_IsFPMultiple);
                //
                //We use the values with maximal recall,
                //in case a higher precision is desired, increase 'min_confidence'.
                if (0 != (int((hv_AccumulatedIsTP.TupleLength())>0)))
                {
                  hv_NumTP = ((const HTuple&)hv_AccumulatedIsTP)[(hv_AccumulatedIsTP.TupleLength())-1];
                }
                else
                {
                  hv_NumTP = 0;
                }
                if (0 != (int((hv_AccumulatedIsFP.TupleLength())>0)))
                {
                  hv_NumFP = ((const HTuple&)hv_AccumulatedIsFP)[(hv_AccumulatedIsFP.TupleLength())-1];
                }
                else
                {
                  hv_NumFP = 0;
                }
                hv_NumFN = (hv_NumGt-hv_NumGtIgnore)-hv_NumTP;
                hv_NumFPClass = (HTuple(hv_IsFPClass[hv_SortIdxs]).TupleGreaterElem(-1)).TupleSum();
                hv_NumFPBackground = (HTuple(hv_IsFPBackground[hv_SortIdxs]).TupleGreaterElem(0)).TupleSum();
                hv_NumFPLocalization = (HTuple(hv_IsFPLocalization[hv_SortIdxs]).TupleGreaterElem(0)).TupleSum();
                hv_NumFPDuplicate = (HTuple(hv_IsFPDuplicate[hv_SortIdxs]).TupleGreaterElem(0)).TupleSum();
                hv_NumFPMultiple = (HTuple(hv_IsFPMultiple[hv_SortIdxs]).TupleGreaterElem(0)).TupleSum();
                if (0 != (int((hv_SortIdxs.TupleLength())==0)))
                {
                  hv_NumFPClass = 0;
                  hv_NumFPBackground = 0;
                  hv_NumFPLocalization = 0;
                  hv_NumFPDuplicate = 0;
                  hv_NumFPMultiple = 0;
                }
                //Consistency checks.
                if (0 != (int(((((((((hv_NumTP.TupleConcat(hv_NumFN)).TupleConcat(hv_NumFP)).TupleConcat(hv_NumFPClass)).TupleConcat(hv_NumFPBackground)).TupleConcat(hv_NumFPLocalization)).TupleConcat(hv_NumFPDuplicate)).TupleConcat(hv_NumFPMultiple)).TupleMin())<0)))
                {
                  throw HException("Fatal error while calculating instance measures.");
                }
                if (0 != (int(hv_NumFP!=((((hv_NumFPClass+hv_NumFPBackground)+hv_NumFPLocalization)+hv_NumFPDuplicate)+hv_NumFPMultiple))))
                {
                  throw HException("Fatal error while calculating instance measures.");
                }
                //
                //Set per-class measures.
                GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                    &hv_PerIoUDetailedEvaluation);
                GetDictTuple(hv_PerIoUDetailedEvaluation, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                    &hv_PerClassDetailedEvaluation);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp", hv_NumTP);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn", hv_NumFN);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp", hv_NumFP);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class", hv_NumFPClass);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background", 
                    hv_NumFPBackground);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate", hv_NumFPDuplicate);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization", 
                    hv_NumFPLocalization);
                SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple", hv_NumFPMultiple);
                //
                //Set detection confusion matrix values.
                GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix", 
                    &hv_DetectionConfusionMatrix);
                SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, hv_ClsIdx, 
                    hv_NumTP);
                SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses, hv_ClsIdx, 
                    hv_NumFN);
                SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, hv_NumClasses, 
                    hv_NumFPBackground);
                SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, hv_NumClasses+1, 
                    hv_NumFPLocalization);
                SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, hv_NumClasses+2, 
                    hv_NumFPDuplicate);
                SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, hv_NumClasses+3, 
                    hv_NumFPMultiple);
                //
                //Go over IsFPClass and set confusions in matrix.
                hv_IndicesWithClassConfusion = (HTuple(hv_IsFPClass[hv_SortIdxs]).TupleGreaterElem(-1)).TupleFind(1);
                hv_IsFPClassIdxs = HTuple();
                if (0 != (int(hv_IndicesWithClassConfusion>-1)))
                {
                  hv_IsFPClassIdxs = HTuple(hv_IsFPClass[HTuple(hv_SortIdxs[hv_IndicesWithClassConfusion])]);
                }
                hv_ClassIdxsConfused = (hv_IsFPClassIdxs.TupleSort()).TupleUniq();
                {
                HTuple end_val366 = (hv_ClassIdxsConfused.TupleLength())-1;
                HTuple step_val366 = 1;
                for (hv_Idx=0; hv_Idx.Continue(end_val366, step_val366); hv_Idx += step_val366)
                {
                  hv_NumConfusedThisIdx = ((hv_IsFPClassIdxs.TupleFind(HTuple(hv_ClassIdxsConfused[hv_Idx]))).TupleGreaterElem(-1)).TupleSum();
                  SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, HTuple(hv_ClassIdxsConfused[hv_Idx]), 
                      hv_NumConfusedThisIdx);
                }
                }
                //
                //Update overall measures.
                hv_PerIoUFN[hv_ITIdx] = HTuple(hv_PerIoUFN[hv_ITIdx])+hv_NumFN;
                hv_PerIoUTP[hv_ITIdx] = HTuple(hv_PerIoUTP[hv_ITIdx])+hv_NumTP;
                hv_PerIoUFP[hv_ITIdx] = HTuple(hv_PerIoUFP[hv_ITIdx])+hv_NumFP;
                hv_PerIoUFPClass[hv_ITIdx] = HTuple(hv_PerIoUFPClass[hv_ITIdx])+hv_NumFPClass;
                hv_PerIoUFPBackground[hv_ITIdx] = HTuple(hv_PerIoUFPBackground[hv_ITIdx])+hv_NumFPBackground;
                hv_PerIoUFPLocalization[hv_ITIdx] = HTuple(hv_PerIoUFPLocalization[hv_ITIdx])+hv_NumFPLocalization;
                hv_PerIoUFPDuplicate[hv_ITIdx] = HTuple(hv_PerIoUFPDuplicate[hv_ITIdx])+hv_NumFPDuplicate;
                hv_PerIoUFPMultiple[hv_ITIdx] = HTuple(hv_PerIoUFPMultiple[hv_ITIdx])+hv_NumFPMultiple;
                if (0 != hv_CalcSoAP)
                {
                  //Calculate and update absolute difference of orientation for class false positives.
                  GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_class", 
                      &hv_AODClass);
                  hv_IdxsClass = (hv_AODClass.TupleGreaterElem(-1)).TupleFind(1);
                  if (0 != (int(hv_IdxsClass!=-1)))
                  {
                    hv_ResSoAPClass = 1.0-((HTuple(hv_AODClass[hv_IdxsClass]).TupleMean())/(HTuple(180).TupleRad()));
                    SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class", 
                        hv_ResSoAPClass);
                    //Update mean over classes.
                    hv_PerIoUNumClassesWithFPClass[hv_ITIdx] = HTuple(hv_PerIoUNumClassesWithFPClass[hv_ITIdx])+1;
                    if (0 != (int(HTuple(hv_PerIoUSoAPClass[hv_ITIdx])==-1)))
                    {
                      hv_PerIoUSoAPClass[hv_ITIdx] = hv_ResSoAPClass;
                    }
                    else
                    {
                      hv_PerIoUSoAPClass[hv_ITIdx] = HTuple(hv_PerIoUSoAPClass[hv_ITIdx])+hv_ResSoAPClass;
                    }
                  }
                  //Calculate and update absolute difference of orientation for localization false positives.
                  GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_localization", 
                      &hv_AODLocalization);
                  hv_IdxsLocalization = (hv_AODLocalization.TupleGreaterElem(-1)).TupleFind(1);
                  if (0 != (int(hv_IdxsLocalization!=-1)))
                  {
                    hv_ResSoAPLocalization = 1.0-((HTuple(hv_AODLocalization[hv_IdxsLocalization]).TupleMean())/(HTuple(180).TupleRad()));
                    SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization", 
                        hv_ResSoAPLocalization);
                    //Update mean over classes.
                    hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx] = HTuple(hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx])+1;
                    if (0 != (int(HTuple(hv_PerIoUSoAPLocalization[hv_ITIdx])==-1)))
                    {
                      hv_PerIoUSoAPLocalization[hv_ITIdx] = hv_ResSoAPLocalization;
                    }
                    else
                    {
                      hv_PerIoUSoAPLocalization[hv_ITIdx] = HTuple(hv_PerIoUSoAPLocalization[hv_ITIdx])+hv_ResSoAPLocalization;
                    }
                  }
                  //Calculate and update absolute difference of orientation for class false positives.
                  GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_duplicate", 
                      &hv_AODDuplicate);
                  hv_IdxsDuplicate = (hv_AODDuplicate.TupleGreaterElem(-1)).TupleFind(1);
                  if (0 != (int(hv_IdxsDuplicate!=-1)))
                  {
                    hv_ResSoAPDuplicate = 1.0-((HTuple(hv_AODDuplicate[hv_IdxsDuplicate]).TupleMean())/(HTuple(180).TupleRad()));
                    SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate", 
                        hv_ResSoAPDuplicate);
                    //Update mean over classes.
                    hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx] = HTuple(hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx])+1;
                    if (0 != (int(HTuple(hv_PerIoUSoAPDuplicate[hv_ITIdx])==-1)))
                    {
                      hv_PerIoUSoAPDuplicate[hv_ITIdx] = hv_ResSoAPDuplicate;
                    }
                    else
                    {
                      hv_PerIoUSoAPDuplicate[hv_ITIdx] = HTuple(hv_PerIoUSoAPDuplicate[hv_ITIdx])+hv_ResSoAPDuplicate;
                    }
                  }
                  //Calculate and update absolute difference of orientation for multiple false positives.
                  GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_multiple", 
                      &hv_AODMultiple);
                  hv_IdxsMultiple = (hv_AODMultiple.TupleGreaterElem(-1)).TupleFind(1);
                  if (0 != (int(hv_IdxsMultiple!=-1)))
                  {
                    hv_ResSoAPMultiple = 1.0-((HTuple(hv_AODMultiple[hv_IdxsMultiple]).TupleMean())/(HTuple(180).TupleRad()));
                    SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple", 
                        hv_ResSoAPMultiple);
                    //Update mean over classes.
                    hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx] = HTuple(hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx])+1;
                    if (0 != (int(HTuple(hv_PerIoUSoAPMultiple[hv_ITIdx])==-1)))
                    {
                      hv_PerIoUSoAPMultiple[hv_ITIdx] = hv_ResSoAPMultiple;
                    }
                    else
                    {
                      hv_PerIoUSoAPMultiple[hv_ITIdx] = HTuple(hv_PerIoUSoAPMultiple[hv_ITIdx])+hv_ResSoAPMultiple;
                    }
                  }
                }
              }
            }
            //
            //Write to output.
            GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                &hv_PerIoUAP);
            SetDictTuple(hv_PerIoUAP, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), HTuple(hv_ClassAPPerIoU[hv_ITIdx]));
            if (0 != hv_CalcSoAP)
            {
              GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                  &hv_PerIoUSoAP);
              SetDictTuple(hv_PerIoUSoAP, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                  HTuple(hv_ClassSoAPPerIoU[hv_ITIdx]));
            }
          }
          }
          //
          //Class mAP is the mean over IoU-thresholds.
          hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
          GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap", &hv_ClassMAPDict);
          SetDictTuple(hv_ClassMAPDict, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
              HTuple(hv_PerClassMAP[hv_ClsIdx]));
          if (0 != hv_CalcSoAP)
          {
            //ClassMSoAP is the mean over IoU-thresholds.
            hv_SoAPIoUIdxsPositive = (hv_ClassSoAPPerIoU.TupleGreaterEqualElem(0.0)).TupleFind(1);
            if (0 != (int(hv_SoAPIoUIdxsPositive!=-1)))
            {
              hv_PerClassMSoAP[hv_ClsIdx] = HTuple(hv_ClassSoAPPerIoU[hv_SoAPIoUIdxsPositive]).TupleMean();
            }
            else
            {
              hv_PerClassMSoAP[hv_ClsIdx] = -1.0;
            }
            GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp", &hv_ClassMSoAPDict);
            SetDictTuple(hv_ClassMSoAPDict, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                HTuple(hv_PerClassMSoAP[hv_ClsIdx]));
          }
        }
        }
        //
        //Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.
        {
        HTuple end_val468 = (hv_IoUThresholds.TupleLength())-1;
        HTuple step_val468 = 1;
        for (hv_ITIdx=0; hv_ITIdx.Continue(end_val468, step_val468); hv_ITIdx += step_val468)
        {
          GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
              &hv_PerIoUAP);
          //
          //Consider only present classes.
          hv_MeanClassAP = -1.0;
          if (0 != (int((hv_ClassesWithGt.TupleLength())>0)))
          {
            hv_MeanClassAP = HTuple(hv_PerIoUMAP[hv_ITIdx])/(hv_ClassesWithGt.TupleLength());
          }
          SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
          if (0 != hv_CalcSoAP)
          {
            GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                &hv_PerIoUSoAP);
            //
            //Consider only present classes.
            hv_MeanClassSoAP = -1.0;
            if (0 != (int(HTuple(hv_PerIoUNumClassesWithTP[hv_ITIdx])>0)))
            {
              hv_MeanClassSoAP = HTuple(hv_PerIoUMSoAP[hv_ITIdx])/HTuple(hv_PerIoUNumClassesWithTP[hv_ITIdx]);
            }
            SetDictTuple(hv_PerIoUSoAP, "mean_class_soap_tp", hv_MeanClassSoAP);
          }
          //
          if (0 != hv_DetailedEvaluation)
          {
            //Add overall measures for TP, FN, FP, ...
            GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                &hv_PerIoUDetailedEvaluation);
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp", HTuple(hv_PerIoUTP[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn", HTuple(hv_PerIoUFN[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp", HTuple(hv_PerIoUFP[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class", HTuple(hv_PerIoUFPClass[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background", HTuple(hv_PerIoUFPBackground[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate", HTuple(hv_PerIoUFPDuplicate[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization", HTuple(hv_PerIoUFPLocalization[hv_ITIdx]));
            SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple", HTuple(hv_PerIoUFPMultiple[hv_ITIdx]));
            if (0 != hv_CalcSoAP)
            {
              if (0 != (int(HTuple(hv_PerIoUNumClassesWithFPClass[hv_ITIdx])>0)))
              {
                hv_PerIoUSoAPClass[hv_ITIdx] = HTuple(hv_PerIoUSoAPClass[hv_ITIdx])/HTuple(hv_PerIoUNumClassesWithFPClass[hv_ITIdx]);
              }
              if (0 != (int(HTuple(hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx])>0)))
              {
                hv_PerIoUSoAPLocalization[hv_ITIdx] = HTuple(hv_PerIoUSoAPLocalization[hv_ITIdx])/HTuple(hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx]);
              }
              if (0 != (int(HTuple(hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx])>0)))
              {
                hv_PerIoUSoAPDuplicate[hv_ITIdx] = HTuple(hv_PerIoUSoAPDuplicate[hv_ITIdx])/HTuple(hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx]);
              }
              if (0 != (int(HTuple(hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx])>0)))
              {
                hv_PerIoUSoAPMultiple[hv_ITIdx] = HTuple(hv_PerIoUSoAPMultiple[hv_ITIdx])/HTuple(hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx]);
              }
              SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_class", HTuple(hv_PerIoUSoAPClass[hv_ITIdx]));
              SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_localization", HTuple(hv_PerIoUSoAPLocalization[hv_ITIdx]));
              SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_duplicate", HTuple(hv_PerIoUSoAPDuplicate[hv_ITIdx]));
              SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_multiple", HTuple(hv_PerIoUSoAPMultiple[hv_ITIdx]));
            }
          }
        }
        }
        //
        //Calculate overall mean AP (over classes and IoU-thresholds).
        //Also here only classes with ground truth annotations are taken into account.
        hv_MAP = -1.0;
        if (0 != (int((hv_ClassesWithGt.TupleLength())>0)))
        {
          hv_MAP = (HTuple(hv_PerClassMAP[hv_ClassesWithGt]).TupleSum())/(hv_ClassesWithGt.TupleLength());
        }
        SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
        if (0 != hv_CalcSoAP)
        {
          hv_MSoAP = -1.0;
          if (0 != (int((hv_PerIoUNumClassesWithTP.TupleSum())>0)))
          {
            hv_IoUsWithTP = (hv_PerIoUNumClassesWithTP.TupleGreaterElem(0)).TupleFind(1);
            hv_MSoAP = ((HTuple(hv_PerIoUMSoAP[hv_IoUsWithTP])/HTuple(hv_PerIoUNumClassesWithTP[hv_IoUsWithTP])).TupleSum())/(hv_IoUsWithTP.TupleLength());
          }
          SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_tp", hv_MSoAP);
          if (0 != hv_DetailedEvaluation)
          {
            hv_MSoAPAll = 0.0;
            hv_NumSoAPAll = 0;
            if (0 != (int((hv_PerIoUNumClassesWithTP.TupleSum())>0)))
            {
              hv_IoUsWithTP = (hv_PerIoUNumClassesWithTP.TupleGreaterElem(0)).TupleFind(1);
              hv_MSoAPAll = hv_MSoAP*(HTuple(hv_PerIoUNumClassesWithTP[hv_IoUsWithTP]).TupleSum());
              hv_NumSoAPAll += HTuple(hv_PerIoUNumClassesWithTP[hv_IoUsWithTP]).TupleSum();
            }
            if (0 != (int((hv_PerIoUNumClassesWithFPClass.TupleSum())>0)))
            {
              hv_IoUsWithFPClass = (hv_PerIoUNumClassesWithFPClass.TupleGreaterElem(0)).TupleFind(1);
              hv_MSoAPAll += ((HTuple(hv_PerIoUSoAPClass[hv_IoUsWithFPClass]).TupleSum())/(hv_IoUsWithFPClass.TupleLength()))*(HTuple(hv_PerIoUNumClassesWithFPClass[hv_IoUsWithFPClass]).TupleSum());
              hv_NumSoAPAll += HTuple(hv_PerIoUNumClassesWithFPClass[hv_IoUsWithFPClass]).TupleSum();
            }
            if (0 != (int((hv_PerIoUNumClassesWithFPLocalization.TupleSum())>0)))
            {
              hv_IoUsWithFPLocalization = (hv_PerIoUNumClassesWithFPLocalization.TupleGreaterElem(0)).TupleFind(1);
              hv_MSoAPAll += ((HTuple(hv_PerIoUSoAPLocalization[hv_IoUsWithFPLocalization]).TupleSum())/(hv_IoUsWithFPLocalization.TupleLength()))*(HTuple(hv_PerIoUNumClassesWithFPLocalization[hv_IoUsWithFPLocalization]).TupleSum());
              hv_NumSoAPAll += HTuple(hv_PerIoUNumClassesWithFPLocalization[hv_IoUsWithFPLocalization]).TupleSum();
            }
            if (0 != (int((hv_PerIoUNumClassesWithFPDuplicate.TupleSum())>0)))
            {
              hv_IoUsWithFPDuplicate = (hv_PerIoUNumClassesWithFPDuplicate.TupleGreaterElem(0)).TupleFind(1);
              hv_MSoAPAll += ((HTuple(hv_PerIoUSoAPDuplicate[hv_IoUsWithFPDuplicate]).TupleSum())/(hv_IoUsWithFPDuplicate.TupleLength()))*(HTuple(hv_PerIoUNumClassesWithFPDuplicate[hv_IoUsWithFPDuplicate]).TupleSum());
              hv_NumSoAPAll += HTuple(hv_PerIoUNumClassesWithFPDuplicate[hv_IoUsWithFPDuplicate]).TupleSum();
            }
            if (0 != (int((hv_PerIoUNumClassesWithFPMultiple.TupleSum())>0)))
            {
              hv_IoUsWithFPMultiple = (hv_PerIoUNumClassesWithFPMultiple.TupleGreaterElem(0)).TupleFind(1);
              hv_MSoAPAll += ((HTuple(hv_PerIoUSoAPMultiple[hv_IoUsWithFPMultiple]).TupleSum())/(hv_IoUsWithFPMultiple.TupleLength()))*(HTuple(hv_PerIoUNumClassesWithFPMultiple[hv_IoUsWithFPMultiple]).TupleSum());
              hv_NumSoAPAll += HTuple(hv_PerIoUNumClassesWithFPMultiple[hv_IoUsWithFPMultiple]).TupleSum();
            }
            if (0 != (int(hv_NumSoAPAll>0)))
            {
              SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all", (hv_MSoAPAll.TupleReal())/hv_NumSoAPAll);
            }
            else
            {
              SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all", -1);
            }
            //
          }
        }
        //
        //Add CurrentEvaluationResult to output.
        SetDictTuple(hv_PerMaxNumEvaluationResult, "area_"+hv_AreaName, hv_CurrentEvaluationResult);
      }
      }
      //Add PerMaxNumEvaluationResult to output.
      SetDictTuple((*hv_EvaluationResult), "max_num_detections_"+hv_MaxNumStr, hv_PerMaxNumEvaluationResult);
    }
    }
  }
  //
  return;
}

// Chapter: OCR / Deep OCR
// Short Description: Computes the ocr_detection relevant evaluation measures. 
void calculate_ocr_detection_measures (HTuple hv_DetectionEvaluationResult, HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Keys, hv_Matches, hv_Key, hv_WordEval;
  HTuple  hv_NumAll, hv_NumTPFP, hv_Divisor, hv___Tmp_Ctrl_Type;

  GetDictParam((hv_DetectionEvaluationResult.TupleGetDictTuple("max_num_detections_all")).TupleGetDictTuple("area_all"), 
      "keys", HTuple(), &hv_Keys);
  //Use the first matching key in order to compute the measures.
  TupleRegexpSelect(hv_Keys, "detailed_evaluation_iou_.*", &hv_Matches);
  hv_Key = ((const HTuple&)hv_Matches)[0];
  hv_WordEval = (((hv_DetectionEvaluationResult.TupleGetDictTuple("max_num_detections_all")).TupleGetDictTuple("area_all")).TupleGetDictTuple(hv_Key)).TupleGetDictTuple("class_0");
  CreateDict(&(*hv_EvaluationResult));
  //Recall
  hv_NumAll = (hv_WordEval.TupleGetDictTuple("num_tp"))+(hv_WordEval.TupleGetDictTuple("num_fn"));
  if (0 != (int(hv_NumAll>0)))
  {
    SetDictTuple((*hv_EvaluationResult), "recall", (hv_WordEval.TupleGetDictTuple("num_tp"))/(hv_NumAll.TupleReal()));
  }
  else
  {
    SetDictTuple((*hv_EvaluationResult), "recall", 0.0);
  }
  //Precision
  hv_NumTPFP = (hv_WordEval.TupleGetDictTuple("num_tp"))+(hv_WordEval.TupleGetDictTuple("num_fp"));
  if (0 != (int(hv_NumTPFP>0)))
  {
    SetDictTuple((*hv_EvaluationResult), "precision", (hv_WordEval.TupleGetDictTuple("num_tp"))/(hv_NumTPFP.TupleReal()));
  }
  else
  {
    SetDictTuple((*hv_EvaluationResult), "precision", 0.0);
  }
  //F-Score
  hv_Divisor = ((*hv_EvaluationResult).TupleGetDictTuple("precision"))+((*hv_EvaluationResult).TupleGetDictTuple("recall"));
  if (0 != (int(hv_Divisor!=0)))
  {
    SetDictTuple((*hv_EvaluationResult), "f_score", ((2*((*hv_EvaluationResult).TupleGetDictTuple("precision")))*((*hv_EvaluationResult).TupleGetDictTuple("recall")))/hv_Divisor);
  }
  else
  {
    SetDictTuple((*hv_EvaluationResult), "f_score", 0.0);
  }
  //SoAP
  TupleRegexpSelect(hv_Keys, "soap_tp_iou_.*", &hv_Matches);
  if (0 != (int((hv_Matches.TupleLength())>0)))
  {
    hv_Key = ((const HTuple&)hv_Matches)[0];
    GetDictParam(((hv_DetectionEvaluationResult.TupleGetDictTuple("max_num_detections_all")).TupleGetDictTuple("area_all")).TupleGetDictTuple(hv_Key), 
        "key_data_type", "class_0", &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((((hv_DetectionEvaluationResult.TupleGetDictTuple("max_num_detections_all")).TupleGetDictTuple("area_all")).TupleGetDictTuple(hv_Key)).TupleGetDictObject("class_0"), 
          (*hv_EvaluationResult), "soap");
    }
    else
    {
      SetDictTuple((*hv_EvaluationResult), "soap", (((hv_DetectionEvaluationResult.TupleGetDictTuple("max_num_detections_all")).TupleGetDictTuple("area_all")).TupleGetDictTuple(hv_Key)).TupleGetDictTuple("class_0"));
    }
  }
  return;
}

// Chapter: OCR / Deep OCR
// Short Description: Calculate OCR recognition measures based on RunningMeasures. 
void calculate_ocr_recognition_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Equal;

  //
  //This procedure calculates the final summarizing OCR recognition measures based on the running measures.
  //
  //
  //Initialize output dictionary and get necessary evaluation parameters.
  CreateDict(&(*hv_EvaluationResult));
  //
  //Compute Accuracy
  hv_Equal = (hv_RunningMeasures.TupleGetDictTuple("words_ground_truth")).TupleEqualElem(hv_RunningMeasures.TupleGetDictTuple("words_prediction"));
  if (0 != (int((hv_Equal.TupleLength())>0)))
  {
    SetDictTuple((*hv_EvaluationResult), "accuracy", ((hv_Equal.TupleSum())/(HTuple(hv_Equal.TupleLength()).TupleReal()))*100);
  }
  else
  {
    SetDictTuple((*hv_EvaluationResult), "accuracy", 0);
  }
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Calculate pixel measures based on RunningMeasures. 
void calculate_pixel_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CalcClassPixelAccuracy, hv_CalcPixelAccuracy;
  HTuple  hv_CalcPixelConfusionMatrix, hv_CalcMeanAccuracy;
  HTuple  hv_CalcMeanPrecision, hv_CalcMeanIou, hv_CalcClassIou;
  HTuple  hv_CalcFWIou, hv_Measures, hv_EvaluationType, hv_PixelMeasures;
  HTuple  hv_M, hv_ConfMatrix, hv_TPMat, hv_TP, hv_SumRowMat;
  HTuple  hv_RowSum, hv_FP, hv_SumColMat, hv_ColSum, hv_FN;
  HTuple  hv_IgnoreClassIDs, hv_Rows, hv_Columns, hv_FPIgnore;
  HTuple  hv_GT, hv_ClsIdxValid, hv_ClassPixelAccuracy, hv_MeanAccuracy;
  HTuple  hv_PixelAccuracy, hv_PD, hv_PDIdxValid, hv_ClassPixelPrecision;
  HTuple  hv_MeanPrecision, hv_ClassIoU, hv_MeanIoU, hv_FWIoU;
  HTuple  hv_FwWeights;

  //
  //This procedure calculates the pixel-wise measures based on the values in running measures.
  //
  //Set default values.
  hv_CalcClassPixelAccuracy = 0;
  hv_CalcPixelAccuracy = 0;
  hv_CalcPixelConfusionMatrix = 0;
  hv_CalcMeanAccuracy = 0;
  hv_CalcMeanPrecision = 0;
  hv_CalcMeanIou = 0;
  hv_CalcClassIou = 0;
  hv_CalcFWIou = 0;
  CreateDict(&(*hv_EvaluationResult));
  //
  //Check which measures are to be calculated.
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
  get_requested_pixel_measures(hv_Measures, hv_EvaluationType, &hv_PixelMeasures);
  if (0 != (int((hv_PixelMeasures.TupleLength())==0)))
  {
    return;
  }
  //
  {
  HTuple end_val22 = (hv_PixelMeasures.TupleLength())-1;
  HTuple step_val22 = 1;
  for (hv_M=0; hv_M.Continue(end_val22, step_val22); hv_M += step_val22)
  {
    if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("pixel_accuracy"))))
    {
      hv_CalcPixelAccuracy = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("class_pixel_accuracy"))))
    {
      hv_CalcClassPixelAccuracy = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("pixel_confusion_matrix"))))
    {
      hv_CalcPixelConfusionMatrix = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("mean_accuracy"))))
    {
      hv_CalcMeanAccuracy = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("mean_precision"))))
    {
      hv_CalcMeanPrecision = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("mean_iou"))))
    {
      hv_CalcMeanIou = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("class_iou"))))
    {
      hv_CalcClassIou = 1;
    }
    else if (0 != (int(HTuple(hv_PixelMeasures[hv_M])==HTuple("frequency_weighted_iou"))))
    {
      hv_CalcFWIou = 1;
    }
    else
    {
      throw HException("Unknown pixel measure: "+HTuple(hv_PixelMeasures[hv_M]));
    }
  }
  }
  //
  //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
  //we first calculate TP/FP/FN from the ConfusionMatrix.
  if (0 != hv_CalcPixelConfusionMatrix)
  {
    //Get the running measures.
    GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", &hv_ConfMatrix);
    //Get the per-class true positives as the diagonal of the matrix.
    GetDiagonalMatrix(hv_ConfMatrix, 0, &hv_TPMat);
    GetFullMatrix(hv_TPMat, &hv_TP);
    //For the confusion matrix, the row determines the predicted class-IDs,
    //the column determines the ground truth class-IDs.
    //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
    SumMatrix(hv_ConfMatrix, "rows", &hv_SumRowMat);
    GetFullMatrix(hv_SumRowMat, &hv_RowSum);
    hv_FP = hv_RowSum-hv_TP;
    //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
    SumMatrix(hv_ConfMatrix, "columns", &hv_SumColMat);
    GetFullMatrix(hv_SumColMat, &hv_ColSum);
    hv_FN = hv_ColSum-hv_TP;
    //We do not want to count the false positives (FP) in the ignore region.
    //The false negatives (FN) are not affected, since the model does not predict the ignore class.
    GetDictTuple(hv_EvalParams, "ignore_class_ids", &hv_IgnoreClassIDs);
    if (0 != (int((hv_IgnoreClassIDs.TupleLength())>0)))
    {
      //The ignore class corresponds to the last row/column in the confusion matrix.
      GetSizeMatrix(hv_ConfMatrix, &hv_Rows, &hv_Columns);
      GetValueMatrix(hv_ConfMatrix, HTuple::TupleGenSequence(0,hv_Rows-1,1), HTuple(hv_Rows,hv_Columns-1), 
          &hv_FPIgnore);
      hv_FP = hv_FP-hv_FPIgnore;
      //Remove last entries of TP, FP, FN (those related to the ignore class).
      hv_TP = hv_TP.TupleSelectRange(0,(hv_TP.TupleLength())-2);
      hv_FP = hv_FP.TupleSelectRange(0,(hv_FP.TupleLength())-2);
      hv_FN = hv_FN.TupleSelectRange(0,(hv_FN.TupleLength())-2);
      //Remove last row/column from confusion matrix.
      GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows-1, hv_Columns-1, &hv_ConfMatrix);
    }
    //Paste the confusion matrix to the output.
    SetDictTuple((*hv_EvaluationResult), "pixel_confusion_matrix", hv_ConfMatrix);
  }
  else
  {
    //Get the running measure values.
    GetDictTuple(hv_RunningMeasures, "tp", &hv_TP);
    GetDictTuple(hv_RunningMeasures, "fp", &hv_FP);
    GetDictTuple(hv_RunningMeasures, "fn", &hv_FN);
  }
  //
  //It might be the case, that some of the classes are not present in the set of validation images.
  //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
  hv_GT = hv_TP+hv_FN;
  hv_ClsIdxValid = (hv_GT.TupleGreaterElem(0)).TupleFind(1);
  //
  //Mean Accuracy, Class Pixel Accuracy.
  //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
  //   as they have to be calculated anyway (to the most part).
  if (0 != (hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)))
  {
    //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
    hv_ClassPixelAccuracy = HTuple(hv_GT.TupleLength(),-1);
    hv_MeanAccuracy = -1;
    if (0 != (int(HTuple(hv_ClsIdxValid[0])>-1)))
    {
      hv_ClassPixelAccuracy[hv_ClsIdxValid] = (HTuple(hv_TP[hv_ClsIdxValid]).TupleReal())/HTuple(hv_GT[hv_ClsIdxValid]);
      hv_MeanAccuracy = HTuple(hv_ClassPixelAccuracy[hv_ClsIdxValid]).TupleMean();
    }
    SetDictTuple((*hv_EvaluationResult), "class_pixel_accuracy", hv_ClassPixelAccuracy);
    SetDictTuple((*hv_EvaluationResult), "mean_accuracy", hv_MeanAccuracy);
  }
  //Pixel Accuracy.
  if (0 != hv_CalcPixelAccuracy)
  {
    //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
    hv_PixelAccuracy = -1;
    if (0 != (int(HTuple(hv_ClsIdxValid[0])>-1)))
    {
      hv_PixelAccuracy = ((HTuple(hv_TP[hv_ClsIdxValid]).TupleSum()).TupleReal())/(HTuple(hv_GT[hv_ClsIdxValid]).TupleSum());
    }
    SetDictTuple((*hv_EvaluationResult), "pixel_accuracy", hv_PixelAccuracy);
  }
  //Mean Precision.
  //-> Also includes precisions for each of the classes which are
  //   used to calculate the mean precision.
  if (0 != hv_CalcMeanPrecision)
  {
    //Compute pixel-level precision averaged over all classes.
    hv_PD = hv_TP+hv_FP;
    hv_PDIdxValid = (hv_PD.TupleGreaterElem(0.0)).TupleFind(1);
    hv_ClassPixelPrecision = HTuple(hv_PD.TupleLength(),-1);
    hv_MeanPrecision = -1;
    if (0 != (int(HTuple(hv_PDIdxValid[0])>-1)))
    {
      hv_ClassPixelPrecision[hv_PDIdxValid] = (HTuple(hv_TP[hv_PDIdxValid]).TupleReal())/HTuple(hv_PD[hv_PDIdxValid]);
      hv_MeanPrecision = HTuple(hv_ClassPixelPrecision[hv_PDIdxValid]).TupleMean();
    }
    SetDictTuple((*hv_EvaluationResult), "mean_precision", hv_MeanPrecision);
  }
  //Mean IoU, class IoU, frequency weighted IoU:
  //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
  //   we return all three of them as they have to be calculated anyway (to the most part).
  if (0 != (HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou)).TupleOr(hv_CalcFWIou)))
  {
    hv_ClassIoU = HTuple(hv_GT.TupleLength(),-1);
    hv_MeanIoU = -1;
    hv_FWIoU = -1;
    if (0 != (int(HTuple(hv_ClsIdxValid[0])>-1)))
    {
      hv_ClassIoU[hv_ClsIdxValid] = (HTuple(hv_TP[hv_ClsIdxValid]).TupleReal())/(HTuple(hv_GT[hv_ClsIdxValid])+HTuple(hv_FP[hv_ClsIdxValid]));
      hv_MeanIoU = HTuple(hv_ClassIoU[hv_ClsIdxValid]).TupleMean();
      hv_FwWeights = (hv_GT.TupleReal())/(hv_GT.TupleSum());
      hv_FWIoU = (HTuple(hv_FwWeights[hv_ClsIdxValid])*HTuple(hv_ClassIoU[hv_ClsIdxValid])).TupleSum();
    }
    SetDictTuple((*hv_EvaluationResult), "class_iou", hv_ClassIoU);
    SetDictTuple((*hv_EvaluationResult), "mean_iou", hv_MeanIoU);
    SetDictTuple((*hv_EvaluationResult), "frequency_weighted_iou", hv_FWIoU);
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Calculate region measures based on running measure values. 
void calculate_region_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CalcMeanPRO, hv_Measures, hv_M, hv_ClsIdxValid;
  HTuple  hv_ClassPRO, hv_MeanPRO;

  //
  //This procedure calculates the region measures based on the
  //values in running measures.
  //
  //Set default values.
  hv_CalcMeanPRO = 0;
  CreateDict(&(*hv_EvaluationResult));
  //
  //Check which measures are to be calculated.
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  {
  HTuple end_val10 = (hv_Measures.TupleLength())-1;
  HTuple step_val10 = 1;
  for (hv_M=0; hv_M.Continue(end_val10, step_val10); hv_M += step_val10)
  {
    if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("mean_pro"))))
    {
      hv_CalcMeanPRO = 1;
    }
    else if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("all"))))
    {
      hv_CalcMeanPRO = 1;
    }
  }
  }
  //
  if (0 != hv_CalcMeanPRO)
  {
    //It might be the case, that some of the classes are not present
    //in the set of evaluation images and are excluded.
    hv_ClsIdxValid = ((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions")).TupleGreaterElem(0)).TupleFind(1);
    //
    //Compute per-region-overlap averaged over the valid classes.
    hv_ClassPRO = HTuple((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions")).TupleLength(),-1);
    hv_MeanPRO = -1;
    if (0 != (int(HTuple(hv_ClsIdxValid[0])>-1)))
    {
      hv_ClassPRO[hv_ClsIdxValid] = HTuple((hv_RunningMeasures.TupleGetDictTuple("gt_overlap"))[hv_ClsIdxValid])/(HTuple((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))[hv_ClsIdxValid]).TupleReal());
      hv_MeanPRO = HTuple(hv_ClassPRO[hv_ClsIdxValid]).TupleMean();
    }
    SetDictTuple((*hv_EvaluationResult), "mean_pro", hv_MeanPRO);
  }
  //
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Calculate 3D gripping point measures based on RunningMeasures. 
void calculate_running_gripping_point_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
    HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Positives, hv_GT, hv_Precision, hv_Recall;
  HTuple  hv_SumPrecisionRecall, hv_FScore;

  CreateDict(&(*hv_EvaluationResult));
  if (0 != (int((HTuple((hv_EvalParams.TupleGetDictTuple("measures")).TupleRegexpSelect("gripping_point_.*|all")).TupleLength())>0)))
  {
    hv_Positives = (hv_RunningMeasures.TupleGetDictTuple("gp_tp"))+(hv_RunningMeasures.TupleGetDictTuple("gp_fp"));
    hv_GT = (hv_RunningMeasures.TupleGetDictTuple("gp_tp"))+(hv_RunningMeasures.TupleGetDictTuple("gp_fn"));
    if (0 != (int(hv_Positives>0.0)))
    {
      hv_Precision = (hv_RunningMeasures.TupleGetDictTuple("gp_tp"))/hv_Positives;
    }
    else
    {
      hv_Precision = 0.0;
    }
    if (0 != (int(hv_GT>0.0)))
    {
      hv_Recall = (hv_RunningMeasures.TupleGetDictTuple("gp_tp"))/hv_GT;
    }
    else
    {
      hv_Recall = 0.0;
    }
    hv_SumPrecisionRecall = hv_Precision+hv_Recall;
    if (0 != (int(hv_SumPrecisionRecall>0.0)))
    {
      hv_FScore = ((2*hv_Precision)*hv_Recall)/hv_SumPrecisionRecall;
    }
    else
    {
      hv_FScore = 0.0;
    }
    if (0 != (int((HTuple((hv_EvalParams.TupleGetDictTuple("measures")).TupleRegexpSelect("gripping_point_precision|all")).TupleLength())>0)))
    {
      SetDictTuple((*hv_EvaluationResult), "gripping_point_precision", hv_Precision);
    }
    if (0 != (int((HTuple((hv_EvalParams.TupleGetDictTuple("measures")).TupleRegexpSelect("gripping_point_recall|all")).TupleLength())>0)))
    {
      SetDictTuple((*hv_EvaluationResult), "gripping_point_recall", hv_Recall);
    }
    if (0 != (int((HTuple((hv_EvalParams.TupleGetDictTuple("measures")).TupleRegexpSelect("gripping_point_f_score|all")).TupleLength())>0)))
    {
      SetDictTuple((*hv_EvaluationResult), "gripping_point_f_score", hv_FScore);
    }
  }
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Initialize and check parameter for the generation of 3D gripping points and poses. 
void check_dl_3d_gripping_points_and_poses_params (HTuple hv_DLGrippingPointParams)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HasMinAreaSize, hv_HasSortingDir, hv_SortingDirectionRaw;
  HTuple  hv_LenSortingDirectionRaw;

  GetDictParam(hv_DLGrippingPointParams, "key_exists", "min_area_size", &hv_HasMinAreaSize);
  if (0 != hv_HasMinAreaSize)
  {
    if (0 != (int((hv_DLGrippingPointParams.TupleGetDictTuple("min_area_size"))<=0)))
    {
      throw HException("DLGrippingPointParams.min_area_size has to be at least 1.");
    }
  }
  else
  {
    SetDictTuple(hv_DLGrippingPointParams, "min_area_size", 1);
  }
  //
  GetDictParam(hv_DLGrippingPointParams, "key_exists", "sorting_direction", &hv_HasSortingDir);
  if (0 != hv_HasSortingDir)
  {
    if (0 != (int(((hv_DLGrippingPointParams.TupleGetDictTuple("sorting_direction")).TupleLength())!=3)))
    {
      throw HException("DLGrippingPointParams.sorting_direction has to be a 3D-vector.");
    }
    hv_SortingDirectionRaw = hv_DLGrippingPointParams.TupleGetDictTuple("sorting_direction");
    hv_LenSortingDirectionRaw = ((hv_SortingDirectionRaw*hv_SortingDirectionRaw).TupleSum()).TupleSqrt();
    if (0 != (int(hv_LenSortingDirectionRaw<1.0e-06)))
    {
      throw HException("DLGrippingPointParams.sorting_direction must not be the zero-vector.");
    }
    SetDictTuple(hv_DLGrippingPointParams, "sorting_direction", hv_SortingDirectionRaw/hv_LenSortingDirectionRaw);
  }
  else
  {
    SetDictTuple(hv_DLGrippingPointParams, "sorting_direction", ((HTuple(0.0).Append(0.0)).Append(0.1)));
  }
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Check if scores of a Global Context Anomaly Detection model have been normalized 
void check_dl_gc_anomaly_scores_normalization (HTuple hv_DLModelHandle, HTuple hv_GenParam)
{

  // Local iconic variables
  HObject  ho_Weights, ho_Bias;

  // Local control variables
  HTuple  hv_DLModelIsConverted, hv_Networks, hv_HasLocalNetwork;
  HTuple  hv_HasGlobalNetwork, hv_NormalizationLayers, hv_Index;
  HTuple  hv_LayerName, hv_Rows, hv_Columns, hv_WeightsValues;
  HTuple  hv_HasDefaultWeights, hv_BiasValues, hv_HasDefaultBias;

  //This procedure checks if all gc anomaly scores have been normalized.
  //
  //Make sure GenParam is an empty tuple.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    throw HException("The parameter GenParam must be an empty tuple.");
  }
  //
  //For models using an AI accelerator interface for inference, the
  //weights of internal layers are no longer available. They are
  //removed to reduce the memory footprint of the model. Therefore
  //we have no means to check if the gc anomaly scores have been
  //normalized, and thus we assume that this is already the case.
  GetDlModelParam(hv_DLModelHandle, "precision_is_converted", &hv_DLModelIsConverted);
  if (0 != (int(hv_DLModelIsConverted==HTuple("true"))))
  {
    return;
  }
  //
  //Find networks to be normalized.
  GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", &hv_Networks);
  hv_HasLocalNetwork = int((hv_Networks.TupleFind("local"))!=-1);
  hv_HasGlobalNetwork = int((hv_Networks.TupleFind("global"))!=-1);
  hv_NormalizationLayers = HTuple();
  if (0 != hv_HasLocalNetwork)
  {
    hv_NormalizationLayers = hv_NormalizationLayers.TupleConcat("local_normalization");
  }
  if (0 != hv_HasGlobalNetwork)
  {
    hv_NormalizationLayers = hv_NormalizationLayers.TupleConcat("global_normalization");
  }
  //
  {
  HTuple end_val29 = (hv_NormalizationLayers.TupleLength())-1;
  HTuple step_val29 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val29, step_val29); hv_Index += step_val29)
  {
    hv_LayerName = HTuple(hv_NormalizationLayers[hv_Index]);
    GetDlModelLayerWeights(&ho_Weights, hv_DLModelHandle, hv_LayerName, "weights");
    GetRegionPoints(ho_Weights, &hv_Rows, &hv_Columns);
    GetGrayval(ho_Weights, hv_Rows, hv_Columns, &hv_WeightsValues);
    //Calculate if weights are equal since some floating point arithmetic
    //is involved in their creation.
    hv_HasDefaultWeights = int(((((hv_WeightsValues.TupleLength())*hv_WeightsValues)-HTuple(hv_WeightsValues.TupleLength(),1.0)).TupleAbs())<((hv_WeightsValues.TupleLength())*1e-6));
    //
    GetDlModelLayerWeights(&ho_Bias, hv_DLModelHandle, hv_LayerName, "bias");
    GetRegionPoints(ho_Bias, &hv_Rows, &hv_Columns);
    GetGrayval(ho_Bias, hv_Rows, hv_Columns, &hv_BiasValues);
    //The bias is set directly, hence an equality check is sufficient.
    hv_HasDefaultBias = int(hv_BiasValues==HTuple(hv_BiasValues.TupleLength(),0.0));
    //
    if (0 != (hv_HasDefaultWeights.TupleAnd(hv_HasDefaultBias)))
    {
      throw HException(HTuple("For a model of type gc_anomaly_detection, the anomaly scores must be normalized first."));
    }
  }
  }
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Calculate top-K error. 
void compute_top_k_error (HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions, HTuple hv_K, 
    HTuple *hv_TopKError)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumMatches, hv_Index, hv_Predictions;
  HTuple  hv_PredictedClasses;

  //
  //This procedure calculates the top-K error out of the given predictions and labels.
  //
  hv_NumMatches = 0;
  //
  //Loop through all selected ground truth labels.
  {
  HTuple end_val6 = (hv_ImageLabelIDs.TupleLength())-1;
  HTuple step_val6 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    //Get the K best results.
    GetDictTuple(HTuple(hv_TopKPredictions[hv_Index]), "predictions", &hv_Predictions);
    hv_PredictedClasses = hv_Predictions.TupleSelectRange(0,hv_K-1);
    //Count how often the ground truth label
    //and K predicted classes match.
    if (0 != (int((hv_PredictedClasses.TupleFind(HTuple(hv_ImageLabelIDs[hv_Index])))!=-1)))
    {
      hv_NumMatches += 1;
    }
  }
  }
  (*hv_TopKError) = 1.0-((hv_NumMatches.TupleReal())/(hv_ImageLabelIDs.TupleLength()));
  //
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Compute a pose from a 3D point and orientation. 
void convert_dl_3d_gripping_point_to_pose (HTuple hv_X, HTuple hv_Y, HTuple hv_Z, 
    HTuple hv_NX, HTuple hv_NY, HTuple hv_NZ, HTuple *hv_Pose)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Normal, hv_Abs, hv_Indices, hv_ToolInCamY;
  HTuple  hv_ToolInCamX, hv_ToolInCamHRot, hv_ToolInCamPoseRot;
  HTuple  hv_HomMat3D, hv_Qx, hv_Qy, hv_Qz;

  //Check for invalid points.
  if (0 != (HTuple(HTuple(HTuple(int(hv_X==0.0)).TupleAnd(int(hv_Y==0.0))).TupleAnd(int(hv_Z==0.0))).TupleOr(HTuple(HTuple(int(hv_NX==0.0)).TupleAnd(int(hv_NY==0.0))).TupleAnd(int(hv_NZ==0.0)))))
  {
    (*hv_Pose) = HTuple();
    return;
  }
  //
  //Get rotation.
  hv_Normal.Clear();
  hv_Normal.Append(hv_NX);
  hv_Normal.Append(hv_NY);
  hv_Normal.Append(hv_NZ);
  TupleFabs(hv_Normal, &hv_Abs);
  TupleSortIndex(hv_Abs, &hv_Indices);
  hv_ToolInCamY[HTuple(hv_Indices[0])] = 0.0;
  hv_ToolInCamY[HTuple(hv_Indices[1])] = -HTuple(hv_Normal[HTuple(hv_Indices[2])]);
  hv_ToolInCamY[HTuple(hv_Indices[2])] = HTuple(hv_Normal[HTuple(hv_Indices[1])]);
  hv_ToolInCamY = hv_ToolInCamY/(((hv_ToolInCamY*hv_ToolInCamY).TupleSum()).TupleSqrt());
  tuple_vector_cross_product(hv_ToolInCamY, hv_Normal, &hv_ToolInCamX);
  hv_ToolInCamHRot.Clear();
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamX[0]));
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamY[0]));
  hv_ToolInCamHRot.Append(HTuple(hv_Normal[0]));
  hv_ToolInCamHRot.Append(0.0);
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamX[1]));
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamY[1]));
  hv_ToolInCamHRot.Append(HTuple(hv_Normal[1]));
  hv_ToolInCamHRot.Append(0.0);
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamX[2]));
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamY[2]));
  hv_ToolInCamHRot.Append(HTuple(hv_Normal[2]));
  hv_ToolInCamHRot.Append(0.0);
  HomMat3dToPose(hv_ToolInCamHRot, &hv_ToolInCamPoseRot);
  hv_ToolInCamPoseRot[5] = 0.0;
  PoseToHomMat3d(hv_ToolInCamPoseRot, &hv_HomMat3D);
  //
  //Get translation.
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, &hv_Qx, &hv_Qy, &hv_Qz);
  (*hv_Pose) = hv_ToolInCamPoseRot;
  (*hv_Pose)[0] = hv_X-hv_Qx;
  (*hv_Pose)[1] = hv_Y-hv_Qy;
  (*hv_Pose)[2] = hv_Z-hv_Qz;
  return;
}

// Chapter: OCR / Deep OCR
// Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
void convert_ocr_detection_result_to_object_detection (HTuple hv_OcrResults, HTuple *hv_DetectionResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Index, hv_OcrResult, hv_RequiredKeysExist;
  HTuple  hv_DetectionResult, hv___Tmp_Ctrl_Type;

  //
  //Convert Deep OCR Detection results
  //to Object Detection results.
  //
  //Create DetectionResults Dict
  TupleGenConst(hv_OcrResults.TupleLength(), HTuple::TupleConstant("HNULL"), &(*hv_DetectionResults));
  {
  HTuple end_val6 = (hv_OcrResults.TupleLength())-1;
  HTuple step_val6 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    hv_OcrResult = HTuple(hv_OcrResults[hv_Index]);
    //Check if input is valid
    GetDictParam(hv_OcrResult, "key_exists", "words", &hv_RequiredKeysExist);
    if (0 != (int((hv_RequiredKeysExist.TupleSum())!=(hv_RequiredKeysExist.TupleLength()))))
    {
      throw HException(("The item at Index "+hv_Index)+" is not a valid Deep OCR Detection Result");
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_exists", ((((HTuple("row").Append("col")).Append("phi")).Append("length1")).Append("length2")), 
        &hv_RequiredKeysExist);
    if (0 != (int((hv_RequiredKeysExist.TupleSum())!=(hv_RequiredKeysExist.TupleLength()))))
    {
      throw HException(("The item at Index "+hv_Index)+" is not a valid Deep OCR Detection Result");
    }
    //Convert ocr detection result to object detection
    CreateDict(&hv_DetectionResult);
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "row", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("row"), 
          hv_DetectionResult, "bbox_row");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_row", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("row"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "col", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("col"), 
          hv_DetectionResult, "bbox_col");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_col", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("col"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "phi", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("phi"), 
          hv_DetectionResult, "bbox_phi");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_phi", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("phi"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "length1", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("length1"), 
          hv_DetectionResult, "bbox_length1");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_length1", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("length1"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "length2", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("length2"), 
          hv_DetectionResult, "bbox_length2");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_length2", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("length2"));
    }
    SetDictTuple(hv_DetectionResult, "bbox_confidence", HTuple((hv_DetectionResult.TupleGetDictTuple("bbox_row")).TupleLength(),1.0));
    SetDictTuple(hv_DetectionResult, "bbox_class_id", HTuple((hv_DetectionResult.TupleGetDictTuple("bbox_row")).TupleLength(),0));
    (*hv_DetectionResults)[hv_Index] = hv_DetectionResult;
  }
  }


  return;
}

// Chapter: Deep Learning / Model
// Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
void create_evaluation_default_param (HTuple hv_EvaluationType, HTuple hv_ClassIDsModel, 
    HTuple *hv_EvalParams)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_AvailableEvaluationTypes, hv_EvaluationTypesStr;
  HTuple  hv_Indices, hv_EvaluateInstances, hv_Measures, hv_GrippingPointParams;
  HTuple  hv_AreaRanges, hv_AllocationBlockLength;

  //
  //This procedure generates a dictionary EvalParams,
  //which contains default values for evaluation parameters.
  //Depending on the evaluation type, the corresponding default parameters and values are set.
  //The class IDs that the model can predict must be given via ClassIDsModel.
  //
  //Check inputs.
  hv_AvailableEvaluationTypes.Clear();
  hv_AvailableEvaluationTypes[0] = "3d_gripping_point_detection";
  hv_AvailableEvaluationTypes[1] = "anomaly_detection";
  hv_AvailableEvaluationTypes[2] = "classification";
  hv_AvailableEvaluationTypes[3] = "detection";
  hv_AvailableEvaluationTypes[4] = "gc_anomaly_detection";
  hv_AvailableEvaluationTypes[5] = "ocr_detection";
  hv_AvailableEvaluationTypes[6] = "ocr_recognition";
  hv_AvailableEvaluationTypes[7] = "segmentation";
  TupleGenConst((2*(hv_AvailableEvaluationTypes.TupleLength()))-1, HTuple("','"), 
      &hv_EvaluationTypesStr);
  hv_EvaluationTypesStr[HTuple::TupleGenSequence(0,hv_EvaluationTypesStr.TupleLength(),2)] = hv_AvailableEvaluationTypes;
  hv_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum();
  TupleFind(hv_AvailableEvaluationTypes, hv_EvaluationType, &hv_Indices);
  if (0 != (HTuple(int(hv_Indices==-1)).TupleOr(int(hv_Indices==HTuple()))))
  {
    throw HException(((("Unknown evaluation_type: "+hv_EvaluationType)+". Choose one of ['")+hv_EvaluationTypesStr)+"']");
  }
  //
  if (0 != (int((hv_ClassIDsModel.TupleLength())<1)))
  {
    if (0 != (int(hv_EvaluationType==HTuple("ocr_detection"))))
    {
      hv_ClassIDsModel = 0;
    }
    else
    {
      throw HException("ClassIDsModel should have at least one entry");
    }
  }
  //
  //Initialize EvalParams.
  CreateDict(&(*hv_EvalParams));
  SetDictTuple((*hv_EvalParams), "evaluation_type", hv_EvaluationType);
  //
  //Set the class IDs.
  SetDictTuple((*hv_EvalParams), "class_ids", hv_ClassIDsModel);
  SetDictTuple((*hv_EvalParams), "num_classes", hv_ClassIDsModel.TupleLength());
  //
  //Set specific parameters depending on the evaluation type.
  hv_EvaluateInstances = 0;
  if (0 != (int(hv_EvaluationType==HTuple("3d_gripping_point_detection"))))
  {
    //
    //Set default 3D Gripping Point Detection measures.
    hv_Measures.Clear();
    hv_Measures[0] = "mean_pro";
    hv_Measures[1] = "mean_precision";
    hv_Measures[2] = "mean_iou";
    //
    //There are no ignored classes for this model type.
    SetDictTuple((*hv_EvalParams), "ignore_class_ids", HTuple());
    //
    //Set default 3D gripping point generation parameters.
    CreateDict(&hv_GrippingPointParams);
    check_dl_3d_gripping_points_and_poses_params(hv_GrippingPointParams);
    SetDictTuple((*hv_EvalParams), "gripping_point_params", hv_GrippingPointParams);
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("anomaly_detection"))).TupleOr(int(hv_EvaluationType==HTuple("gc_anomaly_detection")))))
  {
    //
    //Set default image level measures.
    hv_Measures = "anomaly_score_histogram";
  }
  else if (0 != (int(hv_EvaluationType==HTuple("classification"))))
  {
    //
    //Set default classification measures.
    hv_Measures = "top1_error";
    //
    //Per default all classes are used for evaluation.
    SetDictTuple((*hv_EvalParams), "class_ids_to_evaluate", "global");
  }
  else if (0 != (int(hv_EvaluationType==HTuple("detection"))))
  {
    //
    //Set default detection measures.
    hv_Measures = "mean_ap";
    //
    //Set detection-specific default values.
    hv_EvaluateInstances = 1;
    SetDictTuple((*hv_EvalParams), "instance_type", "rectangle1");
    //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
    SetDictTuple((*hv_EvalParams), "iou_threshold", HTuple::TupleGenSequence(0.5,0.96,0.05));
    //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
    SetDictTuple((*hv_EvalParams), "max_num_detections", -1);
    //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
    CreateDict(&hv_AreaRanges);
    SetDictTuple(hv_AreaRanges, "name", "all");
    SetDictTuple(hv_AreaRanges, "min", 0);
    SetDictTuple(hv_AreaRanges, "max", 2e8);
    SetDictTuple((*hv_EvalParams), "area_ranges", hv_AreaRanges);
    //Some tuples are changing their length during the evaluation. As this slows down the
    //evaluation process they are allocated in blocks of AllocationBlockLength.
    hv_AllocationBlockLength = 200;
    SetDictTuple((*hv_EvalParams), "allocation_block_length", hv_AllocationBlockLength);
    //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
    SetDictTuple((*hv_EvalParams), "detailed_evaluation", 0);
    //Interpolate the precision-recall curves per default.
    SetDictTuple((*hv_EvalParams), "interpolate_pr_curves", 1);
  }
  else if (0 != (int(hv_EvaluationType==HTuple("segmentation"))))
  {
    //
    //Set default pixel measures.
    hv_Measures.Clear();
    hv_Measures[0] = "pixel_accuracy";
    hv_Measures[1] = "mean_accuracy";
    hv_Measures[2] = "mean_iou";
    //
    //Per default there are no ignored classes.
    SetDictTuple((*hv_EvalParams), "ignore_class_ids", HTuple());
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_recognition"))))
  {
    //
    //Set default OCR recognition measures
    hv_Measures = "accuracy";
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_detection"))))
  {
    //
    //Set default ocr_detection measures.
    hv_Measures = "f_score";
    SetDictTuple((*hv_EvalParams), "detailed_evaluation", 1);
    SetDictTuple((*hv_EvalParams), "iou_threshold", 0.5);
    SetDictTuple((*hv_EvalParams), "max_num_detections", -1);
    SetDictTuple((*hv_EvalParams), "instance_type", "rectangle2");
    SetDictTuple((*hv_EvalParams), "allocation_block_length", 100);
    //
    //Configure area constraints.
    CreateDict(&hv_AreaRanges);
    SetDictTuple(hv_AreaRanges, "name", "all");
    SetDictTuple(hv_AreaRanges, "min", 0);
    SetDictTuple(hv_AreaRanges, "max", HTuple::TupleConstant("H_INT_MAX"));
    SetDictTuple((*hv_EvalParams), "area_ranges", hv_AreaRanges);
  }
  //
  SetDictTuple((*hv_EvalParams), "evaluate_instances", hv_EvaluateInstances);
  SetDictTuple((*hv_EvalParams), "measures", hv_Measures);
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
{

  // Local iconic variables
  HObject  ho_Sectors, ho_Arc, ho_Sector;

  // Local control variables
  HTuple  hv_Tolerance, hv_InitialWindowHandle;
  HTuple  hv_NoInitialWindow, hv_Red, hv_Green, hv_Blue, hv_Alpha;
  HTuple  hv_InitialColor, hv_IndexColor, hv_Color_RGBA, hv_Title;
  HTuple  hv_TitleColor, hv_Footnote, hv_FootnoteColor, hv_TitleKeyExists;
  HTuple  hv_TitleColorKeyExists, hv_FootnoteKeyExists, hv_FootnoteColorKeyExists;
  HTuple  hv_GivenTitle, hv_GivenTitleColor, hv_Exception;
  HTuple  hv_GivenFootnote, hv_GivenFootnoteColor, hv_FullCircleAngle;
  HTuple  hv_StartAngle, hv_DrawColors, hv_K, hv_EndAngle;
  HTuple  hv_Rows, hv_Columns, hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_ContourStyle, hv_Ascent, hv_Descent, hv_Width;
  HTuple  hv_Height;

  //
  //Draw a pie-chart into the active window.
  //
  //Check input Ratios.
  if (0 != (int(((hv_Ratios.TupleLessElem(0.0)).TupleSum())>0)))
  {
    throw HException("Values of parameter Ratios must be positive.");
  }
  hv_Tolerance = 0.1;
  if (0 != (int(((1-(hv_Ratios.TupleSum())).TupleAbs())>=hv_Tolerance)))
  {
    throw HException("Sum of Ratios differs too much from 1.");
  }
  //
  //Get current window handle.
  if (HDevWindowStack::IsOpen())
    hv_InitialWindowHandle = HDevWindowStack::GetActive();
  //In case there is no open window, no initial values are to be reset.
  hv_NoInitialWindow = 0;
  if (0 != (int(hv_InitialWindowHandle==-1)))
  {
    hv_NoInitialWindow = 1;
  }
  else
  {
    //Get current set color.
    GetRgba(hv_InitialWindowHandle, &hv_Red, &hv_Green, &hv_Blue, &hv_Alpha);
    hv_InitialColor = HTuple();
    {
    HTuple end_val22 = (hv_Red.TupleLength())-1;
    HTuple step_val22 = 1;
    for (hv_IndexColor=0; hv_IndexColor.Continue(end_val22, step_val22); hv_IndexColor += step_val22)
    {
      hv_Color_RGBA = ((("#"+(HTuple(hv_Red[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Green[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Blue[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Alpha[hv_IndexColor]).TupleString("2x"));
      TupleRegexpReplace(hv_Color_RGBA, (HTuple(" ").Append("replace_all")), "0", 
          &hv_Color_RGBA);
      hv_InitialColor = hv_InitialColor.TupleConcat(hv_Color_RGBA);
    }
    }
  }
  HDevWindowStack::SetActive(hv_WindowHandle);
  //
  //In case no segment colors are specified, generate random colors.
  if (0 != (int((hv_Colors.TupleLength())==0)))
  {
    //Generate random colors.
    get_distinct_colors(hv_Ratios.TupleLength(), 1, 0, 220, &hv_Colors);
  }
  //
  //Set default parameters.
  hv_Title = HTuple();
  hv_TitleColor = "white";
  hv_Footnote = HTuple();
  hv_FootnoteColor = "white";
  //Get generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    GetDictParam(hv_GenParam, "key_exists", "title", &hv_TitleKeyExists);
    GetDictParam(hv_GenParam, "key_exists", "title_color", &hv_TitleColorKeyExists);
    GetDictParam(hv_GenParam, "key_exists", "footnote", &hv_FootnoteKeyExists);
    GetDictParam(hv_GenParam, "key_exists", "footnote_color", &hv_FootnoteColorKeyExists);
    //
    //Title text.
    if (0 != hv_TitleKeyExists)
    {
      GetDictTuple(hv_GenParam, "title", &hv_GivenTitle);
      if (0 != (HTuple((hv_GivenTitle.TupleIsString()).TupleNot()).TupleOr(int((hv_GivenTitle.TupleStrlen())<1))))
      {
        throw HException("Invalid value for key 'title'");
      }
      hv_Title = hv_GivenTitle;
    }
    //Title color.
    if (0 != hv_TitleColorKeyExists)
    {
      GetDictTuple(hv_GenParam, "title_color", &hv_GivenTitleColor);
      if (0 != ((hv_GivenTitleColor.TupleIsString()).TupleNot()))
      {
        throw HException("Invalid value for key 'title_color'");
      }
      try
      {
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),hv_GivenTitleColor);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid value for key 'title_color'");
      }
      hv_TitleColor = hv_GivenTitleColor;
    }
    //
    //Footnote text.
    if (0 != hv_FootnoteKeyExists)
    {
      GetDictTuple(hv_GenParam, "footnote", &hv_GivenFootnote);
      if (0 != (HTuple((hv_GivenFootnote.TupleIsString()).TupleNot()).TupleOr(int((hv_GivenFootnote.TupleStrlen())<1))))
      {
        throw HException("Invalid value for key 'footnote'");
      }
      hv_Footnote = hv_GivenFootnote;
    }
    //Footnote color.
    if (0 != hv_FootnoteColorKeyExists)
    {
      GetDictTuple(hv_GenParam, "footnote_color", &hv_GivenFootnoteColor);
      if (0 != ((hv_GivenFootnoteColor.TupleIsString()).TupleNot()))
      {
        throw HException("Invalid value for key 'footnote_color'");
      }
      try
      {
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),hv_GivenFootnoteColor);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid value for key 'footnote_color'");
      }
      hv_FootnoteColor = hv_GivenFootnoteColor;
    }
  }
  hv_FullCircleAngle = 2*3.14159;
  hv_StartAngle = 0;
  //
  //Generate circle-sectors.
  hv_Ratios = hv_Ratios/(hv_Ratios.TupleSum());
  hv_DrawColors = HTuple();
  GenEmptyObj(&ho_Sectors);
  {
  HTuple end_val99 = (hv_Ratios.TupleLength())-1;
  HTuple step_val99 = 1;
  for (hv_K=0; hv_K.Continue(end_val99, step_val99); hv_K += step_val99)
  {
    if (0 != (int(HTuple(hv_Ratios[hv_K])>0)))
    {
      hv_EndAngle = hv_StartAngle+(HTuple(hv_Ratios[hv_K])*hv_FullCircleAngle);
      GenCircleContourXld(&ho_Arc, hv_Row, hv_Column, hv_Radius, hv_StartAngle, hv_EndAngle, 
          "positive", 1);
      GetContourXld(ho_Arc, &hv_Rows, &hv_Columns);
      GenContourPolygonXld(&ho_Sector, (hv_Row.TupleConcat(hv_Rows)).TupleConcat(hv_Row), 
          (hv_Column.TupleConcat(hv_Columns)).TupleConcat(hv_Column));
      hv_StartAngle = hv_EndAngle;
      hv_DrawColors = hv_DrawColors.TupleConcat(HTuple(hv_Colors[hv_K]));
      ConcatObj(ho_Sectors, ho_Sector, &ho_Sectors);
    }
  }
  }
  //Rotate 90 degrees such that the first sector starts at the top.
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, 0.25*hv_FullCircleAngle, hv_Row, hv_Column, 
      &hv_HomMat2DRotate);
  AffineTransContourXld(ho_Sectors, &ho_Sectors, hv_HomMat2DRotate);
  //
  //Display sectors.
  HDevWindowStack::SetActive(hv_WindowHandle);
  GetContourStyle(hv_WindowHandle, &hv_ContourStyle);
  if (HDevWindowStack::IsOpen())
    SetContourStyle(HDevWindowStack::GetActive(),"stroke_and_fill");
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),hv_DrawColors);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Sectors, HDevWindowStack::GetActive());
  //(Optional) title.
  if (0 != (int(hv_Title!=HTuple())))
  {
    GetStringExtents(hv_WindowHandle, hv_Title, &hv_Ascent, &hv_Descent, &hv_Width, 
        &hv_Height);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Title, "image", (((hv_Row-hv_Radius)-hv_Height)-hv_Ascent)-hv_Descent, 
          hv_Column-(hv_Width/2), hv_TitleColor, "box", "false");
  }
  //(Optional) footnote.
  if (0 != (int(hv_Footnote!=HTuple())))
  {
    GetStringExtents(hv_WindowHandle, hv_Footnote, &hv_Ascent, &hv_Descent, &hv_Width, 
        &hv_Height);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Footnote, "image", (((hv_Row+hv_Radius)-hv_Height)+hv_Ascent)+hv_Descent, 
          hv_Column-(hv_Width/2), hv_FootnoteColor, "box", "false");
  }
  if (HDevWindowStack::IsOpen())
    SetContourStyle(HDevWindowStack::GetActive(),hv_ContourStyle);
  //
  //Reset original window and colors (and close the window in case there was none open).
  if (0 != hv_NoInitialWindow)
  {
    if (HDevWindowStack::IsOpen())
      CloseWindow(HDevWindowStack::Pop());
  }
  else
  {
    HDevWindowStack::SetActive(hv_InitialWindowHandle);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_InitialColor);
  }
  return;
}

// Chapter: Develop
// Short Description: Resize a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_TempWidth, hv_TempHeight;
  HTuple  hv_WindowWidth, hv_WindowHeight;

  //This procedure adjusts the size of the current window
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct aspect ratio
  //given by Width and Height.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority.
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple(int((hv_WidthLimit.TupleLength())==0)).TupleOr(int(hv_WidthLimit<0))))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != (int((hv_WidthLimit.TupleLength())==1)))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple(int((hv_HeightLimit.TupleLength())==0)).TupleOr(int(hv_HeightLimit<0))))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != (int((hv_HeightLimit.TupleLength())==1)))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(int(hv_MinWidth>hv_Width)).TupleOr(int(hv_MinHeight>hv_Height))))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_Width).TupleConcat((hv_MinHeight.TupleReal())/hv_Height)).TupleMax();
  }
  hv_TempWidth = hv_Width*hv_ResizeFactor;
  hv_TempHeight = hv_Height*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(int(hv_MaxWidth<hv_TempWidth)).TupleOr(int(hv_MaxHeight<hv_TempHeight))))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_Width*hv_ResizeFactor;
  hv_WindowHeight = hv_Height*hv_ResizeFactor;
  //Resize window
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),hv_Row, hv_Column, hv_WindowWidth, 
        hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: System / Operating System
// Short Description: Estimate the remaining time for a task given the current progress. 
void estimate_progress (HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent, 
    HTuple hv_ProgressMax, HTuple *hv_SecondsElapsed, HTuple *hv_SecondsRemaining, 
    HTuple *hv_ProgressPercent, HTuple *hv_ProgressPerSecond)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_SecondsNow, hv_Epsilon, hv_ProgressRemaining;

  //
  //This procedure estimates the remaining time in seconds,
  //given a start time and a progress value.
  //
  //Get current time.
  CountSeconds(&hv_SecondsNow);
  //
  //Get elapsed time span.
  (*hv_SecondsElapsed) = hv_SecondsNow-hv_SecondsStart;
  //
  //A very small additive constant to avoid division by zero.
  hv_Epsilon = 1e-6;
  //
  //Estimate remaining time based on elapsed time.
  hv_ProgressRemaining = hv_ProgressMax-hv_ProgressCurrent;
  (*hv_ProgressPerSecond) = ((hv_ProgressCurrent-hv_ProgressMin).TupleReal())/(((*hv_SecondsElapsed).TupleReal())+hv_Epsilon);
  (*hv_SecondsRemaining) = hv_ProgressRemaining/((*hv_ProgressPerSecond)+hv_Epsilon);
  //
  //Get current progress in percent.
  (*hv_ProgressPercent) = (100*((hv_ProgressCurrent-hv_ProgressMin).TupleReal()))/(((hv_ProgressMax-hv_ProgressMin).TupleReal())+hv_Epsilon);
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
void evaluate_dl_model (HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod, 
    HTuple hv_SampleSelectValues, HTuple hv_GenParam, HTuple *hv_EvaluationResult, 
    HTuple *hv_EvalParams)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ModelType, hv_ClassIDs, hv_ClassNames;
  HTuple  hv_Alphabet, hv_BatchSize, hv_InstanceTypeModel;
  HTuple  hv_Exception, hv_IsInstanceSegmentation, hv_InstanceType;
  HTuple  hv_ModelIgnoreClassIDs, hv_ShowProgress, hv_GenParamKeys;
  HTuple  hv_OptionalKeyNames, hv_GenParamIndex, hv_IoUThreshold;
  HTuple  hv_MaxNumDetections, hv_AreaRanges, hv_DetailedEvaluation;
  HTuple  hv_AllocationBlockLength, hv_IgnoreClassIDs, hv_AllIgnoreClassIDs;
  HTuple  hv_EvaluateClassIDs, hv_ClassesToEvaluate, hv_KeyExists;
  HTuple  hv_ClassIDsToEvaluate, hv_AnomalyClassificationThresholds;
  HTuple  hv_EvaluateMask, hv_Value, hv_Measures, hv_IgnoreDirection;
  HTuple  hv_ClassInfoExists, hv_DatasetClassIDs, hv_ClassIDsToClassNames;
  HTuple  hv_EvaluateClassNames, hv_DLSamples, hv_SampleIndices;
  HTuple  hv_NumSamples, hv_NumBatches, hv_RunningMeasures;
  HTuple  hv_Outputs, hv_EvalGCAnomalyNetworks, hv_ModelGCAnomalyNetworks;
  HTuple  hv_DefaultRequested, hv_EvalAnomalyNetworkIndex;
  HTuple  hv_EvalGCAnomalyNetwork, hv_FindIndex, hv_Progress;
  HTuple  hv_TaskInfo, hv_SecondsStart, hv_BatchIndex, hv_BatchStart;
  HTuple  hv_BatchEnd, hv_SamplesIndicesBatch, hv_DLSamplesBatch;
  HTuple  hv_DLResultsBatch, hv_SecondsElapsed, hv_SecondsRemaining;
  HTuple  hv_ProgressPercent, hv_ProgressPerSecond, hv_TimeElapsedString;
  HTuple  hv_TimeRemainingString;

  //This procedure applies the model given by DLModelHandle on the selected samples
  //of DLDataset and evaluates the results against the ground truth annotations
  //to calculate evaluation measures.
  //
  //Input:
  // - DLDataset.
  // - DLModelHandle.
  // - SampleSelectMethod: Method by which the samples are selected.
  // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
  //                       for the corresponding selection method.
  // - GenParam: Parameters of the evaluation that should be changed from the default.
  //
  //Output:
  // - EvaluationResult: Dictionary containing the output measures.
  // - EvalParams: Dictionary with the used evaluation parameters.
  //
  //** Initialization: ***
  //
  GetDlModelParam(hv_DLModelHandle, "type", &hv_ModelType);
  if (0 != (HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(int(hv_ModelType!=HTuple("3d_gripping_point_detection"))).TupleAnd(int(hv_ModelType!=HTuple("anomaly_detection")))).TupleAnd(int(hv_ModelType!=HTuple("classification")))).TupleAnd(int(hv_ModelType!=HTuple("detection")))).TupleAnd(int(hv_ModelType!=HTuple("gc_anomaly_detection")))).TupleAnd(int(hv_ModelType!=HTuple("ocr_detection")))).TupleAnd(int(hv_ModelType!=HTuple("ocr_recognition")))).TupleAnd(int(hv_ModelType!=HTuple("segmentation")))))
  {
    throw HException(("Current model type is not supported: \""+hv_ModelType)+"\"");
  }
  //
  //Check if model has been normalized, if required by model type.
  if (0 != (int(hv_ModelType==HTuple("gc_anomaly_detection"))))
  {
    check_dl_gc_anomaly_scores_normalization(hv_DLModelHandle, HTuple());
  }
  //
  //Get the class IDs as set in the model.
  if (0 != (int(hv_ModelType==HTuple("3d_gripping_point_detection"))))
  {
    //Only the gripping_map class is evaluated.
    GetDlModelParam(hv_DLModelHandle, "class_ids", &hv_ClassIDs);
    GetDlModelParam(hv_DLModelHandle, "class_names", &hv_ClassNames);
    hv_ClassIDs = HTuple(hv_ClassIDs[hv_ClassNames.TupleFind("gripping_map")]);
  }
  else if (0 != (HTuple(int(hv_ModelType==HTuple("anomaly_detection"))).TupleOr(int(hv_ModelType==HTuple("gc_anomaly_detection")))))
  {
    //Default for anomaly detection and Global Context Anomaly Detection is 0,1.
    hv_ClassIDs.Clear();
    hv_ClassIDs[0] = 0;
    hv_ClassIDs[1] = 1;
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    //No Class IDs in case of ocr_recognition models
    GetDlModelParam(hv_DLModelHandle, "alphabet", &hv_Alphabet);
    TupleGenSequence(0, hv_Alphabet.TupleLength(), 1, &hv_ClassIDs);
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    //Default for ocr_detection. Only evaluate word.
    //0: word, 1: char, 2: ignore
    hv_ClassIDs = 0;
  }
  else
  {
    GetDlModelParam(hv_DLModelHandle, "class_ids", &hv_ClassIDs);
  }
  //
  //Get the batch size as set in the model.
  GetDlModelParam(hv_DLModelHandle, "batch_size", &hv_BatchSize);
  //
  //Generate default parameters.
  create_evaluation_default_param(hv_ModelType, hv_ClassIDs, &(*hv_EvalParams));
  //
  //Get model specific information.
  if (0 != (int(hv_ModelType==HTuple("detection"))))
  {
    try
    {
      GetDlModelParam(hv_DLModelHandle, "instance_type", &hv_InstanceTypeModel);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_InstanceTypeModel = "rectangle1";
    }
    GetDlModelParam(hv_DLModelHandle, "instance_segmentation", &hv_IsInstanceSegmentation);
    if (0 != (int(hv_IsInstanceSegmentation==HTuple("true"))))
    {
      hv_InstanceType = "mask";
    }
    else
    {
      hv_InstanceType = hv_InstanceTypeModel;
    }
    //Note, these are the defaults. If the user specifies
    //'evaluate_mask' as false, the evaluation will use
    //the instance type of the model (InstanceTypeModel).
  }
  else if (0 != (int(hv_ModelType==HTuple("segmentation"))))
  {
    GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", &hv_ModelIgnoreClassIDs);
  }
  //
  //By default we do not show the progress of evaluation.
  hv_ShowProgress = 0;
  //
  //Set user specified parameters.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamKeys);
    hv_OptionalKeyNames.Clear();
    hv_OptionalKeyNames[0] = "measures";
    hv_OptionalKeyNames[1] = "evaluation_type";
    hv_OptionalKeyNames[2] = "class_ids";
    hv_OptionalKeyNames[3] = "num_classes";
    hv_OptionalKeyNames[4] = "evaluate_instances";
    hv_OptionalKeyNames[5] = "gc_anomaly_networks";
    hv_OptionalKeyNames[6] = "gripping_point_params";
    {
    HTuple end_val82 = (hv_GenParamKeys.TupleLength())-1;
    HTuple step_val82 = 1;
    for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val82, step_val82); hv_GenParamIndex += step_val82)
    {
      if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("show_progress"))))
      {
        //Show the progress of the evaluation.
        GetDictTuple(hv_GenParam, "show_progress", &hv_ShowProgress);
        hv_ShowProgress = HTuple(int(hv_ShowProgress==HTuple("true"))).TupleOr(int(hv_ShowProgress==1));
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("iou_threshold"))).TupleAnd(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection"))))))
      {
        //Set IoU threshold.
        GetDictTuple(hv_GenParam, "iou_threshold", &hv_IoUThreshold);
        SetDictTuple((*hv_EvalParams), "iou_threshold", hv_IoUThreshold);
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("max_num_detections"))).TupleAnd(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection"))))))
      {
        //Set maximal number detections.
        GetDictTuple(hv_GenParam, "max_num_detections", &hv_MaxNumDetections);
        SetDictTuple((*hv_EvalParams), "max_num_detections", hv_MaxNumDetections);
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("area_ranges"))).TupleAnd(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection"))))))
      {
        //Set area ranges.
        GetDictTuple(hv_GenParam, "area_ranges", &hv_AreaRanges);
        SetDictTuple((*hv_EvalParams), "area_ranges", hv_AreaRanges);
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("detailed_evaluation"))).TupleAnd(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection"))))))
      {
        //Set detailed evaluation.
        GetDictTuple(hv_GenParam, "detailed_evaluation", &hv_DetailedEvaluation);
        SetDictTuple((*hv_EvalParams), "detailed_evaluation", hv_DetailedEvaluation);
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("allocation_block_length"))).TupleAnd(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection"))))))
      {
        //Set length of blocks that are allocated during evaluation.
        GetDictTuple(hv_GenParam, "allocation_block_length", &hv_AllocationBlockLength);
        SetDictTuple((*hv_EvalParams), "allocation_block_length", hv_AllocationBlockLength);
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("interpolate_pr_curves"))).TupleAnd(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection"))))))
      {
        //Set interpolation of precision-recall curves.
        GetDictTuple(hv_GenParam, "interpolate_pr_curves", &hv_DetailedEvaluation);
        SetDictTuple((*hv_EvalParams), "interpolate_pr_curves", hv_DetailedEvaluation);
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("ignore_class_ids"))).TupleAnd(int(hv_ModelType==HTuple("segmentation")))))
      {
        //Set ignore class IDs.
        GetDictTuple(hv_GenParam, "ignore_class_ids", &hv_IgnoreClassIDs);
        //Merge the specified ignore class IDs with the model ignore class IDs.
        hv_AllIgnoreClassIDs = ((hv_ModelIgnoreClassIDs.TupleConcat(hv_IgnoreClassIDs)).TupleSort()).TupleUniq();
        SetDictTuple((*hv_EvalParams), "ignore_class_ids", hv_AllIgnoreClassIDs);
        //Remove the ignore class IDs from the model class IDs.
        TupleDifference(hv_ClassIDs, hv_IgnoreClassIDs, &hv_EvaluateClassIDs);
        SetDictTuple((*hv_EvalParams), "class_ids", hv_EvaluateClassIDs);
        SetDictTuple((*hv_EvalParams), "num_classes", hv_EvaluateClassIDs.TupleLength());
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("class_names_to_evaluate"))).TupleAnd(int(hv_ModelType==HTuple("classification")))))
      {
        //Class names to be used in evaluation.
        //To transform the names to IDs later, one has to remember the class names.
        GetDictTuple(hv_GenParam, "class_names_to_evaluate", &hv_ClassesToEvaluate);
        GetDlModelParam(hv_DLModelHandle, "class_names", &hv_ClassNames);
        SetDictTuple((*hv_EvalParams), "class_names_to_evaluate", hv_ClassesToEvaluate);
        SetDictTuple((*hv_EvalParams), "class_names", hv_ClassNames);
        GetDictParam((*hv_EvalParams), "key_exists", "class_ids_to_evaluate", &hv_KeyExists);
        if (0 != hv_KeyExists)
        {
          //To avoid inconsistent class names/IDs, remove the older ones.
          RemoveDictKey((*hv_EvalParams), "class_ids_to_evaluate");
        }
      }
      else if (0 != (HTuple(int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("class_ids_to_evaluate"))).TupleAnd(int(hv_ModelType==HTuple("classification")))))
      {
        //Class IDs to be used in evaluation.
        GetDictTuple(hv_GenParam, "class_ids_to_evaluate", &hv_ClassIDsToEvaluate);
        SetDictTuple((*hv_EvalParams), "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
        GetDictParam((*hv_EvalParams), "key_exists", "class_names_to_evaluate", &hv_KeyExists);
        if (0 != hv_KeyExists)
        {
          //To avoid inconsistent class names/IDs, remove the older ones.
          RemoveDictKey((*hv_EvalParams), "class_names_to_evaluate");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("anomaly_classification_thresholds"))))
      {
        //Set anomaly classification threshold for confusion matrices.
        GetDictTuple(hv_GenParam, "anomaly_classification_thresholds", &hv_AnomalyClassificationThresholds);
        SetDictTuple((*hv_EvalParams), "anomaly_classification_thresholds", hv_AnomalyClassificationThresholds);
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("evaluate_mask"))))
      {
        GetDictTuple(hv_GenParam, "evaluate_mask", &hv_EvaluateMask);
        if (0 != (hv_EvaluateMask.TupleNot()))
        {
          hv_InstanceType = hv_InstanceTypeModel;
        }
      }
      else if (0 != (int((hv_OptionalKeyNames.TupleFind(HTuple(hv_GenParamKeys[hv_GenParamIndex])))!=-1)))
      {
        GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[hv_GenParamIndex]), &hv_Value);
        SetDictTuple((*hv_EvalParams), HTuple(hv_GenParamKeys[hv_GenParamIndex]), 
            hv_Value);
      }
      else
      {
        throw HException(("Unknown parameter : '"+HTuple(hv_GenParamKeys[hv_GenParamIndex]))+"'");
      }
    }
    }
  }
  //
  //Finally specify the detection evaluation based on all given parameters and defaults.
  if (0 != (int(hv_ModelType==HTuple("detection"))))
  {
    if (0 != (int(hv_InstanceType==HTuple("mask"))))
    {
      SetDictTuple((*hv_EvalParams), "evaluate_mask", 1);
      GetDictTuple((*hv_EvalParams), "measures", &hv_Measures);
      SetDictTuple((*hv_EvalParams), "measures", hv_Measures.TupleDifference("soap"));
    }
    else
    {
      SetDictTuple((*hv_EvalParams), "evaluate_mask", 0);
    }
    //Overwrite instance_type
    SetDictTuple((*hv_EvalParams), "instance_type", hv_InstanceType);
    //For rectangle2 detection with ignore_direction set to false, we also evaluate the
    //precision of the predicted angle using the Score of Angle Precision (SoAP).
    if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      GetDlModelParam(hv_DLModelHandle, "ignore_direction", &hv_IgnoreDirection);
      if (0 != (int(hv_IgnoreDirection==HTuple("false"))))
      {
        GetDictTuple((*hv_EvalParams), "measures", &hv_Measures);
        SetDictTuple((*hv_EvalParams), "measures", hv_Measures.TupleConcat("soap"));
      }
    }
  }
  //
  //Set class names.
  if (0 != (int(hv_ModelType==HTuple("3d_gripping_point_detection"))))
  {
    SetDictTuple((*hv_EvalParams), "class_names", "gripping_map");
  }
  else
  {
    //Get the class names from the dataset if present.
    GetDictParam(hv_DLDataset, "key_exists", (HTuple("class_names").Append("class_ids")), 
        &hv_ClassInfoExists);
    if (0 != (int((hv_ClassInfoExists.TupleSum())==(hv_ClassInfoExists.TupleLength()))))
    {
      GetDictTuple(hv_DLDataset, "class_names", &hv_ClassNames);
      GetDictTuple(hv_DLDataset, "class_ids", &hv_DatasetClassIDs);
      //Set the class names only for the class IDs that are evaluated.
      GetDictTuple((*hv_EvalParams), "class_ids", &hv_EvaluateClassIDs);
      hv_ClassIDsToClassNames = HTuple((hv_DatasetClassIDs.TupleMax())+1,"");
      hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
      if (0 != (int((hv_EvaluateClassIDs.TupleLength())==(hv_ClassNames.TupleLength()))))
      {
        hv_EvaluateClassNames = HTuple(hv_ClassIDsToClassNames[hv_EvaluateClassIDs]);
        //Set the class names to EvalParams.
        SetDictTuple((*hv_EvalParams), "class_names", hv_EvaluateClassNames);
      }
    }
  }
  //
  //Get indices of samples to read from the dataset.
  GetDictTuple(hv_DLDataset, "samples", &hv_DLSamples);
  //
  //Check if there are samples present in the dataset.
  if (0 != (int((hv_DLSamples.TupleLength())==0)))
  {
    throw HException("The provided set of samples in the dataset must be non-empty.");
  }
  //
  //Check for empty SampleSelectValues.
  if (0 != (int((hv_SampleSelectValues.TupleLength())==0)))
  {
    if (0 != (int(hv_SampleSelectMethod==HTuple("image_ids"))))
    {
      throw HException("The provided set of samples of the 'image_ids' selection must be non-empty.");
    }
    else if (0 != (int(hv_SampleSelectMethod==HTuple("sample_indices"))))
    {
      throw HException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
    }
    else
    {
      throw HException("Provide a name for 'split' selection.");
    }
  }
  //
  //
  //Get the sample indices according to the sample selection method.
  hv_SampleIndices = HTuple();
  if (0 != (int(hv_SampleSelectMethod==HTuple("split"))))
  {
    //Get the samples of the split specified.
    find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", &hv_SampleIndices);
  }
  else if (0 != (int(hv_SampleSelectMethod==HTuple("image_ids"))))
  {
    //Get the samples specified by 'image_ids'.
    if (0 != (int((hv_SampleSelectValues.TupleLength())>(hv_DLSamples.TupleLength()))))
    {
      throw HException("The number of the image ids provided through 'image_id' is invalid.");
    }
    find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", &hv_SampleIndices);
  }
  else if (0 != (int(hv_SampleSelectMethod==HTuple("sample_indices"))))
  {
    //Get the samples specified by 'sample_indices'.
    if (0 != (HTuple(int((hv_SampleSelectValues.TupleMin())<0)).TupleOr(int((hv_SampleSelectValues.TupleMax())>((hv_DLSamples.TupleLength())-1)))))
    {
      throw HException("The range of the indices provided through 'sample_indices' is invalid.");
    }
    hv_SampleIndices = hv_SampleSelectValues;
  }
  else
  {
    throw HException(("Unknown sample selection method : '"+hv_SampleSelectMethod)+"'");
  }
  //
  //Get the number of batches.
  hv_NumSamples = hv_SampleIndices.TupleLength();
  hv_NumBatches = ((hv_NumSamples/(hv_BatchSize.TupleReal())).TupleCeil()).TupleInt();
  //
  //Check for empty samples selected by the selection method.
  if (0 != (int(hv_NumSamples==0)))
  {
    throw HException(("No samples present in the dataset that are part of the '"+hv_SampleSelectMethod)+"' selection.");
  }
  //
  //
  //** Running measures are initialized according to evaluation method.
  //
  init_running_evaluation_measures((*hv_EvalParams), &hv_RunningMeasures);
  //
  //
  //** Apply model to each image and gather evaluation information: ***
  //
  //Use alternative outputs if requested.
  hv_Outputs = HTuple();
  //
  if (0 != (HTuple(int(hv_ModelType==HTuple("gc_anomaly_detection"))).TupleAnd(int(hv_GenParam!=HTuple()))))
  {
    //
    GetDictParam(hv_GenParam, "key_exists", "gc_anomaly_networks", &hv_KeyExists);
    if (0 != hv_KeyExists)
    {
      GetDictTuple(hv_GenParam, "gc_anomaly_networks", &hv_EvalGCAnomalyNetworks);
      hv_EvalGCAnomalyNetworks = hv_EvalGCAnomalyNetworks.TupleSort();
      GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", &hv_ModelGCAnomalyNetworks);
      hv_ModelGCAnomalyNetworks = hv_ModelGCAnomalyNetworks.TupleSort();
      //
      hv_DefaultRequested = HTuple(int((hv_EvalGCAnomalyNetworks.TupleLength())==0)).TupleOr(int(hv_EvalGCAnomalyNetworks==hv_ModelGCAnomalyNetworks));
      {
      HTuple end_val274 = (hv_EvalGCAnomalyNetworks.TupleLength())-1;
      HTuple step_val274 = 1;
      for (hv_EvalAnomalyNetworkIndex=0; hv_EvalAnomalyNetworkIndex.Continue(end_val274, step_val274); hv_EvalAnomalyNetworkIndex += step_val274)
      {
        hv_EvalGCAnomalyNetwork = HTuple(hv_EvalGCAnomalyNetworks[hv_EvalAnomalyNetworkIndex]);
        hv_FindIndex = hv_ModelGCAnomalyNetworks.TupleFind(hv_EvalGCAnomalyNetwork);
        if (0 != (HTuple(int(hv_FindIndex==HTuple())).TupleOr(int(hv_FindIndex==-1))))
        {
          throw HException(("Invalid 'gc_anomaly_networks' requested. Model does not contain a "+hv_EvalGCAnomalyNetwork)+" network.");
        }
        if (0 != (hv_DefaultRequested.TupleNot()))
        {
          hv_Outputs = hv_Outputs.TupleConcat("anomaly_image_"+hv_EvalGCAnomalyNetwork);
        }
      }
      }
    }
  }
  //
  //Initialize progress variables.
  if (0 != hv_ShowProgress)
  {
    hv_Progress.Clear();
    hv_Progress[0] = "Procedure: evaluate_dl_model";
    hv_Progress[1] = "";
    hv_Progress[2] = "";
    hv_Progress[3] = "";
    if (0 != (int(hv_ModelType==HTuple("detection"))))
    {
      hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
      hv_Progress = hv_Progress.TupleConcat(hv_TaskInfo);
    }
    CountSeconds(&hv_SecondsStart);
    // dev_inspect_ctrl(...); only in hdevelop
  }
  //
  //Loop batchwise over the samples to be evaluated.
  {
  HTuple end_val299 = hv_NumBatches-1;
  HTuple step_val299 = 1;
  for (hv_BatchIndex=0; hv_BatchIndex.Continue(end_val299, step_val299); hv_BatchIndex += step_val299)
  {
    hv_BatchStart = hv_BatchIndex*hv_BatchSize;
    hv_BatchEnd = ((hv_BatchStart+hv_BatchSize)-1).TupleMin2(hv_NumSamples-1);
    hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(hv_BatchStart,hv_BatchEnd);
    //
    //Read samples
    read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, &hv_DLSamplesBatch);
    //
    //Apply the model.
    ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, hv_Outputs, &hv_DLResultsBatch);
    //
    //Update the running measures.
    update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch, (*hv_EvalParams), 
        hv_RunningMeasures);
    //
    //Provide progress information.
    if (0 != hv_ShowProgress)
    {
      if (0 != (HTuple(int((hv_BatchIndex%10)==1)).TupleOr(int(hv_BatchIndex==(hv_NumBatches-1)))))
      {
        estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_NumBatches-1, &hv_SecondsElapsed, 
            &hv_SecondsRemaining, &hv_ProgressPercent, &hv_ProgressPerSecond);
        timespan_string(hv_SecondsElapsed, "auto", &hv_TimeElapsedString);
        timespan_string(hv_SecondsRemaining, "top2", &hv_TimeRemainingString);
        hv_Progress[1] = ("Progress: "+(hv_ProgressPercent.TupleRound()))+" %";
        hv_Progress[2] = "Time elapsed: "+hv_TimeElapsedString;
        hv_Progress[3] = "Time left: "+hv_TimeRemainingString;
      }
    }
  }
  }
  //
  //Provide progress information.
  if (0 != (hv_ShowProgress.TupleAnd(int(hv_ModelType==HTuple("detection")))))
  {
    hv_Progress.Clear();
    hv_Progress[0] = "Procedure: evaluate_dl_model";
    hv_Progress[1] = "";
    hv_Progress[2] = "";
    hv_Progress[1] = "Please wait...";
    hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
  }
  //
  //
  //** Do the actual calculation of measures: ***
  //
  calculate_evaluation_measures(hv_RunningMeasures, (*hv_EvalParams), &(*hv_EvaluationResult));
  //
  //Close progress inspect.
  if (0 != hv_ShowProgress)
  {
    hv_Progress = "Done.";
    // dev_close_inspect_ctrl(...); only in hdevelop
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, HTuple hv_Mode, 
    HTuple *hv_SampleIndices)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumKeyValues, hv_NumFound, hv_SampleIndex;
  HTuple  hv_Sample, hv_KeyExists, hv_Tuple, hv_Hit, hv_ValueIndex;
  HTuple  hv_Value;

  //
  //This procedure gets the indices of the samples that contain the
  //requested KeyName matching the requested KeyValue according to the Mode.
  //If there is no match, an empty tuple [] will be returned.
  //
  //Check input parameters.
  if (0 != (int((hv_KeyName.TupleLength())!=1)))
  {
    throw HException(HTuple("Invalid KeyName size: ")+(hv_KeyName.TupleLength()));
  }
  if (0 != (int((hv_Mode.TupleLength())!=1)))
  {
    throw HException(HTuple("Invalid Mode size: ")+(hv_Mode.TupleLength()));
  }
  if (0 != (HTuple(HTuple(int(hv_Mode!=HTuple("match"))).TupleAnd(int(hv_Mode!=HTuple("or")))).TupleAnd(int(hv_Mode!=HTuple("contain")))))
  {
    throw HException("Invalid Mode value: "+hv_Mode);
  }
  hv_NumKeyValues = hv_KeyValue.TupleLength();
  if (0 != (HTuple(int(hv_Mode==HTuple("contain"))).TupleAnd(int(hv_NumKeyValues<1))))
  {
    throw HException("Invalid KeyValue size for contain Mode: "+hv_NumKeyValues);
  }
  //
  //Find the indices.
  (*hv_SampleIndices) = HTuple(hv_Samples.TupleLength(),0);
  hv_NumFound = 0;
  //
  {
  HTuple end_val24 = (hv_Samples.TupleLength())-1;
  HTuple step_val24 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val24, step_val24); hv_SampleIndex += step_val24)
  {
    hv_Sample = HTuple(hv_Samples[hv_SampleIndex]);
    GetDictParam(hv_Sample, "key_exists", hv_KeyName, &hv_KeyExists);
    if (0 != hv_KeyExists)
    {
      GetDictTuple(hv_Sample, hv_KeyName, &hv_Tuple);
      if (0 != (int(hv_Mode==HTuple("match"))))
      {
        //Mode 'match': Tuple must be equal KeyValue.
        hv_Hit = int(hv_Tuple==hv_KeyValue);
      }
      else if (0 != (HTuple(int(hv_Mode==HTuple("or"))).TupleAnd(int((hv_Tuple.TupleLength())==1))))
      {
        //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
        hv_Hit = int((hv_KeyValue.TupleFindFirst(hv_Tuple))>=0);
      }
      else if (0 != (int(hv_Mode==HTuple("contain"))))
      {
        //Mode 'contain': Tuple must contain any of the elements in KeyValue.
        {
        HTuple end_val37 = hv_NumKeyValues-1;
        HTuple step_val37 = 1;
        for (hv_ValueIndex=0; hv_ValueIndex.Continue(end_val37, step_val37); hv_ValueIndex += step_val37)
        {
          hv_Value = HTuple(hv_KeyValue[hv_ValueIndex]);
          hv_Hit = int((hv_Tuple.TupleFindFirst(hv_Value))>=0);
          if (0 != hv_Hit)
          {
            break;
          }
        }
        }
      }
      else
      {
        //Unsupported configuration.
        hv_Hit = 0;
      }
      if (0 != hv_Hit)
      {
        (*hv_SampleIndices)[hv_NumFound] = hv_SampleIndex;
        hv_NumFound += 1;
      }
    }
  }
  }
  (*hv_SampleIndices) = (*hv_SampleIndices).TupleSelectRange(0,hv_NumFound-1);
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
void gen_confusion_matrix (HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, HTuple *hv_ConfusionMatrix)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayMatrix, hv_ReturnMatrix, hv_DisplayColor;
  HTuple  hv_DisplayColumnWidth, hv_GenParamIndex, hv_CalculateRelativeMatrix;
  HTuple  hv_Classes, hv_NumClasses, hv_AbsoluteMatrixID;
  HTuple  hv_RelativeMatrixID, hv_ColumnMatrix, hv_Class;
  HTuple  hv_ThisLabel, hv_NumClassGroundTruth, hv_RowMatrix;
  HTuple  hv_PredictedClass, hv_ThisPredictedClass, hv_NumMatches;
  HTuple  hv_RelativeError, hv_StringWidths, hv_StringIndex;
  HTuple  hv_String, hv_Ascent, hv_Descent, hv_StringWidth;
  HTuple  hv_StringHeight, hv_MaxStringWidth, hv_RowStart;
  HTuple  hv_RowDistance, hv_RowEnd, hv_ColumnStart, hv_ColumnOffset;
  HTuple  hv_ColumnEnd, hv_Width, hv_Height, hv_WidthLimit;
  HTuple  hv_HeightLimit, hv_TextRow, hv_TextColumn, hv_Index;
  HTuple  hv_Text, hv_Row, hv_Column, hv_AbsoluteTransposedMatrixID;
  HTuple  hv_MatrixText, hv_MatrixMaxID, hv_MaxValue, hv_StringConversion;
  HTuple  hv_RelativeTransposedMatrixID, hv_TextColor, hv_RelativeValues;
  HTuple  hv_Thresholds, hv_Colors, hv_Greater, hv_Indices;
  HTuple  hv_DiagonalIndex, hv_Value;

  //This procedure computes a confusion matrix.
  //Therefore, it compares the classes
  //assigned in GroundTruthLabels and PredictedClasses.
  //The resulting confusion matrix can be
  //visualized, returned, or both.
  //In each case, the output can be changed
  //via generic parameters using GenParamName and GenParamValue.
  //For the visualization, the graphics window
  //must be specified with WindowHandle.
  //
  if (0 != (int((hv_GroundTruthLabels.TupleLength())!=(hv_PredictedClasses.TupleLength()))))
  {
    throw HException("Number of ground truth labels and predicted classes must be equal.");
  }
  //
  //Set generic parameter defaults.
  hv_DisplayMatrix = "absolute";
  hv_ReturnMatrix = "absolute";
  hv_DisplayColor = "true";
  hv_DisplayColumnWidth = "minimal";
  //
  //Parse generic parameters.
  {
  HTuple end_val21 = (hv_GenParamName.TupleLength())-1;
  HTuple step_val21 = 1;
  for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val21, step_val21); hv_GenParamIndex += step_val21)
  {
    if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("display_matrix"))))
    {
      //Set 'display_matrix'.
      hv_DisplayMatrix = HTuple(hv_GenParamValue[hv_GenParamIndex]);
    }
    else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("return_matrix"))))
    {
      //Set 'return_matrix'.
      hv_ReturnMatrix = HTuple(hv_GenParamValue[hv_GenParamIndex]);
    }
    else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("display_color"))))
    {
      //Set 'display_color'.
      hv_DisplayColor = HTuple(hv_GenParamValue[hv_GenParamIndex]);
    }
    else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("display_column_width"))))
    {
      //Set 'display_column_width'.
      hv_DisplayColumnWidth = HTuple(hv_GenParamValue[hv_GenParamIndex]);
    }
    else
    {
      throw HException(("Unknown generic parameter: '"+HTuple(hv_GenParamName[hv_GenParamIndex]))+"'");
    }
  }
  }
  //
  if (0 != (HTuple(HTuple(int(hv_DisplayMatrix==HTuple("relative"))).TupleOr(int(hv_ReturnMatrix==HTuple("relative")))).TupleOr(int(hv_DisplayColor==HTuple("true")))))
  {
    hv_CalculateRelativeMatrix = 1;
  }
  else
  {
    hv_CalculateRelativeMatrix = 0;
  }
  //
  //Calculate the confusion matrix with absolute values
  //and the confusion matrix with relative errors.
  //We start with an empty matrix
  //and add the number of matching labels.
  hv_Classes = (hv_GroundTruthLabels.TupleSort()).TupleUniq();
  hv_NumClasses = hv_Classes.TupleLength();
  CreateMatrix(hv_NumClasses, hv_NumClasses, 0, &hv_AbsoluteMatrixID);
  if (0 != hv_CalculateRelativeMatrix)
  {
    CreateMatrix(hv_NumClasses, hv_NumClasses, 0, &hv_RelativeMatrixID);
  }
  {
  HTuple end_val55 = hv_NumClasses-1;
  HTuple step_val55 = 1;
  for (hv_ColumnMatrix=0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix += step_val55)
  {
    hv_Class = HTuple(hv_Classes[hv_ColumnMatrix]);
    hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(hv_Class);
    if (0 != hv_CalculateRelativeMatrix)
    {
      //Obtain the number of ground truth labels per class.
      hv_NumClassGroundTruth = hv_ThisLabel.TupleSum();
    }
    {
    HTuple end_val62 = hv_NumClasses-1;
    HTuple step_val62 = 1;
    for (hv_RowMatrix=0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix += step_val62)
    {
      //Select classes for this row/column.
      hv_PredictedClass = HTuple(hv_Classes[hv_RowMatrix]);
      //Check whether the input data
      //corresponds to these classes.
      hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(hv_PredictedClass);
      //Count the number of elements where the predicted class
      //matches the ground truth label.
      hv_NumMatches = ((hv_ThisLabel+hv_ThisPredictedClass).TupleEqualElem(2)).TupleSum();
      //Set value in matrix.
      SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix, hv_NumMatches);
      if (0 != hv_CalculateRelativeMatrix)
      {
        if (0 != (int(hv_NumClassGroundTruth>0)))
        {
          hv_RelativeError = (hv_NumMatches.TupleReal())/hv_NumClassGroundTruth;
        }
        else
        {
          hv_RelativeError = 0;
        }
        SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix, hv_RelativeError);
      }
    }
    }
  }
  }
  //
  //Return the result.
  if (0 != (int(hv_ReturnMatrix==HTuple("absolute"))))
  {
    CopyMatrix(hv_AbsoluteMatrixID, &(*hv_ConfusionMatrix));
  }
  else if (0 != (int(hv_ReturnMatrix==HTuple("relative"))))
  {
    CopyMatrix(hv_RelativeMatrixID, &(*hv_ConfusionMatrix));
  }
  else if (0 != (int(hv_ReturnMatrix==HTuple("none"))))
  {
    //No matrix is returned.
  }
  else
  {
    throw HException("Unsupported mode for 'return_matrix'");
  }
  //
  //Display the matrix.
  if (0 != (int(hv_DisplayMatrix!=HTuple("none"))))
  {
    //
    //Find maximal string width and set display position parameters.
    hv_StringWidths = HTuple();
    //Get the string width of each class.
    {
    HTuple end_val101 = (hv_Classes.TupleLength())-1;
    HTuple step_val101 = 1;
    for (hv_StringIndex=0; hv_StringIndex.Continue(end_val101, step_val101); hv_StringIndex += step_val101)
    {
      hv_String = HTuple(hv_Classes[hv_StringIndex]);
      GetStringExtents(hv_WindowHandle, hv_String, &hv_Ascent, &hv_Descent, &hv_StringWidth, 
          &hv_StringHeight);
      hv_StringWidths = hv_StringWidths.TupleConcat(hv_StringWidth);
    }
    }
    //The columns should have a minimum width for 4 characters.
    GetStringExtents(hv_WindowHandle, "test", &hv_Ascent, &hv_Descent, &hv_StringWidth, 
        &hv_StringHeight);
    hv_MaxStringWidth = (hv_StringWidths.TupleMax()).TupleMax2(hv_StringWidth);
    //Get the maximum string width
    //and resize the window accordingly.
    hv_RowStart = 80;
    hv_RowDistance = hv_StringHeight+10;
    hv_RowEnd = hv_StringHeight*7;
    hv_ColumnStart = 50+hv_MaxStringWidth;
    hv_ColumnOffset = 20;
    hv_ColumnEnd = hv_ColumnOffset;
    //
    //Adapt the window size to fit the confusion matrix.
    if (0 != (int(hv_DisplayColumnWidth==HTuple("minimal"))))
    {
      //Every column of the confusion matrix is as narrow as possible
      //based to the respective string widths.
      hv_Width = (((hv_StringWidths.TupleSum())+(hv_ColumnOffset*hv_NumClasses))+hv_ColumnStart)+hv_ColumnEnd;
    }
    else if (0 != (int(hv_DisplayColumnWidth==HTuple("equal"))))
    {
      //Every column of the confusion matrix should have the same width.
      //based on the maximum string width.
      hv_Width = (((hv_MaxStringWidth+hv_ColumnOffset)*hv_NumClasses)+hv_ColumnStart)+hv_ColumnEnd;
    }
    else
    {
      throw HException("");
    }
    hv_Height = ((hv_RowDistance*hv_NumClasses)+hv_RowStart)+hv_RowEnd;
    HDevWindowStack::SetActive(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    //
    //Set reasonable limits for graphics window (adapt if necessary).
    hv_WidthLimit.Clear();
    hv_WidthLimit[0] = 450;
    hv_WidthLimit[1] = 1920;
    hv_HeightLimit.Clear();
    hv_HeightLimit[0] = 250;
    hv_HeightLimit[1] = 1080;
    if (0 != (HTuple(int(hv_Width>HTuple(hv_WidthLimit[1]))).TupleOr(int(hv_Height>HTuple(hv_HeightLimit[1])))))
    {
      throw HException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
    }
    dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
    //
    //Get display coordinates.
    //Get row coordinates for display.
    hv_TextRow = HTuple();
    {
    HTuple end_val145 = hv_NumClasses-1;
    HTuple step_val145 = 1;
    for (hv_ColumnMatrix=0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix += step_val145)
    {
      hv_TextRow = hv_TextRow.TupleConcat(HTuple::TupleGenSequence(0,(hv_NumClasses-1)*hv_RowDistance,hv_RowDistance));
    }
    }
    //Get column coordinates for display.
    hv_TextColumn = HTuple();
    {
    HTuple end_val150 = hv_NumClasses-1;
    HTuple step_val150 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val150, step_val150); hv_Index += step_val150)
    {
      hv_TextColumn = hv_TextColumn.TupleConcat(HTuple(hv_NumClasses,hv_ColumnStart));
      if (0 != (int(hv_DisplayColumnWidth==HTuple("minimal"))))
      {
        hv_ColumnStart = (hv_ColumnStart+HTuple(hv_StringWidths[hv_Index]))+hv_ColumnOffset;
      }
      else if (0 != (int(hv_DisplayColumnWidth==HTuple("equal"))))
      {
        hv_ColumnStart = (hv_ColumnStart+hv_MaxStringWidth)+hv_ColumnOffset;
      }
    }
    }
    //Display the confusion matrix with a margin from the top.
    hv_TextRow += hv_RowStart;
    //Display axis titles.
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"Ground truth labels", "window", "top", 
          "right", "white", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"Predicted classes", "window", "bottom", 
          "left", "white", "box", "false");
    {
    HTuple end_val163 = (hv_Classes.TupleLength())-1;
    HTuple step_val163 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val163, step_val163); hv_Index += step_val163)
    {
      hv_Text = HTuple(hv_Classes[hv_Index]);
      //Display predicted class names.
      hv_Row = HTuple(hv_TextRow[hv_Index]);
      hv_Column = (HTuple(hv_TextColumn[0])-hv_MaxStringWidth)-hv_ColumnOffset;
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_Text, "window", hv_Row, hv_Column, 
            "light gray", "box", "false");
      //Display ground truth label names.
      hv_Row = HTuple(hv_TextRow[0])-hv_RowDistance;
      hv_Column = HTuple(hv_TextColumn[hv_Index*hv_NumClasses]);
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_Text, "window", hv_Row, hv_Column, 
            "light gray", "box", "false");
    }
    }
    //
    //Get the confusion matrix values for display.
    if (0 != (int(hv_DisplayMatrix==HTuple("absolute"))))
    {
      //Displayed matrix corresponds to the transposed returned matrix.
      TransposeMatrix(hv_AbsoluteMatrixID, &hv_AbsoluteTransposedMatrixID);
      GetFullMatrix(hv_AbsoluteTransposedMatrixID, &hv_MatrixText);
      ClearMatrix(hv_AbsoluteTransposedMatrixID);
      //Align the numbers right.
      MaxMatrix(hv_AbsoluteMatrixID, "full", &hv_MatrixMaxID);
      GetFullMatrix(hv_MatrixMaxID, &hv_MaxValue);
      ClearMatrix(hv_MatrixMaxID);
      hv_StringConversion = (((hv_MaxValue.TupleLog10()).TupleCeil()).TupleInt())+".0f";
      hv_MatrixText = hv_MatrixText.TupleString(hv_StringConversion);
    }
    else
    {
      //Displayed matrix corresponds to the transposed returned matrix.
      TransposeMatrix(hv_RelativeMatrixID, &hv_RelativeTransposedMatrixID);
      GetFullMatrix(hv_RelativeTransposedMatrixID, &hv_MatrixText);
      ClearMatrix(hv_RelativeTransposedMatrixID);
      hv_MatrixText = hv_MatrixText.TupleString(".2f");
    }
    //Set color for displayed confusion matrix.
    if (0 != (int(hv_DisplayColor==HTuple("true"))))
    {
      TupleGenConst(hv_MatrixText.TupleLength(), "#666666", &hv_TextColor);
      //Use the relative values to adapt the color of the text.
      TransposeMatrix(hv_RelativeMatrixID, &hv_RelativeTransposedMatrixID);
      GetFullMatrix(hv_RelativeTransposedMatrixID, &hv_RelativeValues);
      ClearMatrix(hv_RelativeTransposedMatrixID);
      //Set the colors and respective thresholds for the off-diagonal values.
      hv_Thresholds.Clear();
      hv_Thresholds[0] = 0.0;
      hv_Thresholds[1] = 0.05;
      hv_Thresholds[2] = 0.1;
      hv_Thresholds[3] = 0.2;
      hv_Colors.Clear();
      hv_Colors[0] = "#8C4D4D";
      hv_Colors[1] = "#B33333";
      hv_Colors[2] = "#D91A1A";
      hv_Colors[3] = "#FF0000";
      {
      HTuple end_val204 = (hv_Thresholds.TupleLength())-1;
      HTuple step_val204 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val204, step_val204); hv_Index += step_val204)
      {
        TupleGreaterElem(hv_RelativeValues, HTuple(hv_Thresholds[hv_Index]), &hv_Greater);
        TupleFind(hv_Greater, 1, &hv_Indices);
        if (0 != (int(hv_Indices!=-1)))
        {
          TupleReplace(hv_TextColor, hv_Indices, HTuple(hv_Colors[hv_Index]), &hv_TextColor);
        }
        else
        {
          break;
        }
      }
      }
      //Set the colors and respective thresholds for the diagonal values.
      hv_Thresholds.Clear();
      hv_Thresholds[0] = -0.01;
      hv_Thresholds[1] = 0.60;
      hv_Thresholds[2] = 0.80;
      hv_Thresholds[3] = 0.90;
      hv_Thresholds[4] = 0.95;
      hv_Thresholds[5] = 0.98;
      hv_Colors.Clear();
      hv_Colors[0] = "#666666";
      hv_Colors[1] = "#508650";
      hv_Colors[2] = "#419C41";
      hv_Colors[3] = "#2BBD2B";
      hv_Colors[4] = "#15DE15";
      hv_Colors[5] = "#00FF00";
      {
      HTuple end_val216 = hv_NumClasses-1;
      HTuple step_val216 = 1;
      for (hv_DiagonalIndex=0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex += step_val216)
      {
        GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex, &hv_Value);
        {
        HTuple end_val218 = (hv_Thresholds.TupleLength())-1;
        HTuple step_val218 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val218, step_val218); hv_Index += step_val218)
        {
          if (0 != (int(hv_Value>HTuple(hv_Thresholds[hv_Index]))))
          {
            hv_TextColor[hv_DiagonalIndex*(hv_NumClasses+1)] = HTuple(hv_Colors[hv_Index]);
          }
          else
          {
            break;
          }
        }
        }
      }
      }
    }
    else
    {
      //Default value for the text color.
      TupleGenConst(hv_MatrixText.TupleLength(), "white", &hv_TextColor);
    }
    //
    //Display confusion matrix.
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_MatrixText, "window", hv_TextRow, 
          hv_TextColumn, hv_TextColor, "box", "false");
    //
    //Clean up.
    if (0 != hv_CalculateRelativeMatrix)
    {
      ClearMatrix(hv_RelativeMatrixID);
    }
    ClearMatrix(hv_AbsoluteMatrixID);
  }
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Generate gripping points for connected regions of high gripping confidence. 
void gen_dl_3d_gripping_point_image_coord (HObject ho_GrippingMap, HObject *ho_Regions, 
    HTuple hv_MinAreaSize, HTuple *hv_Rows, HTuple *hv_Columns)
{

  // Local iconic variables
  HObject  ho_TmpRegions, ho_FilteredRegions, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_Skeletons, ho_OrigRegion;
  HObject  ho_Skeleton, ho_SkeletonIntersection, ho_Contours;
  HObject  ho_ContourRegions, ho_ContourSelected, ho_RegionSelected;
  HObject  ho_CenterRegion;

  // Local control variables
  HTuple  hv_GapClosingRadius, hv_NumDilationRuns;
  HTuple  hv_NumRegions, hv_RegionIdx, hv_Area, hv_Row1, hv_Column1;
  HTuple  hv_Radius, hv_RadiusIndex, hv_Dilation, hv_Rows1;
  HTuple  hv_Columns1, hv_RowOut, hv_Indices, hv_SelectedColumns;
  HTuple  hv_ColumnOut, hv_NumContours, hv_CandidateRows;
  HTuple  hv_CandidateCols, hv_ContourIdx, hv_Row, hv_Column;
  HTuple  hv_MinDistance, hv_RowCandidate, hv_ColumnCandidate;
  HTuple  hv_RowUnused, hv_ColumnUnused, hv_MinDist, hv_MaxDist;
  HTuple  hv_Indices1;

  //
  //This procedure extracts connected regions from the gripping
  //map and generates a single gripping point near the center
  //of each of those regions.
  //
  hv_GapClosingRadius = 3.5;
  hv_NumDilationRuns = 5;
  //
  //Compute regions (connected components).
  Threshold(ho_GrippingMap, &ho_TmpRegions, 0.5, 1);
  //
  //Close small gaps inside regions to get a nicer skeleton.
  ClosingCircle(ho_TmpRegions, &ho_FilteredRegions, hv_GapClosingRadius);
  //
  Connection(ho_FilteredRegions, &ho_ConnectedRegions);
  //
  //Filter for regions smaller than RegionThreshold.
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_MinAreaSize, 
      "max");
  CountObj(ho_SelectedRegions, &hv_NumRegions);
  if (0 != (int(hv_NumRegions<1)))
  {
    GenEmptyObj(&(*ho_Regions));
    (*hv_Rows) = HTuple();
    (*hv_Columns) = HTuple();
    return;
  }
  //
  //Determine gripping point based on skeleton per region.
  Skeleton(ho_SelectedRegions, &ho_Skeletons);
  TupleGenConst(hv_NumRegions, 0, &(*hv_Rows));
  TupleGenConst(hv_NumRegions, 0, &(*hv_Columns));
  GenEmptyObj(&(*ho_Regions));
  {
  HTuple end_val31 = hv_NumRegions;
  HTuple step_val31 = 1;
  for (hv_RegionIdx=1; hv_RegionIdx.Continue(end_val31, step_val31); hv_RegionIdx += step_val31)
  {
    SelectObj(ho_SelectedRegions, &ho_OrigRegion, hv_RegionIdx);
    Intersection(ho_OrigRegion, ho_TmpRegions, &ho_OrigRegion);
    SelectObj(ho_Skeletons, &ho_Skeleton, hv_RegionIdx);
    //
    //Reduce skeleton and region produced by contours by original
    //region (if skeleton used pixels added by closing circle).
    Intersection(ho_Skeleton, ho_OrigRegion, &ho_SkeletonIntersection);
    //
    //Check if skeleton lies outside valid region
    AreaCenter(ho_SkeletonIntersection, &hv_Area, &hv_Row1, &hv_Column1);
    if (0 != (int(hv_Area==0)))
    {
      //Skeleton outside valid region -> use simple median row pixel and
      //fixing this row, the median column pixel. This case should be
      //extremely rare.
      RegionFeatures(ho_OrigRegion, "outer_radius", &hv_Radius);
      {
      HTuple end_val47 = hv_NumDilationRuns-1;
      HTuple step_val47 = 1;
      for (hv_RadiusIndex=0; hv_RadiusIndex.Continue(end_val47, step_val47); hv_RadiusIndex += step_val47)
      {
        hv_Dilation = (hv_Radius/hv_NumDilationRuns).TupleMax2(1.5);
        DilationCircle(ho_Skeleton, &ho_Skeleton, hv_Dilation);
        Intersection(ho_Skeleton, ho_OrigRegion, &ho_SkeletonIntersection);
        AreaCenter(ho_SkeletonIntersection, &hv_Area, &hv_Row1, &hv_Column1);
        if (0 != (int(hv_Area>0)))
        {
          break;
        }
      }
      }
      GetRegionPoints(ho_SkeletonIntersection, &hv_Rows1, &hv_Columns1);
      TupleMedian(hv_Rows1, &hv_RowOut);
      TupleFind(hv_Rows1, hv_RowOut, &hv_Indices);
      TupleSelect(hv_Columns1, hv_Indices, &hv_SelectedColumns);
      TupleMedian(hv_SelectedColumns, &hv_ColumnOut);
    }
    else
    {
      //Skeleton inside valid region -> use skeleton
      GenContoursSkeletonXld(ho_SkeletonIntersection, &ho_Contours, 1, "filter");
      GenRegionContourXld(ho_Contours, &ho_ContourRegions, "margin");
      Intersection(ho_ContourRegions, ho_SkeletonIntersection, &ho_ContourRegions
          );
      //
      //From every contour select middle point as candidate.
      CountObj(ho_Contours, &hv_NumContours);
      TupleGenConst(hv_NumContours, 0, &hv_CandidateRows);
      TupleGenConst(hv_NumContours, 0, &hv_CandidateCols);
      {
      HTuple end_val71 = hv_NumContours;
      HTuple step_val71 = 1;
      for (hv_ContourIdx=1; hv_ContourIdx.Continue(end_val71, step_val71); hv_ContourIdx += step_val71)
      {
        SelectObj(ho_Contours, &ho_ContourSelected, hv_ContourIdx);
        SelectObj(ho_ContourRegions, &ho_RegionSelected, hv_ContourIdx);
        //
        //Select point in RegionSelected closest to middle
        //of the contour.
        GetContourXld(ho_ContourSelected, &hv_Row, &hv_Column);
        GenRegionRuns(&ho_CenterRegion, HTuple(hv_Row[(hv_Row.TupleLength())/2]), 
            HTuple(hv_Column[(hv_Column.TupleLength())/2]), HTuple(hv_Column[(hv_Column.TupleLength())/2]));
        //
        //Make sure the selected point is always inside
        //the region.
        DistanceRrMin(ho_RegionSelected, ho_CenterRegion, &hv_MinDistance, &hv_RowCandidate, 
            &hv_ColumnCandidate, &hv_RowUnused, &hv_ColumnUnused);
        //
        hv_CandidateRows[hv_ContourIdx-1] = hv_RowCandidate;
        hv_CandidateCols[hv_ContourIdx-1] = hv_ColumnCandidate;
      }
      }
      //
      //Find candidate with minimum maximum distance to any
      //point in SkeletonIntersection.
      DistancePr(ho_SkeletonIntersection, hv_CandidateRows, hv_CandidateCols, &hv_MinDist, 
          &hv_MaxDist);
      TupleSortIndex(hv_MaxDist, &hv_Indices1);
      hv_RowOut = HTuple(hv_CandidateRows[HTuple(hv_Indices1[0])]);
      hv_ColumnOut = HTuple(hv_CandidateCols[HTuple(hv_Indices1[0])]);
    }
    //
    //Collect output.
    (*hv_Rows)[hv_RegionIdx-1] = hv_RowOut;
    (*hv_Columns)[hv_RegionIdx-1] = hv_ColumnOut;
    ConcatObj((*ho_Regions), ho_OrigRegion, &(*ho_Regions));
  }
  }
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Extract gripping points based on a 3D gripping point detection model output. 
void gen_dl_3d_gripping_points_and_poses (HTuple hv_DLSampleBatch, HTuple hv_DLGrippingPointParams, 
    HTuple hv_DLResultBatch)
{

  // Local iconic variables
  HObject  ho_Regions, ho___Tmp_Obj_0;

  // Local control variables
  HTuple  hv_MinAreaSize, hv_SortingDirection, hv_SampleIndex;
  HTuple  hv_DLSample, hv_DLResult, hv_Rows, hv_Columns, hv_HasXYZ;
  HTuple  hv_X, hv_Y, hv_Z, hv_NormalsXYZ, hv_NX, hv_NY, hv_NZ;
  HTuple  hv_DLResultUnsorted, hv_Index, hv_GrippingPoint;
  HTuple  hv_Depths, hv_AscendingIndices, hv___Tmp_Ctrl_0;

  //Extracts gripping points from connected regions in the
  //'gripping_map' image of the items in DLResultBatch.
  //Stores gripping points in a dict containing
  //row, column, region and pose.
  //
  if (0 != (int((hv_DLGrippingPointParams.TupleLength())==0)))
  {
    CreateDict(&hv_DLGrippingPointParams);
  }
  //
  check_dl_3d_gripping_points_and_poses_params(hv_DLGrippingPointParams);
  //
  hv_MinAreaSize = hv_DLGrippingPointParams.TupleGetDictTuple("min_area_size");
  hv_SortingDirection = hv_DLGrippingPointParams.TupleGetDictTuple("sorting_direction");
  //
  //Preprocess the sample entries.
  {
  HTuple end_val15 = (hv_DLSampleBatch.TupleLength())-1;
  HTuple step_val15 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val15, step_val15); hv_SampleIndex += step_val15)
  {
    hv_DLSample = HTuple(hv_DLSampleBatch[hv_SampleIndex]);
    hv_DLResult = HTuple(hv_DLResultBatch[hv_SampleIndex]);
    //
    gen_dl_3d_gripping_point_image_coord(hv_DLResult.TupleGetDictObject("gripping_map"), 
        &ho_Regions, hv_MinAreaSize, &hv_Rows, &hv_Columns);
    if (0 != (int((hv_Rows.TupleLength())<1)))
    {
      SetDictTuple(hv_DLResult, "gripping_points", HTuple());
      continue;
    }
    //
    //Convert to output.
    GetDictParam(hv_DLSample, "key_exists", ((HTuple("x").Append("y")).Append("z")), 
        &hv_HasXYZ);
    TupleMin(hv_HasXYZ, &hv_HasXYZ);
    if (0 != hv_HasXYZ)
    {
      GetGrayval(hv_DLSample.TupleGetDictObject("x"), hv_Rows, hv_Columns, &hv_X);
      GetGrayval(hv_DLSample.TupleGetDictObject("y"), hv_Rows, hv_Columns, &hv_Y);
      GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns, &hv_Z);
      GetGrayval(hv_DLSample.TupleGetDictObject("normals"), hv_Rows, hv_Columns, 
          &hv_NormalsXYZ);
      hv_NX = ((const HTuple&)hv_NormalsXYZ)[HTuple::TupleGenSequence(0,(hv_NormalsXYZ.TupleLength())-1,3)];
      hv_NY = ((const HTuple&)hv_NormalsXYZ)[HTuple::TupleGenSequence(1,(hv_NormalsXYZ.TupleLength())-1,3)];
      hv_NZ = ((const HTuple&)hv_NormalsXYZ)[HTuple::TupleGenSequence(2,(hv_NormalsXYZ.TupleLength())-1,3)];
    }
    //
    TupleGenConst(hv_Rows.TupleLength(), HTuple::TupleConstant("HNULL"), &hv_DLResultUnsorted);
    {
    HTuple end_val39 = (hv_Rows.TupleLength())-1;
    HTuple step_val39 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val39, step_val39); hv_Index += step_val39)
    {
      CreateDict(&hv_GrippingPoint);
      hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
      SetDictTuple(hv_GrippingPoint, "row", HTuple(hv_Rows[hv_Index]));
      SetDictTuple(hv_GrippingPoint, "column", HTuple(hv_Columns[hv_Index]));
      SelectObj(ho_Regions, &ho___Tmp_Obj_0, hv_Index+1);
      SetDictObject(ho___Tmp_Obj_0, hv_GrippingPoint, "region");
      if (0 != hv_HasXYZ)
      {
        convert_dl_3d_gripping_point_to_pose(HTuple(hv_X[hv_Index]), HTuple(hv_Y[hv_Index]), 
            HTuple(hv_Z[hv_Index]), HTuple(hv_NX[hv_Index]), HTuple(hv_NY[hv_Index]), 
            HTuple(hv_NZ[hv_Index]), &hv___Tmp_Ctrl_0);
        SetDictTuple(hv_GrippingPoint, "pose", hv___Tmp_Ctrl_0);
      }
      hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
    }
    }
    //
    //Sort by ascending depth (closer objects first).
    if (0 != hv_HasXYZ)
    {
      hv_Depths = ((hv_X*HTuple(hv_SortingDirection[0]))+(hv_Y*HTuple(hv_SortingDirection[1])))+(hv_Z*HTuple(hv_SortingDirection[2]));
    }
    else
    {
      GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns, &hv_Depths);
    }
    TupleSortIndex(hv_Depths, &hv_AscendingIndices);
    TupleGenConst(hv_Rows.TupleLength(), HTuple::TupleConstant("HNULL"), &hv___Tmp_Ctrl_0);
    SetDictTuple(hv_DLResult, "gripping_points", hv___Tmp_Ctrl_0);
    SetDictTuple(hv_DLResult, "gripping_points", HTuple(hv_DLResultUnsorted[hv_AscendingIndices]));
  }
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Generate NumColors distinct colors 
void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
    HTuple hv_EndColor, HTuple *hv_Colors)
{

  // Local iconic variables
  HObject  ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
  HObject  ho_ImageR, ho_ImageG, ho_ImageB;

  // Local control variables
  HTuple  hv_IsString, hv_Hue, hv_Lightness, hv_Saturation;
  HTuple  hv_Rows, hv_Columns, hv_Red, hv_Green, hv_Blue;

  //
  //We get distinct color-values first in HLS color-space.
  //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
  //
  //Parameter checks.
  //NumColors.
  if (0 != (int(hv_NumColors<1)))
  {
    throw HException("NumColors should be at least 1");
  }
  if (0 != ((hv_NumColors.TupleIsInt()).TupleNot()))
  {
    throw HException("NumColors should be of type int");
  }
  if (0 != (int((hv_NumColors.TupleLength())!=1)))
  {
    throw HException("NumColors should have length 1");
  }
  //Random.
  if (0 != (HTuple(int(hv_Random!=0)).TupleAnd(int(hv_Random!=1))))
  {
    TupleIsString(hv_Random, &hv_IsString);
    if (0 != hv_IsString)
    {
      hv_Random = HTuple(int(hv_Random==HTuple("true"))).TupleOr("false");
    }
    else
    {
      throw HException("Random should be either true or false");
    }
  }
  //StartColor.
  if (0 != (int((hv_StartColor.TupleLength())!=1)))
  {
    throw HException("StartColor should have length 1");
  }
  if (0 != (HTuple(int(hv_StartColor<0)).TupleOr(int(hv_StartColor>255))))
  {
    throw HException(HTuple("StartColor should be in the range [0, 255]"));
  }
  if (0 != ((hv_StartColor.TupleIsInt()).TupleNot()))
  {
    throw HException("StartColor should be of type int");
  }
  //EndColor.
  if (0 != (int((hv_EndColor.TupleLength())!=1)))
  {
    throw HException("EndColor should have length 1");
  }
  if (0 != (HTuple(int(hv_EndColor<0)).TupleOr(int(hv_EndColor>255))))
  {
    throw HException(HTuple("EndColor should be in the range [0, 255]"));
  }
  if (0 != ((hv_EndColor.TupleIsInt()).TupleNot()))
  {
    throw HException("EndColor should be of type int");
  }
  //
  //Color generation.
  if (0 != (int(hv_StartColor>hv_EndColor)))
  {
    hv_EndColor += 255;
  }
  if (0 != (int(hv_NumColors!=1)))
  {
    hv_Hue = (hv_StartColor+((((hv_EndColor-hv_StartColor)*(HTuple::TupleGenSequence(0,hv_NumColors-1,1).TupleReal()))/((hv_NumColors-1).TupleReal())).TupleInt()))%255;
  }
  else
  {
    hv_Hue = (hv_StartColor.TupleConcat(hv_EndColor)).TupleMean();
  }
  if (0 != hv_Random)
  {
    hv_Hue = ((const HTuple&)hv_Hue)[HTuple::TupleRand(hv_NumColors).TupleSortIndex()];
    hv_Lightness = (((5.0+HTuple::TupleRand(hv_NumColors))*255.0)/10.0).TupleInt();
    hv_Saturation = (((9.0+HTuple::TupleRand(hv_NumColors))*255.0)/10.0).TupleInt();
  }
  else
  {
    hv_Lightness = (HTuple(hv_NumColors,0.55)*255.0).TupleInt();
    hv_Saturation = (HTuple(hv_NumColors,0.95)*255.0).TupleInt();
  }
  //
  //Write colors to a 3-channel image in order to transform easier.
  GenImageConst(&ho_HLSImageH, "byte", 1, hv_NumColors);
  GenImageConst(&ho_HLSImageL, "byte", 1, hv_NumColors);
  GenImageConst(&ho_HLSImageS, "byte", 1, hv_NumColors);
  GetRegionPoints(ho_HLSImageH, &hv_Rows, &hv_Columns);
  SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
  SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
  SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
  //
  //Convert from HLS to RGB.
  TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, &ho_ImageR, &ho_ImageG, &ho_ImageB, 
      "hls");
  //
  //Get RGB-values and transform to Hex.
  GetGrayval(ho_ImageR, hv_Rows, hv_Columns, &hv_Red);
  GetGrayval(ho_ImageG, hv_Rows, hv_Columns, &hv_Green);
  GetGrayval(ho_ImageB, hv_Rows, hv_Columns, &hv_Blue);
  (*hv_Colors) = (("#"+(hv_Red.TupleString("02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
  return;
  //
}

// Chapter: Deep Learning / Model
// Short Description: Return all pixel measures from a specified list of measures. 
void get_requested_pixel_measures (HTuple hv_Measures, HTuple hv_EvaluationType, 
    HTuple *hv_PixelMeasures)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ValidMeasures, hv_M;

  //
  //This helper procedure returns for a given list of
  //requested measures all pixel measures for the specified
  //evaluation type.
  //
  (*hv_PixelMeasures) = HTuple();
  get_valid_pixel_measures(hv_EvaluationType, &hv_ValidMeasures);
  //
  {
  HTuple end_val8 = (hv_Measures.TupleLength())-1;
  HTuple step_val8 = 1;
  for (hv_M=0; hv_M.Continue(end_val8, step_val8); hv_M += step_val8)
  {
    if (0 != (int(HTuple(hv_Measures[hv_M])==HTuple("all"))))
    {
      (*hv_PixelMeasures) = (*hv_PixelMeasures).TupleConcat(hv_ValidMeasures);
    }
    else if (0 != (int((hv_ValidMeasures.TupleFind(HTuple(hv_Measures[hv_M])))!=-1)))
    {
      (*hv_PixelMeasures) = (*hv_PixelMeasures).TupleConcat(HTuple(hv_Measures[hv_M]));
    }
  }
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Returns the list of available pixel evaluation measures for the specified type. 
void get_valid_pixel_measures (HTuple hv_EvaluationType, HTuple *hv_EvaluationMeasures)
{

  // Local iconic variables

  //
  //This helper procedure returns for the given evaluation type
  //all pixel measures available for this type.
  //
  (*hv_EvaluationMeasures) = HTuple();
  if (0 != (int(hv_EvaluationType==HTuple("segmentation"))))
  {
    (*hv_EvaluationMeasures).Clear();
    (*hv_EvaluationMeasures)[0] = "pixel_accuracy";
    (*hv_EvaluationMeasures)[1] = "mean_accuracy";
    (*hv_EvaluationMeasures)[2] = "mean_iou";
    (*hv_EvaluationMeasures)[3] = "class_iou";
    (*hv_EvaluationMeasures)[4] = "class_pixel_accuracy";
    (*hv_EvaluationMeasures)[5] = "pixel_confusion_matrix";
    (*hv_EvaluationMeasures)[6] = "frequency_weighted_iou";
  }
  else if (0 != (int(hv_EvaluationType==HTuple("3d_gripping_point_detection"))))
  {
    (*hv_EvaluationMeasures).Clear();
    (*hv_EvaluationMeasures)[0] = "mean_precision";
    (*hv_EvaluationMeasures)[1] = "mean_iou";
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
void init_running_evaluation_measures (HTuple hv_EvalParams, HTuple *hv_RunningMeasures)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Valid, hv_Exception, hv_NumClasses;
  HTuple  hv_EvaluationType, hv_Measures, hv_ClassIDs, hv_PixelMeasures;
  HTuple  hv_CalcRegionMeasures, hv_CalcGrippingPointMeasures;
  HTuple  hv_InstanceType, hv_EvalOrientation, hv_AllocationBlockLength;
  HTuple  hv_IoUThreshs, hv_MaxNumDetections, hv_AreaRanges;
  HTuple  hv_AreaNames, hv_MinAreas, hv_MaxAreas, hv_DetailedEvaluation;
  HTuple  hv_MaxNumIdx, hv_MaxNum, hv_CurrentRunningMeasure;
  HTuple  hv_AreaIdx, hv_AreaRunningMeasure, hv_I, hv_IoURunningMeasure;
  HTuple  hv_ClsIdx, hv_ClassRunningMeasures, hv_Confidence;
  HTuple  hv_IgnoreClassIDs, hv_CalcConfMatrix, hv_MatrixSize;
  HTuple  hv_PixelConfusionMatrix, hv_MaxId, hv_ClsIDToClsIdx;
  HTuple  hv_TP, hv_FP, hv_FN;

  //
  //This procedure initializes the dictionary RunningMeasures for evaluation.
  //It uses the evaluation parameters to initialize the running measures accordingly.
  //
  //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
  //
  //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
  //
  CreateDict(&(*hv_RunningMeasures));
  //Check that the necessary evaluation parameters exist.
  validate_evaluation_param(hv_EvalParams, &hv_Valid, &hv_Exception);
  if (0 != (hv_Valid.TupleNot()))
  {
    throw HException(HTuple("Invalid EvalParams, ")+hv_Exception);
  }
  //
  //Get general evaluation parameters.
  GetDictTuple(hv_EvalParams, "num_classes", &hv_NumClasses);
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
  //
  if (0 != (int(hv_EvaluationType==HTuple("3d_gripping_point_detection"))))
  {
    //RunningMeasures contains:
    //if pixel measures:
    //- tp/fp/fn (pixel numbers for the gripping_map class)
    //if region measures:
    //- gt_overlap (accumulated overlap of groundtruth regions with the prediction)
    //- num_gt_regions (overall number of groundtruth regions)
    //if gripping point measures:
    //- gp_tp/gp_fp/gp_fn (gripping point true positives, false positives, and
    //  false negatives w.r.t. ground truth gripping point region).
    get_requested_pixel_measures(hv_Measures, hv_EvaluationType, &hv_PixelMeasures);
    if (0 != (int((hv_PixelMeasures.TupleLength())>0)))
    {
      SetDictTuple((*hv_RunningMeasures), "tp", 0);
      SetDictTuple((*hv_RunningMeasures), "fp", 0);
      SetDictTuple((*hv_RunningMeasures), "fn", 0);
    }
    hv_CalcRegionMeasures = HTuple(int((hv_Measures.TupleFind("mean_pro"))>-1)).TupleOr(int((hv_Measures.TupleFind("all"))>-1));
    if (0 != hv_CalcRegionMeasures)
    {
      SetDictTuple((*hv_RunningMeasures), "gt_overlap", 0);
      SetDictTuple((*hv_RunningMeasures), "num_gt_regions", 0);
    }
    hv_CalcGrippingPointMeasures = int((HTuple(hv_Measures.TupleRegexpSelect("gripping_point_.*|all")).TupleLength())>0);
    if (0 != hv_CalcGrippingPointMeasures)
    {
      SetDictTuple((*hv_RunningMeasures), "gp_tp", 0);
      SetDictTuple((*hv_RunningMeasures), "gp_fp", 0);
      SetDictTuple((*hv_RunningMeasures), "gp_fn", 0);
    }
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("anomaly_detection"))).TupleOr(int(hv_EvaluationType==HTuple("gc_anomaly_detection")))))
  {
    //RunningMeasures contains:
    //- image_ids:          IDs of the images.
    //- anomaly_label_ids:  Class IDs of ground truth labels.
    //- anomaly_scores:     Predicted image level anomaly scores.
    SetDictTuple((*hv_RunningMeasures), "image_ids", HTuple());
    SetDictTuple((*hv_RunningMeasures), "anomaly_label_ids", HTuple());
    SetDictTuple((*hv_RunningMeasures), "anomaly_scores", HTuple());
  }
  else if (0 != (int(hv_EvaluationType==HTuple("classification"))))
  {
    //RunningMeasures contains:
    //- image_ids:          IDs of the images.
    //- image_label_ids:    Class IDs of ground truth labels.
    //- top1_predictions:   Class IDs of the top predicted class.
    //- topk_predictions:   Class IDs of top-K predicted classes.
    SetDictTuple((*hv_RunningMeasures), "image_ids", HTuple());
    SetDictTuple((*hv_RunningMeasures), "image_label_ids", HTuple());
    SetDictTuple((*hv_RunningMeasures), "top1_predictions", HTuple());
    SetDictTuple((*hv_RunningMeasures), "topk_predictions", HTuple());
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("detection"))).TupleOr(int(hv_EvaluationType==HTuple("ocr_detection")))))
  {
    //RunningMeasures contains:
    //For each maximal number of regions (MaxNumDetections):
    // - For each area range (AreaRanges):
    //   -- confidence:     Confidence (score) of each result.
    //   -- num_gt:         Total number of ground truth instances per class.
    //   -- num_pred:       Total number of predictions per class.
    //   -- num_gt_ignore:  Number of ignored ground truth instances per class.
    //   -- for each IoU-threshold:
    //      --- For each class:
    //          ---- is_tp:                  TP/FP assignment of result.
    //          ---- ignore:                 Ignore/Not-Ignore assignment of result.
    //          ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):
    //                                       Absolute orientation difference of the result.
    //
    //Check if the orientation difference is to be evaluated.
    GetDictTuple(hv_EvalParams, "instance_type", &hv_InstanceType);
    hv_EvalOrientation = 0;
    if (0 != (HTuple(int(hv_InstanceType==HTuple("rectangle2"))).TupleAnd(HTuple(int((hv_Measures.TupleFind("soap"))!=-1)).TupleOr(int((hv_Measures.TupleFind("all"))!=-1)))))
    {
      hv_EvalOrientation = 1;
    }
    //
    //Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,
    //arrays are allocated with -1 in blocks of AllocationBlockLength
    //(thus, if a block is filled, the next block is allocated).
    //Otherwise the arrays have to be concatenated which is rather slow.
    //The actual length of the array is garnered in num_pred.
    GetDictTuple(hv_EvalParams, "allocation_block_length", &hv_AllocationBlockLength);
    GetDictTuple(hv_EvalParams, "iou_threshold", &hv_IoUThreshs);
    GetDictTuple(hv_EvalParams, "max_num_detections", &hv_MaxNumDetections);
    GetDictTuple(hv_EvalParams, "area_ranges", &hv_AreaRanges);
    //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
    GetDictTuple(hv_AreaRanges, "name", &hv_AreaNames);
    GetDictTuple(hv_AreaRanges, "min", &hv_MinAreas);
    GetDictTuple(hv_AreaRanges, "max", &hv_MaxAreas);
    //Check if a detailed evaluation will be performed.
    GetDictTuple(hv_EvalParams, "detailed_evaluation", &hv_DetailedEvaluation);
    //Set a result dictionary for each maximal number of detections and IoU-threshold.
    {
    HTuple end_val104 = (hv_MaxNumDetections.TupleLength())-1;
    HTuple step_val104 = 1;
    for (hv_MaxNumIdx=0; hv_MaxNumIdx.Continue(end_val104, step_val104); hv_MaxNumIdx += step_val104)
    {
      hv_MaxNum = HTuple(hv_MaxNumDetections[hv_MaxNumIdx]);
      CreateDict(&hv_CurrentRunningMeasure);
      {
      HTuple end_val107 = (hv_AreaNames.TupleLength())-1;
      HTuple step_val107 = 1;
      for (hv_AreaIdx=0; hv_AreaIdx.Continue(end_val107, step_val107); hv_AreaIdx += step_val107)
      {
        CreateDict(&hv_AreaRunningMeasure);
        {
        HTuple end_val109 = (hv_IoUThreshs.TupleLength())-1;
        HTuple step_val109 = 1;
        for (hv_I=0; hv_I.Continue(end_val109, step_val109); hv_I += step_val109)
        {
          CreateDict(&hv_IoURunningMeasure);
          {
          HTuple end_val111 = hv_NumClasses-1;
          HTuple step_val111 = 1;
          for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val111, step_val111); hv_ClsIdx += step_val111)
          {
            CreateDict(&hv_ClassRunningMeasures);
            SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple(hv_AllocationBlockLength,-1));
            SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple(hv_AllocationBlockLength,-1));
            if (0 != hv_EvalOrientation)
            {
              SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff", HTuple(hv_AllocationBlockLength,-1));
            }
            if (0 != hv_DetailedEvaluation)
            {
              SetDictTuple(hv_ClassRunningMeasures, "is_fp_class", HTuple(hv_AllocationBlockLength,-1));
              SetDictTuple(hv_ClassRunningMeasures, "is_fp_background", HTuple(hv_AllocationBlockLength,-1));
              SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization", HTuple(hv_AllocationBlockLength,-1));
              SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate", HTuple(hv_AllocationBlockLength,-1));
              SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple", HTuple(hv_AllocationBlockLength,-1));
              if (0 != hv_EvalOrientation)
              {
                SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_class", 
                    HTuple(hv_AllocationBlockLength,-1));
                SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_localization", 
                    HTuple(hv_AllocationBlockLength,-1));
                SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_duplicate", 
                    HTuple(hv_AllocationBlockLength,-1));
                SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_multiple", 
                    HTuple(hv_AllocationBlockLength,-1));
              }
              SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives", 
                  HTuple(hv_AllocationBlockLength,-1));
              SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives", 
                  HTuple(hv_AllocationBlockLength,-1));
              SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives", 
                  0);
              SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives", 
                  0);
            }
            SetDictTuple(hv_IoURunningMeasure, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                hv_ClassRunningMeasures);
          }
          }
          SetDictTuple(hv_AreaRunningMeasure, "iou_"+((""+HTuple(hv_IoUThreshs[hv_I])).TupleRegexpReplace("\\.","")), 
              hv_IoURunningMeasure);
        }
        }
        CreateDict(&hv_Confidence);
        {
        HTuple end_val140 = hv_NumClasses-1;
        HTuple step_val140 = 1;
        for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val140, step_val140); hv_ClsIdx += step_val140)
        {
          SetDictTuple(hv_Confidence, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), HTuple(hv_AllocationBlockLength,-1.0));
        }
        }
        SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
        SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple(hv_NumClasses,0));
        SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple(hv_NumClasses,0));
        SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple(hv_NumClasses,0));
        SetDictTuple(hv_CurrentRunningMeasure, "area_"+HTuple(hv_AreaNames[hv_AreaIdx]), 
            hv_AreaRunningMeasure);
      }
      }
      if (0 != (int(hv_MaxNum==-1)))
      {
        hv_MaxNum = "all";
      }
      SetDictTuple((*hv_RunningMeasures), "max_num_detections_"+hv_MaxNum, hv_CurrentRunningMeasure);
    }
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("segmentation"))))
  {
    //RunningMeasures contains:
    //if confusion matrix in Measures (slower but more information).
    // - confusion matrix per pixel.
    //else:
    // - TP/FP/FN (pixel numbers per class).
    //
    //Incorporate ignore class IDs.
    GetDictTuple(hv_EvalParams, "ignore_class_ids", &hv_IgnoreClassIDs);
    //
    //Check if we need to compute/update the confusion matrix.
    hv_CalcConfMatrix = HTuple(int((hv_Measures.TupleFind("pixel_confusion_matrix"))>-1)).TupleOr(int((hv_Measures.TupleFind("all"))>-1));
    if (0 != hv_CalcConfMatrix)
    {
      //Define the size of the confusion matrix.
      hv_MatrixSize = hv_NumClasses+(int((hv_IgnoreClassIDs.TupleLength())>0));
      CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, &hv_PixelConfusionMatrix);
      SetDictTuple((*hv_RunningMeasures), "pixel_confusion_matrix", hv_PixelConfusionMatrix);
      //
      //If the class IDs are not running indices from 0 to NumClasses we
      //define a mapping from class IDs to class indices.
      if (0 != (HTuple(int(hv_ClassIDs!=HTuple::TupleGenSequence(0,(hv_ClassIDs.TupleLength())-1,1))).TupleOr(int((hv_IgnoreClassIDs.TupleLength())>0))))
      {
        //Get the max ID that can occur.
        hv_MaxId = (hv_ClassIDs.TupleMax())+(int((hv_IgnoreClassIDs.TupleLength())>0));
        //Define the basic mapping.
        TupleGenConst(hv_MaxId+1, -1, &hv_ClsIDToClsIdx);
        hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple::TupleGenSequence(0,(hv_ClassIDs.TupleLength())-1,1);
        //Map ignore IDs to the next higher one.
        hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax())+1;
        //Set the mapping to the evaluation parameters.
        SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
      }
    }
    else
    {
      hv_TP = HTuple(hv_NumClasses,0);
      hv_FP = HTuple(hv_NumClasses,0);
      hv_FN = HTuple(hv_NumClasses,0);
      SetDictTuple((*hv_RunningMeasures), "tp", hv_TP);
      SetDictTuple((*hv_RunningMeasures), "fp", hv_FP);
      SetDictTuple((*hv_RunningMeasures), "fn", hv_FN);
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_recognition"))))
  {
    //RunningMeasures for OCR recognition models.
    SetDictTuple((*hv_RunningMeasures), "image_ids", HTuple());
    SetDictTuple((*hv_RunningMeasures), "words_ground_truth", HTuple());
    SetDictTuple((*hv_RunningMeasures), "words_prediction", HTuple());
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Read the dictionaries DLSamples from files. 
void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple *hv_DLSampleBatch)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DatasetSamples, hv_MinIndex, hv_MaxIndex;
  HTuple  hv_KeyDirExists, hv_DictDir, hv_DLSamplesProc, hv_ImageIndex;
  HTuple  hv_KeyFileExists, hv_ImageID, hv_FileNameRelative;
  HTuple  hv_FileNameSample, hv_FileExists, hv_DictPath, hv_DLSample;
  HTuple  hv_Exception;

  //
  //This procedure reads a batch of DLSample dictionaries from disk.
  //The wanted samples are selected from a DLDataset by their indices.
  //The indices of the wanted samples are handed over in SampleIndices.
  //It returns the tuple of read-in dictionaries in DLSampleBatch.
  //
  //Sanity checks of inputs.
  //
  if (0 != (int((hv_SampleIndices.TupleLength())<=0)))
  {
    //Check the length of selected indices.
    throw HException(HTuple("Invalid length of SelectedIndices: ")+(hv_SampleIndices.TupleLength()));
  }
  else
  {
    //Get the samples from the DLDataset.
    GetDictTuple(hv_DLDataset, "samples", &hv_DatasetSamples);
    //Get min and max value of given indices.
    TupleMin(hv_SampleIndices, &hv_MinIndex);
    TupleMax(hv_SampleIndices, &hv_MaxIndex);
    if (0 != (HTuple(int(hv_MinIndex<0)).TupleOr(int(hv_MaxIndex>((hv_DatasetSamples.TupleLength())-1)))))
    {
      //Check the value range of the provided indices.
      throw HException("The given SampleIndices are not within the range of available samples in DLDataset.");
    }
  }
  //
  //Check if the key dlsample_dir is given.
  GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", &hv_KeyDirExists);
  //
  if (0 != hv_KeyDirExists)
  {
    //
    //Get the dlsample_dir.
    GetDictTuple(hv_DLDataset, "dlsample_dir", &hv_DictDir);
    //Get the samples to be processed.
    hv_DLSamplesProc = HTuple(hv_DatasetSamples[hv_SampleIndices]);
    //
    //Initialize DLSampleBatch tuple.
    (*hv_DLSampleBatch) = HTuple();
    //
    //Read in all DLSamples into the batch.
    {
    HTuple end_val37 = (hv_SampleIndices.TupleLength())-1;
    HTuple step_val37 = 1;
    for (hv_ImageIndex=0; hv_ImageIndex.Continue(end_val37, step_val37); hv_ImageIndex += step_val37)
    {
      //Check if dlsample key exist.
      GetDictParam(HTuple(hv_DLSamplesProc[hv_ImageIndex]), "key_exists", "dlsample_file_name", 
          &hv_KeyFileExists);
      //
      if (0 != (hv_KeyFileExists.TupleNot()))
      {
        //
        //If the key does not exist, check if a corresponding file exists.
        GetDictTuple(HTuple(hv_DLSamplesProc[hv_ImageIndex]), "image_id", &hv_ImageID);
        hv_FileNameRelative = hv_ImageID+"_dlsample.hdict";
        hv_FileNameSample = (hv_DictDir+"/")+hv_FileNameRelative;
        //
        FileExists(hv_FileNameSample, &hv_FileExists);
        if (0 != hv_FileExists)
        {
          //If it exists, create corresponding key.
          SetDictTuple(HTuple(hv_DLSamplesProc[hv_ImageIndex]), "dlsample_file_name", 
              hv_FileNameRelative);
        }
        else
        {
          //If not, throw an error.
          throw HException("No 'dlsample_file_name' and hdict file available for image ID "+hv_ImageID);
        }
        //
      }
      //
      //If dlsample dictionary is available for reading, read it.
      GetDictTuple(HTuple(hv_DLSamplesProc[hv_ImageIndex]), "dlsample_file_name", 
          &hv_DictPath);
      try
      {
        ReadDict((hv_DictDir+"/")+hv_DictPath, HTuple(), HTuple(), &hv_DLSample);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException((((("An error has occurred while reading "+hv_DictDir)+"/")+hv_DictPath)+HTuple(" , HALCON error # "))+HTuple(hv_Exception[0]));
      }
      //Add it to the DLSampleBatch.
      (*hv_DLSampleBatch) = (*hv_DLSampleBatch).TupleConcat(hv_DLSample);
      //
    }
    }
  }
  else
  {
    throw HException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
  }

  return;
}

// Chapter: File / Misc
// Short Description: Remove a directory recursively. 
void remove_dir_recursively (HTuple hv_DirName)
{

  // Local control variables
  HTuple  hv_Dirs, hv_I, hv_Files;

  //Recursively delete all subdirectories.
  ListFiles(hv_DirName, "directories", &hv_Dirs);
  {
  HTuple end_val2 = (hv_Dirs.TupleLength())-1;
  HTuple step_val2 = 1;
  for (hv_I=0; hv_I.Continue(end_val2, step_val2); hv_I += step_val2)
  {
    remove_dir_recursively(HTuple(hv_Dirs[hv_I]));
  }
  }
  //Delete all files.
  ListFiles(hv_DirName, "files", &hv_Files);
  {
  HTuple end_val7 = (hv_Files.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_I=0; hv_I.Continue(end_val7, step_val7); hv_I += step_val7)
  {
    DeleteFile(HTuple(hv_Files[hv_I]));
  }
  }
  //Remove empty directory.
  RemoveDir(hv_DirName);
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_Fonts, hv_Style, hv_Exception;
  HTuple  hv_AvailableFonts, hv_Fdx, hv_Indices;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  if (0 != (HTuple(int(hv_Size==HTuple())).TupleOr(int(hv_Size==-1))))
  {
    hv_Size = 16;
  }
  if (0 != (int((hv_OS.TupleSubstr(0,2))==HTuple("Win"))))
  {
    //Restore previous behavior
    hv_Size = (1.13677*hv_Size).TupleInt();
  }
  else
  {
    hv_Size = hv_Size.TupleInt();
  }
  if (0 != (int(hv_Font==HTuple("Courier"))))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Courier";
    hv_Fonts[1] = "Courier 10 Pitch";
    hv_Fonts[2] = "Courier New";
    hv_Fonts[3] = "CourierNew";
    hv_Fonts[4] = "Liberation Mono";
  }
  else if (0 != (int(hv_Font==HTuple("mono"))))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Consolas";
    hv_Fonts[1] = "Menlo";
    hv_Fonts[2] = "Courier";
    hv_Fonts[3] = "Courier 10 Pitch";
    hv_Fonts[4] = "FreeMono";
    hv_Fonts[5] = "Liberation Mono";
  }
  else if (0 != (int(hv_Font==HTuple("sans"))))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Luxi Sans";
    hv_Fonts[1] = "DejaVu Sans";
    hv_Fonts[2] = "FreeSans";
    hv_Fonts[3] = "Arial";
    hv_Fonts[4] = "Liberation Sans";
  }
  else if (0 != (int(hv_Font==HTuple("serif"))))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Times New Roman";
    hv_Fonts[1] = "Luxi Serif";
    hv_Fonts[2] = "DejaVu Serif";
    hv_Fonts[3] = "FreeSerif";
    hv_Fonts[4] = "Utopia";
    hv_Fonts[5] = "Liberation Serif";
  }
  else
  {
    hv_Fonts = hv_Font;
  }
  hv_Style = "";
  if (0 != (int(hv_Bold==HTuple("true"))))
  {
    hv_Style += HTuple("Bold");
  }
  else if (0 != (int(hv_Bold!=HTuple("false"))))
  {
    hv_Exception = "Wrong value of control parameter Bold";
    throw HException(hv_Exception);
  }
  if (0 != (int(hv_Slant==HTuple("true"))))
  {
    hv_Style += HTuple("Italic");
  }
  else if (0 != (int(hv_Slant!=HTuple("false"))))
  {
    hv_Exception = "Wrong value of control parameter Slant";
    throw HException(hv_Exception);
  }
  if (0 != (int(hv_Style==HTuple(""))))
  {
    hv_Style = "Normal";
  }
  QueryFont(hv_WindowHandle, &hv_AvailableFonts);
  hv_Font = "";
  {
  HTuple end_val48 = (hv_Fonts.TupleLength())-1;
  HTuple step_val48 = 1;
  for (hv_Fdx=0; hv_Fdx.Continue(end_val48, step_val48); hv_Fdx += step_val48)
  {
    hv_Indices = hv_AvailableFonts.TupleFind(HTuple(hv_Fonts[hv_Fdx]));
    if (0 != (int((hv_Indices.TupleLength())>0)))
    {
      if (0 != (int(HTuple(hv_Indices[0])>=0)))
      {
        hv_Font = HTuple(hv_Fonts[hv_Fdx]);
        break;
      }
    }
  }
  }
  if (0 != (int(hv_Font==HTuple(""))))
  {
    throw HException("Wrong value of control parameter Font");
  }
  hv_Font = (((hv_Font+"-")+hv_Style)+"-")+hv_Size;
  SetFont(hv_WindowHandle, hv_Font);
  return;
}

// Chapter: System / Operating System
// Short Description: Create a formatted string of a time span. 
void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, HTuple *hv_TimeString)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Seconds, hv_TotalMinutes, hv_Minutes;
  HTuple  hv_TotalHours, hv_Hours, hv_Days;

  //
  //This procedure creates a readable representation of a time span
  //given the elapsed time in seconds.
  //
  //Ensure that the input is an integer.
  hv_TotalSeconds = hv_TotalSeconds.TupleInt();
  //
  hv_Seconds = hv_TotalSeconds%60;
  //
  hv_TotalMinutes = hv_TotalSeconds/60;
  hv_Minutes = hv_TotalMinutes%60;
  //
  hv_TotalHours = hv_TotalSeconds/3600;
  hv_Hours = hv_TotalHours%24;
  //
  hv_Days = hv_TotalSeconds/86400;
  //
  if (0 != (int(hv_Format==HTuple("auto"))))
  {
    //Print the highest non-zero unit and all remaining sub-units.
    if (0 != (int(hv_Days>0)))
    {
      (*hv_TimeString) = (((((((hv_Days.TupleString("d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else if (0 != (int(hv_Hours>0)))
    {
      (*hv_TimeString) = (((((hv_Hours.TupleString("d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else if (0 != (int(hv_Minutes>0)))
    {
      (*hv_TimeString) = (((hv_Minutes.TupleString("d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else
    {
      (*hv_TimeString) = (hv_Seconds.TupleString("d"))+"s";
    }
  }
  else if (0 != (int(hv_Format==HTuple("top1"))))
  {
    //Print the highest non-zero unit.
    if (0 != (int(hv_Days>0)))
    {
      (*hv_TimeString) = (hv_Days.TupleString("d"))+"d";
    }
    else if (0 != (int(hv_Hours>0)))
    {
      (*hv_TimeString) = (hv_Hours.TupleString("d"))+"h";
    }
    else if (0 != (int(hv_Minutes>0)))
    {
      (*hv_TimeString) = (hv_Minutes.TupleString("d"))+"m";
    }
    else
    {
      (*hv_TimeString) = (hv_Seconds.TupleString("d"))+"s";
    }
  }
  else if (0 != (int(hv_Format==HTuple("top2"))))
  {
    //Print the highest non-zero unit and the following sub-unit.
    if (0 != (int(hv_Days>0)))
    {
      (*hv_TimeString) = (((hv_Days.TupleString("d"))+"d ")+(hv_Hours.TupleString("d")))+"h";
    }
    else if (0 != (int(hv_Hours>0)))
    {
      (*hv_TimeString) = (((hv_Hours.TupleString("d"))+"h ")+(hv_Minutes.TupleString("d")))+"m";
    }
    else if (0 != (int(hv_Minutes>0)))
    {
      (*hv_TimeString) = (((hv_Minutes.TupleString("d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else
    {
      (*hv_TimeString) = (hv_Seconds.TupleString("d"))+"s";
    }
  }
  else if (0 != (int(hv_Format==HTuple("dhms"))))
  {
    //Print a Days-Hours-Minutes-Seconds string.
    (*hv_TimeString) = (((((((hv_Days.TupleString("d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
  }
  else if (0 != (int(hv_Format==HTuple("hms"))))
  {
    //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
    (*hv_TimeString) = (((((hv_TotalHours.TupleString("d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
  }
  else
  {
    throw HException("Unknown format string.");
  }
  //
  return;
}

// Chapter: Tuple / Element Order
// Short Description: Sort the elements of a tuple randomly. 
void tuple_shuffle (HTuple hv_Tuple, HTuple *hv_Shuffled)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ShuffleIndices;

  //This procedure sorts the input tuple randomly.
  //
  if (0 != (int((hv_Tuple.TupleLength())>0)))
  {
    //Create a tuple of random numbers,
    //sort this tuple, and return the indices
    //of this sorted tuple.
    hv_ShuffleIndices = HTuple::TupleRand(hv_Tuple.TupleLength()).TupleSortIndex();
    //Assign the elements of Tuple
    //to these random positions.
    (*hv_Shuffled) = HTuple(hv_Tuple[hv_ShuffleIndices]);
  }
  else
  {
    //If the input tuple is empty,
    //an empty tuple should be returned.
    (*hv_Shuffled) = HTuple();
  }
  return;
}

// Chapter: Tuple / Arithmetic
// Short Description: Calculate the cross product of two vectors of length 3. 
void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC)
{

  // Local iconic variables

  //The caller must ensure that the length of both input vectors is 3
  (*hv_VC) = (HTuple(hv_V1[1])*HTuple(hv_V2[2]))-(HTuple(hv_V1[2])*HTuple(hv_V2[1]));
  (*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[2])*HTuple(hv_V2[0]))-(HTuple(hv_V1[0])*HTuple(hv_V2[2])));
  (*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[0])*HTuple(hv_V2[1]))-(HTuple(hv_V1[1])*HTuple(hv_V2[0])));
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
void update_running_evaluation_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures)
{

  // Local control variables
  HTuple  hv_EvaluationType;

  //
  //This procedure updates the running measures depending on the evaluation type.
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
  if (0 != (HTuple(int(hv_EvaluationType==HTuple("anomaly_detection"))).TupleOr(int(hv_EvaluationType==HTuple("gc_anomaly_detection")))))
  {
    update_running_image_anomaly_measures(hv_Samples, hv_Results, hv_EvalParams, 
        hv_RunningMeasures);
  }
  else if (0 != (int(hv_EvaluationType==HTuple("classification"))))
  {
    update_running_image_classification_measures(hv_Samples, hv_Results, hv_EvalParams, 
        hv_RunningMeasures);
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("detection"))).TupleOr(int(hv_EvaluationType==HTuple("ocr_detection")))))
  {
    update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("segmentation"))).TupleOr(int(hv_EvaluationType==HTuple("3d_gripping_point_detection")))))
  {
    update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
    if (0 != (int(hv_EvaluationType==HTuple("3d_gripping_point_detection"))))
    {
      update_running_region_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
      update_running_gripping_point_measures(hv_Samples, hv_Results, hv_EvalParams, 
          hv_RunningMeasures);
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_recognition"))))
  {
    update_running_ocr_recognition_measures(hv_Samples, hv_Results, hv_EvalParams, 
        hv_RunningMeasures);
  }
  //
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Update running measures for 3D gripping points. 
void update_running_gripping_point_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures)
{

  // Local iconic variables
  HObject  ho_AnnotationRegion, ho_GTRegions, ho_GTRegion;

  // Local control variables
  HTuple  hv_Index, hv_Sample, hv_Result, hv_NumGTRegions;
  HTuple  hv_GrippingPointFound, hv_IndexGTRegions, hv_TP;
  HTuple  hv_FP, hv_IndexGrippingPoint, hv_GrippingPoint;
  HTuple  hv_GPFound, hv_NumGrippingPointFound;

  if (0 != (int((HTuple((hv_EvalParams.TupleGetDictTuple("measures")).TupleRegexpSelect("gripping_point_.*|all")).TupleLength())>0)))
  {
    {
    HTuple end_val1 = (hv_Samples.TupleLength())-1;
    HTuple step_val1 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
    {
      hv_Sample = HTuple(hv_Samples[hv_Index]);
      hv_Result = HTuple(hv_Results[hv_Index]);
      gen_dl_3d_gripping_points_and_poses(hv_Sample, hv_EvalParams.TupleGetDictTuple("gripping_point_params"), 
          hv_Result);
      Threshold(hv_Sample.TupleGetDictObject("segmentation_image"), &ho_AnnotationRegion, 
          HTuple((hv_EvalParams.TupleGetDictTuple("class_ids"))[0]), HTuple((hv_EvalParams.TupleGetDictTuple("class_ids"))[0]));
      Connection(ho_AnnotationRegion, &ho_GTRegions);
      CountObj(ho_GTRegions, &hv_NumGTRegions);
      //True positives: Only one gripping point
      //within a ground truth region is counted
      //as true positive. All additional points
      //witin the same ground truth region are
      //considered a false positive.
      //False negative: All ground truth regions
      //that do not contain at least one
      //gripping point are a false negative.
      hv_GrippingPointFound = HTuple((hv_Result.TupleGetDictTuple("gripping_points")).TupleLength(),0);
      {
      HTuple end_val17 = hv_NumGTRegions;
      HTuple step_val17 = 1;
      for (hv_IndexGTRegions=1; hv_IndexGTRegions.Continue(end_val17, step_val17); hv_IndexGTRegions += step_val17)
      {
        SelectObj(ho_GTRegions, &ho_GTRegion, hv_IndexGTRegions);
        hv_TP = 0.0;
        hv_FP = 0.0;
        {
        HTuple end_val21 = ((hv_Result.TupleGetDictTuple("gripping_points")).TupleLength())-1;
        HTuple step_val21 = 1;
        for (hv_IndexGrippingPoint=0; hv_IndexGrippingPoint.Continue(end_val21, step_val21); hv_IndexGrippingPoint += step_val21)
        {
          hv_GrippingPoint = HTuple((hv_Result.TupleGetDictTuple("gripping_points"))[hv_IndexGrippingPoint]);
          TestRegionPoint(ho_GTRegion, hv_GrippingPoint.TupleGetDictTuple("row"), 
              hv_GrippingPoint.TupleGetDictTuple("column"), &hv_GPFound);
          if (0 != hv_GPFound)
          {
            if (0 != (int(hv_TP==0.0)))
            {
              hv_TP += 1.0;
            }
            else
            {
              hv_FP += 1.0;
            }
            hv_GrippingPointFound[hv_IndexGrippingPoint] = 1;
          }
        }
        }
        SetDictTuple(hv_RunningMeasures, "gp_tp", (hv_RunningMeasures.TupleGetDictTuple("gp_tp"))+hv_TP);
        SetDictTuple(hv_RunningMeasures, "gp_fp", (hv_RunningMeasures.TupleGetDictTuple("gp_fp"))+hv_FP);
        if (0 != (int(hv_TP==0.0)))
        {
          SetDictTuple(hv_RunningMeasures, "gp_fn", (hv_RunningMeasures.TupleGetDictTuple("gp_fn"))+1.0);
        }
      }
      }
      //All gripping points that have not been
      //found to lie within the ground truth
      //region are additional false positives.
      if (0 != (int((hv_GrippingPointFound.TupleLength())>0)))
      {
        hv_NumGrippingPointFound = hv_GrippingPointFound.TupleSum();
      }
      else
      {
        hv_NumGrippingPointFound = 0;
      }
      SetDictTuple(hv_RunningMeasures, "gp_fp", (hv_RunningMeasures.TupleGetDictTuple("gp_fp"))+((hv_GrippingPointFound.TupleLength())-hv_NumGrippingPointFound));
    }
    }
  }
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Update running measures for an anomaly detection or Global Context Anomaly Detection evaluation. 
void update_running_image_anomaly_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ImageIDs, hv_AnomalyLabelIDs, hv_AnomalyScores;
  HTuple  hv_SampleIndex, hv_Sample, hv_ImageID, hv_AnomalyLabelID;
  HTuple  hv_Result, hv_Keys, hv_AnomalyScoreKey, hv_AnomalyScore;

  //
  //This procedure updates the RunningMeasures for an evaluation for anomaly detection.
  //
  //These measures are stored in the dictionary RunningMeasures and
  //updated by incorporating the Results the model obtained for the Samples.
  //
  //
  //Get image ids.
  GetDictTuple(hv_RunningMeasures, "image_ids", &hv_ImageIDs);
  //Get anomaly label ids.
  GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", &hv_AnomalyLabelIDs);
  //Get anomaly scores.
  GetDictTuple(hv_RunningMeasures, "anomaly_scores", &hv_AnomalyScores);
  //Loop over all samples and update running measures accordingly.
  {
  HTuple end_val14 = (hv_Samples.TupleLength())-1;
  HTuple step_val14 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val14, step_val14); hv_SampleIndex += step_val14)
  {
    hv_Sample = HTuple(hv_Samples[hv_SampleIndex]);
    GetDictTuple(hv_Sample, "image_id", &hv_ImageID);
    GetDictTuple(hv_Sample, "anomaly_label_id", &hv_AnomalyLabelID);
    hv_Result = HTuple(hv_Results[hv_SampleIndex]);
    GetDictParam(hv_Result, "keys", HTuple(), &hv_Keys);
    TupleRegexpSelect(hv_Keys, "anomaly_score.*", &hv_AnomalyScoreKey);
    //It is not expected that AnomalyScoreKey contains more than one item.
    //In case it unexpectedly does, we index it with [0].
    GetDictTuple(hv_Result, HTuple(hv_AnomalyScoreKey[0]), &hv_AnomalyScore);
    //
    hv_ImageIDs = hv_ImageIDs.TupleConcat(hv_ImageID);
    hv_AnomalyLabelIDs = hv_AnomalyLabelIDs.TupleConcat(hv_AnomalyLabelID);
    hv_AnomalyScores = hv_AnomalyScores.TupleConcat(hv_AnomalyScore);
  }
  }
  //
  //Set image ids in running measures.
  SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
  //Set anomaly label ids in running measures.
  SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", hv_AnomalyLabelIDs);
  //Set anomaly scores in running measures.
  SetDictTuple(hv_RunningMeasures, "anomaly_scores", hv_AnomalyScores);
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Update running measures for an image classification evaluation. 
void update_running_image_classification_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_RegExpTopKError, hv_Measures, hv_K;
  HTuple  hv_M, hv_ComputeTopKError, hv_ImageIDs, hv_ImageLabelIDs;
  HTuple  hv_Top1Prediction, hv_TopKPredictionDicts, hv_Index;
  HTuple  hv_Sample, hv_ImageID, hv_ImageLabelID, hv_Result;
  HTuple  hv_PredictedClassIDs, hv_TopKPrediction, hv_TopKPredictionDict;

  //
  //This procedure updates the RunningMeasures for an evaluation for classification.
  //
  //To avoid memory, only save first K predictions per sample.
  hv_RegExpTopKError = "top([0-9]+)_error";
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  hv_K = 1;
  {
  HTuple end_val7 = (hv_Measures.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_M=0; hv_M.Continue(end_val7, step_val7); hv_M += step_val7)
  {
    hv_ComputeTopKError = HTuple(hv_Measures[hv_M]).TupleRegexpTest(hv_RegExpTopKError);
    if (0 != hv_ComputeTopKError)
    {
      hv_K = hv_K.TupleMax2((HTuple(hv_Measures[hv_M]).TupleRegexpMatch(hv_RegExpTopKError)).TupleNumber());
    }
  }
  }
  //
  //Extend tuples in RunningMeasures with new results.
  GetDictTuple(hv_RunningMeasures, "image_ids", &hv_ImageIDs);
  GetDictTuple(hv_RunningMeasures, "image_label_ids", &hv_ImageLabelIDs);
  GetDictTuple(hv_RunningMeasures, "top1_predictions", &hv_Top1Prediction);
  GetDictTuple(hv_RunningMeasures, "topk_predictions", &hv_TopKPredictionDicts);
  {
  HTuple end_val19 = (hv_Samples.TupleLength())-1;
  HTuple step_val19 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val19, step_val19); hv_Index += step_val19)
  {
    hv_Sample = HTuple(hv_Samples[hv_Index]);
    GetDictTuple(hv_Sample, "image_id", &hv_ImageID);
    GetDictTuple(hv_Sample, "image_label_id", &hv_ImageLabelID);
    hv_Result = HTuple(hv_Results[hv_Index]);
    GetDictTuple(hv_Result, "classification_class_ids", &hv_PredictedClassIDs);
    hv_TopKPrediction = hv_PredictedClassIDs.TupleSelectRange(0,hv_K-1);
    CreateDict(&hv_TopKPredictionDict);
    SetDictTuple(hv_TopKPredictionDict, "predictions", hv_TopKPrediction);
    //
    hv_ImageIDs = hv_ImageIDs.TupleConcat(hv_ImageID);
    hv_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(hv_ImageLabelID);
    hv_Top1Prediction = hv_Top1Prediction.TupleConcat(HTuple(hv_TopKPrediction[0]));
    hv_TopKPredictionDicts = hv_TopKPredictionDicts.TupleConcat(hv_TopKPredictionDict);
  }
  }
  //
  SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
  SetDictTuple(hv_RunningMeasures, "image_label_ids", hv_ImageLabelIDs);
  SetDictTuple(hv_RunningMeasures, "top1_predictions", hv_Top1Prediction);
  SetDictTuple(hv_RunningMeasures, "topk_predictions", hv_TopKPredictionDicts);
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Update running measures for an instance-based evaluation. 
void update_running_instance_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MaxNumDetections, hv_AreaRanges, hv_IoUThresholds;
  HTuple  hv_InstanceType, hv_ClassIDs, hv_NumClasses, hv_Measures;
  HTuple  hv_AreaNames, hv_MinAreas, hv_MaxAreas, hv_NumAreaRanges;
  HTuple  hv_AllocationBlockLength, hv_DetailedEvaluation;
  HTuple  hv_KeyExists, hv_ClassIDToClassIdx, hv_EvaluateOrientation;
  HTuple  hv_SIdx, hv_CurrentSample, hv_CurrentResult, hv_GtClassIDs;
  HTuple  hv_ResClassIDs, hv_NumGT, hv_NumRes, hv_Confidences;
  HTuple  hv_ResSortIndices, hv_GtAreas, hv_ResAreas, hv_IoUs;
  HTuple  hv_GtPhis, hv_ResPhis, hv_MDIdx, hv_MaxNum, hv_MaxNumStr;
  HTuple  hv_CurrentRunningMeasures, hv_AreaIdx, hv_MinArea;
  HTuple  hv_MaxArea, hv_AreaName, hv_AreaRunningMeasures;
  HTuple  hv_GtIgnore, hv_GtIgnoreInds, hv_PerClassNumGt;
  HTuple  hv_PerClassNumPred, hv_PerClassConfidences, hv_PerClassNumGtIgnore;
  HTuple  hv_SampleHasFP, hv_SampleHasFN, hv_ClsIdx, hv_CurrentClassID;
  HTuple  hv_CurrentGtIdxs, hv_CurrentNumGt, hv_CurrentGtIgnore;
  HTuple  hv_CurrentNumGtIgnore, hv_CurrentNumGtNoIgnore;
  HTuple  hv_CurrentResIdxs, hv_CurrentNumRes, hv_CurrentResAreas;
  HTuple  hv_OldNumPred, hv_CurrentClassConfidences, hv_GtSortIdx;
  HTuple  hv_CurrentResPhis, hv_CurrentGtPhis, hv_ITIdx, hv_GtMatched;
  HTuple  hv_ResMatched, hv_ResAbsOrientationDiff, hv_ResIgnore;
  HTuple  hv_ResIdx, hv_CurrentIoU, hv_MatchIdx, hv_GtIdx;
  HTuple  hv_AreaIgnore, hv_PerIoUMeasure, hv_PerClassMeasures;
  HTuple  hv_CurrentIsTP, hv_CurrentIgnore, hv_CurrentAbsOrientationDiff;
  HTuple  hv_GtMatchedNoIgnore, hv_ResIsFPClass, hv_ResIsFPBackground;
  HTuple  hv_ResIsFPLocalization, hv_ResIsFPDuplicate, hv_ResIsFPMultiple;
  HTuple  hv_ResAbsOrientationDiffClass, hv_ResAbsOrientationDiffLocalization;
  HTuple  hv_ResAbsOrientationDiffDuplicate, hv_ResAbsOrientationDiffMultiple;
  HTuple  hv_FPResIdxsThisClass, hv_FPResIdxsAllResults, hv_GTIdxsNotToIgnore;
  HTuple  hv_MaxIoU, hv_IoUsWithGT, hv_MaxIdx, hv_GTClassIDMaxIoU;
  HTuple  hv_AbsOrientationDiff, hv_IsFPClass, hv_IsFPBackground;
  HTuple  hv_IsFPLocalization, hv_IsFPDuplicate, hv_IsFPMultiple;
  HTuple  hv_AbsOrientationDiffMultiple, hv_AbsOrientationDiffDuplicate;
  HTuple  hv_AbsOrientationDiffLocalization, hv_AbsOrientationDiffClass;
  HTuple  hv_CurrentImageID, hv_ImageIDsWithFN, hv_NumImageIDsWithFN;
  HTuple  hv_ImageIDsWithFP, hv_NumImageIDsWithFP, hv___Tmp_Ctrl_Dict_Init_0;
  HTuple  hv___Tmp_Ctrl_Dict_Init_1;

  //
  //This procedure updates the RunningMeasures
  //for an instance-based evaluation for detection.
  //These measures are stored in the dictionary RunningMeasures and
  //updated by incorporating the Results the model obtained for the Samples.
  //
  dev_update_off();
  //Get the necessary evaluation parameters.
  GetDictTuple(hv_EvalParams, "max_num_detections", &hv_MaxNumDetections);
  GetDictTuple(hv_EvalParams, "area_ranges", &hv_AreaRanges);
  GetDictTuple(hv_EvalParams, "iou_threshold", &hv_IoUThresholds);
  GetDictTuple(hv_EvalParams, "instance_type", &hv_InstanceType);
  GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
  GetDictTuple(hv_EvalParams, "num_classes", &hv_NumClasses);
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  //
  //Get the area parameters: name, min, and max.
  GetDictTuple(hv_AreaRanges, "name", &hv_AreaNames);
  GetDictTuple(hv_AreaRanges, "min", &hv_MinAreas);
  GetDictTuple(hv_AreaRanges, "max", &hv_MaxAreas);
  hv_NumAreaRanges = (hv_AreaNames.TupleLength())-1;
  //
  //Get the allocation length for extending tuples.
  GetDictTuple(hv_EvalParams, "allocation_block_length", &hv_AllocationBlockLength);
  //
  //Check if a detailed evaluation should be done.
  hv_DetailedEvaluation = 0;
  GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation", &hv_KeyExists);
  if (0 != (HTuple(hv_KeyExists[0])))
  {
    GetDictTuple(hv_EvalParams, "detailed_evaluation", &hv_DetailedEvaluation);
  }
  if (0 != hv_DetailedEvaluation)
  {
    //We need a mapping from class IDs to class indices
    hv_ClassIDToClassIdx = HTuple((hv_ClassIDs.TupleMax())+1,-1);
    hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple::TupleGenSequence(0,hv_NumClasses-1,1);
  }
  //
  //Check if the orientation is to be evaluated.
  hv_EvaluateOrientation = 0;
  if (0 != (HTuple(int(hv_InstanceType==HTuple("rectangle2"))).TupleAnd(HTuple(int((hv_Measures.TupleFind("soap"))!=-1)).TupleOr(int((hv_Measures.TupleFind("all"))!=-1)))))
  {
    hv_EvaluateOrientation = 1;
  }
  //
  //Go through samples.
  {
  HTuple end_val44 = (hv_Samples.TupleLength())-1;
  HTuple step_val44 = 1;
  for (hv_SIdx=0; hv_SIdx.Continue(end_val44, step_val44); hv_SIdx += step_val44)
  {
    //
    hv_CurrentSample = HTuple(hv_Samples[hv_SIdx]);
    hv_CurrentResult = HTuple(hv_Results[hv_SIdx]);
    //
    //Get classes.
    GetDictTuple(hv_CurrentSample, "bbox_label_id", &hv_GtClassIDs);
    //Convert results from Deep OCR format to rectangle2 Object Detection format.
    CreateDict(&hv___Tmp_Ctrl_Dict_Init_0);
    SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "ocr_detection");
    if (0 != ((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0)).TupleTestEqualDictItem("evaluation_type","comp")))
    {
      convert_ocr_detection_result_to_object_detection(hv_CurrentResult, &hv_CurrentResult);
    }
    hv___Tmp_Ctrl_Dict_Init_0 = HTuple::TupleConstant("HNULL");
    GetDictTuple(hv_CurrentResult, "bbox_class_id", &hv_ResClassIDs);
    hv_NumGT = hv_GtClassIDs.TupleLength();
    hv_NumRes = hv_ResClassIDs.TupleLength();
    //
    //Get result confidences and sort them in descending order.
    GetDictTuple(hv_CurrentResult, "bbox_confidence", &hv_Confidences);
    hv_ResSortIndices = (-hv_Confidences).TupleSortIndex();
    hv_Confidences = HTuple(hv_Confidences[hv_ResSortIndices]);
    //Sort the result class IDs.
    hv_ResClassIDs = HTuple(hv_ResClassIDs[hv_ResSortIndices]);
    //
    //Compute the IoUs of the instances.
    area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices, 
        &hv_GtAreas, &hv_ResAreas, &hv_IoUs);
    //
    if (0 != hv_EvaluateOrientation)
    {
      GetDictTuple(hv_CurrentSample, "bbox_phi", &hv_GtPhis);
      GetDictTuple(hv_CurrentResult, "bbox_phi", &hv_ResPhis);
      hv_ResPhis = HTuple(hv_ResPhis[hv_ResSortIndices]);
    }
    //Loop over the maximal number of detections.
    {
    HTuple end_val78 = (hv_MaxNumDetections.TupleLength())-1;
    HTuple step_val78 = 1;
    for (hv_MDIdx=0; hv_MDIdx.Continue(end_val78, step_val78); hv_MDIdx += step_val78)
    {
      hv_MaxNum = HTuple(hv_MaxNumDetections[hv_MDIdx]);
      hv_MaxNumStr = ""+hv_MaxNum;
      if (0 != (int(hv_MaxNum==-1)))
      {
        hv_MaxNumStr = "all";
      }
      GetDictTuple(hv_RunningMeasures, "max_num_detections_"+hv_MaxNumStr, &hv_CurrentRunningMeasures);
      //
      //Loop over the area ranges.
      {
      HTuple end_val87 = (hv_AreaNames.TupleLength())-1;
      HTuple step_val87 = 1;
      for (hv_AreaIdx=0; hv_AreaIdx.Continue(end_val87, step_val87); hv_AreaIdx += step_val87)
      {
        //
        //Get information about the current area range.
        hv_MinArea = HTuple(hv_MinAreas[hv_AreaIdx]);
        hv_MaxArea = HTuple(hv_MaxAreas[hv_AreaIdx]);
        hv_AreaName = HTuple(hv_AreaNames[hv_AreaIdx]);
        //
        GetDictTuple(hv_CurrentRunningMeasures, "area_"+hv_AreaName, &hv_AreaRunningMeasures);
        //
        //Set ignore-flag for ground truth instances.
        //For Deep OCR detection, ignore classes other than 'word'
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_1);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "ocr_detection");
        if (0 != ((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1)).TupleTestEqualDictItem("evaluation_type","comp")))
        {
          hv_GtIgnore = hv_GtClassIDs.TupleNotEqualElem(0);
        }
        else
        {
          hv_GtIgnore = HTuple(hv_NumGT,0);
        }
        hv___Tmp_Ctrl_Dict_Init_1 = HTuple::TupleConstant("HNULL");
        //
        //Ignore ground truth instances with area outside the area range.
        if (0 != (int(hv_NumGT>0)))
        {
          TupleFind((hv_GtAreas.TupleLessElem(hv_MinArea)).TupleOr(hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 
              1, &hv_GtIgnoreInds);
          if (0 != (int(hv_GtIgnoreInds>-1)))
          {
            hv_GtIgnore[hv_GtIgnoreInds] = 1;
          }
        }
        //
        GetDictTuple(hv_AreaRunningMeasures, "num_gt", &hv_PerClassNumGt);
        GetDictTuple(hv_AreaRunningMeasures, "num_pred", &hv_PerClassNumPred);
        GetDictTuple(hv_AreaRunningMeasures, "confidence", &hv_PerClassConfidences);
        GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", &hv_PerClassNumGtIgnore);
        //
        if (0 != hv_DetailedEvaluation)
        {
          //Store if a sample has at least one false positive or false negative (for each IoU threshold).
          hv_SampleHasFP = HTuple(hv_IoUThresholds.TupleLength(),0);
          hv_SampleHasFN = HTuple(hv_IoUThresholds.TupleLength(),0);
        }
        //
        //Loop over the classes.
        {
        HTuple end_val127 = hv_NumClasses-1;
        HTuple step_val127 = 1;
        for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val127, step_val127); hv_ClsIdx += step_val127)
        {
          hv_CurrentClassID = HTuple(hv_ClassIDs[hv_ClsIdx]);
          //
          //Get the ground truth for this class.
          hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(hv_CurrentClassID);
          if (0 != (int(hv_CurrentGtIdxs==-1)))
          {
            hv_CurrentGtIdxs = HTuple();
          }
          hv_CurrentNumGt = hv_CurrentGtIdxs.TupleLength();
          //
          //Get ground truth ignore for this class.
          hv_CurrentGtIgnore = HTuple(hv_GtIgnore[hv_CurrentGtIdxs]);
          if (0 != (int((hv_CurrentGtIgnore.TupleLength())==0)))
          {
            hv_CurrentNumGtIgnore = 0;
          }
          else
          {
            hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum();
          }
          //
          //Number of gt for this class and without ignore.
          hv_CurrentNumGtNoIgnore = hv_CurrentNumGt-hv_CurrentNumGtIgnore;
          //
          //Get results for this class.
          hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(hv_CurrentClassID);
          if (0 != (int(hv_CurrentResIdxs==-1)))
          {
            hv_CurrentResIdxs = HTuple();
          }
          hv_CurrentNumRes = hv_MaxNum.TupleMin2(hv_CurrentResIdxs.TupleLength());
          //MaxNum -1 corresponds to taking all results.
          if (0 != (int(hv_MaxNum==-1)))
          {
            hv_CurrentNumRes = hv_CurrentResIdxs.TupleLength();
          }
          hv_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(0,hv_CurrentNumRes-1);
          //
          //Get areas of the current results.
          hv_CurrentResAreas = HTuple(hv_ResAreas[hv_CurrentResIdxs]);
          //
          //Update the confidences, num_gt and num_pred for this class.
          hv_OldNumPred = HTuple(hv_PerClassNumPred[hv_ClsIdx]);
          hv_PerClassNumGt[hv_ClsIdx] = HTuple(hv_PerClassNumGt[hv_ClsIdx])+hv_CurrentNumGt;
          hv_PerClassNumGtIgnore[hv_ClsIdx] = HTuple(hv_PerClassNumGtIgnore[hv_ClsIdx])+hv_CurrentNumGtIgnore;
          hv_PerClassNumPred[hv_ClsIdx] = HTuple(hv_PerClassNumPred[hv_ClsIdx])+hv_CurrentNumRes;
          GetDictTuple(hv_PerClassConfidences, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
              &hv_CurrentClassConfidences);
          //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
          //if the allocated block is long enough, otherwise allocate a new block.
          if (0 != (int(HTuple(hv_PerClassNumPred[hv_ClsIdx])>(hv_CurrentClassConfidences.TupleLength()))))
          {
            hv_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
          }
          hv_CurrentClassConfidences[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = HTuple(hv_Confidences[hv_CurrentResIdxs]);
          SetDictTuple(hv_PerClassConfidences, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
              hv_CurrentClassConfidences);
          //
          //Sort the ground truth: Non-ignored instances first.
          hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex();
          hv_CurrentGtIgnore = HTuple(hv_CurrentGtIgnore[hv_GtSortIdx]);
          hv_CurrentGtIdxs = HTuple(hv_CurrentGtIdxs[hv_GtSortIdx]);
          //
          //Get orientations of result and ground truth instances.
          if (0 != hv_EvaluateOrientation)
          {
            hv_CurrentResPhis = HTuple(hv_ResPhis[hv_CurrentResIdxs]);
            hv_CurrentGtPhis = HTuple(hv_GtPhis[hv_CurrentGtIdxs]);
          }
          //
          if (0 != (int(hv_CurrentNumRes>0)))
          {
            //Loop over IoU thresholds.
            {
            HTuple end_val190 = (hv_IoUThresholds.TupleLength())-1;
            HTuple step_val190 = 1;
            for (hv_ITIdx=0; hv_ITIdx.Continue(end_val190, step_val190); hv_ITIdx += step_val190)
            {
              //We check which ground truth and
              //result instance can be matched.
              hv_GtMatched = HTuple(hv_CurrentNumGt,0);
              hv_ResMatched = HTuple(hv_CurrentNumRes,0);
              //
              if (0 != hv_EvaluateOrientation)
              {
                //Initialize the absolute orientation difference to -1.
                hv_ResAbsOrientationDiff = HTuple(hv_CurrentNumRes,-1);
              }
              //Store which detections should be ignored.
              hv_ResIgnore = HTuple(hv_CurrentNumRes,0);
              {
              HTuple end_val202 = hv_CurrentNumRes-1;
              HTuple step_val202 = 1;
              for (hv_ResIdx=0; hv_ResIdx.Continue(end_val202, step_val202); hv_ResIdx += step_val202)
              {
                //Set the currently best achieved IoU to the IoU threshold and
                //initialize the matching index.
                hv_CurrentIoU = HTuple(hv_IoUThresholds[hv_ITIdx]).TupleMin2(1-1.0e-10);
                hv_MatchIdx = -1;
                //Loop over ground truth.
                {
                HTuple end_val208 = hv_CurrentNumGt-1;
                HTuple step_val208 = 1;
                for (hv_GtIdx=0; hv_GtIdx.Continue(end_val208, step_val208); hv_GtIdx += step_val208)
                {
                  //Continue if this ground truth has already been matched.
                  if (0 != (HTuple(hv_GtMatched[hv_GtIdx])))
                  {
                    continue;
                  }
                  //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                  if (0 != (int(hv_MatchIdx>-1)))
                  {
                    if (0 != (HTuple(int(HTuple(hv_CurrentGtIgnore[hv_MatchIdx])==0)).TupleAnd(int(HTuple(hv_CurrentGtIgnore[hv_GtIdx])==1))))
                    {
                      break;
                    }
                  }
                  //Continue if IoU is not better than a previous match.
                  if (0 != (int(HTuple(hv_IoUs[(HTuple(hv_CurrentGtIdxs[hv_GtIdx])*hv_NumRes)+HTuple(hv_CurrentResIdxs[hv_ResIdx])])<hv_CurrentIoU)))
                  {
                    continue;
                  }
                  //We got a new best match, store it.
                  hv_CurrentIoU = HTuple(hv_IoUs[(HTuple(hv_CurrentGtIdxs[hv_GtIdx])*hv_NumRes)+HTuple(hv_CurrentResIdxs[hv_ResIdx])]);
                  hv_MatchIdx = hv_GtIdx;
                }
                }
                //If a match has been made we store it for both ground truth and result.
                if (0 != (int(hv_MatchIdx!=-1)))
                {
                  //In COCO they use the IDs of GT and Res, we just use 1
                  //to indicate the matching, but don't store which one has been matched.
                  hv_ResMatched[hv_ResIdx] = 1;
                  hv_GtMatched[hv_MatchIdx] = 1;
                  hv_ResIgnore[hv_ResIdx] = HTuple(hv_CurrentGtIgnore[hv_MatchIdx]);
                  //
                  if (0 != hv_EvaluateOrientation)
                  {
                    //Set the absolute orientation difference.
                    hv_ResAbsOrientationDiff[hv_ResIdx] = (HTuple(hv_CurrentResPhis[hv_ResIdx])-HTuple(hv_CurrentGtPhis[hv_MatchIdx])).TupleAbs();
                    if (0 != (int(HTuple(hv_ResAbsOrientationDiff[hv_ResIdx])>(HTuple(180).TupleRad()))))
                    {
                      hv_ResAbsOrientationDiff[hv_ResIdx] = (HTuple(360).TupleRad())-HTuple(hv_ResAbsOrientationDiff[hv_ResIdx]);
                    }
                  }
                }
              }
              }
              //Ignore the unmatched results that are outside of the current area range.
              hv_AreaIgnore = (hv_CurrentResAreas.TupleLessElem(hv_MinArea)).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
              hv_ResIgnore = HTuple((hv_ResMatched.TupleEqualElem(-1)).TupleAnd(hv_AreaIgnore.TupleEqualElem(1))).TupleOr(hv_ResIgnore);
              //True positives are the matched results.
              GetDictTuple(hv_AreaRunningMeasures, "iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                  &hv_PerIoUMeasure);
              GetDictTuple(hv_PerIoUMeasure, "class_"+HTuple(hv_ClassIDs[hv_ClsIdx]), 
                  &hv_PerClassMeasures);
              GetDictTuple(hv_PerClassMeasures, "is_tp", &hv_CurrentIsTP);
              //As for confidences, check if we have to allocate a new block.
              if (0 != (int(HTuple(hv_PerClassNumPred[hv_ClsIdx])>(hv_CurrentIsTP.TupleLength()))))
              {
                hv_CurrentIsTP = hv_CurrentIsTP.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
              }
              hv_CurrentIsTP[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResMatched;
              SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
              //Set the ignored results.
              GetDictTuple(hv_PerClassMeasures, "ignore", &hv_CurrentIgnore);
              if (0 != (int(HTuple(hv_PerClassNumPred[hv_ClsIdx])>(hv_CurrentIgnore.TupleLength()))))
              {
                hv_CurrentIgnore = hv_CurrentIgnore.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
              }
              hv_CurrentIgnore[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResIgnore;
              SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
              //Set the absolute orientation difference.
              if (0 != hv_EvaluateOrientation)
              {
                GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff", &hv_CurrentAbsOrientationDiff);
                if (0 != (int(HTuple(hv_PerClassNumPred[hv_ClsIdx])>(hv_CurrentAbsOrientationDiff.TupleLength()))))
                {
                  hv_CurrentAbsOrientationDiff = hv_CurrentAbsOrientationDiff.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                }
                hv_CurrentAbsOrientationDiff[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResAbsOrientationDiff;
                SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff", hv_CurrentAbsOrientationDiff);
              }
              //
              //Beginning of detailed evaluation processing (optional).
              //
              if (0 != hv_DetailedEvaluation)
              {
                //Check if there have been false negatives.
                if (0 != (int(hv_CurrentNumGtNoIgnore>0)))
                {
                  hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(hv_CurrentGtIgnore.TupleNot());
                  if (0 != (int((hv_GtMatchedNoIgnore.TupleSum())<hv_CurrentNumGtNoIgnore)))
                  {
                    hv_SampleHasFN[hv_ITIdx] = 1;
                  }
                }
                //
                //Initialize the detailed running measures.
                hv_ResIsFPClass = HTuple(hv_CurrentNumRes,-1);
                hv_ResIsFPBackground = HTuple(hv_CurrentNumRes,0);
                hv_ResIsFPLocalization = HTuple(hv_CurrentNumRes,0);
                hv_ResIsFPDuplicate = HTuple(hv_CurrentNumRes,0);
                hv_ResIsFPMultiple = HTuple(hv_CurrentNumRes,0);
                //
                //Initialize detailed running measures for orientation difference.
                if (0 != hv_EvaluateOrientation)
                {
                  hv_ResAbsOrientationDiffClass = HTuple(hv_CurrentNumRes,-1);
                  hv_ResAbsOrientationDiffLocalization = HTuple(hv_CurrentNumRes,-1);
                  hv_ResAbsOrientationDiffDuplicate = HTuple(hv_CurrentNumRes,-1);
                  hv_ResAbsOrientationDiffMultiple = HTuple(hv_CurrentNumRes,-1);
                }
                //Check if there have been false positives.
                if (0 != (int((hv_ResMatched.TupleSum())<hv_CurrentNumRes)))
                {
                  hv_SampleHasFP[hv_ITIdx] = 1;
                  //
                  //For each false positive, find out what was the reason for being false positive:
                  hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(0);
                  hv_FPResIdxsAllResults = HTuple(hv_CurrentResIdxs[hv_FPResIdxsThisClass]);
                  hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(0);
                  {
                  HTuple end_val307 = (hv_FPResIdxsThisClass.TupleLength())-1;
                  HTuple step_val307 = 1;
                  for (hv_ResIdx=0; hv_ResIdx.Continue(end_val307, step_val307); hv_ResIdx += step_val307)
                  {
                    if (0 != (HTuple(hv_ResIgnore[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])]).TupleNot()))
                    {
                      if (0 != (HTuple(int((hv_GTIdxsNotToIgnore.TupleLength())==0)).TupleOr(int(hv_GTIdxsNotToIgnore==-1))))
                      {
                        //No GT instances or all GT instances are ignored.
                        //Thus, any detection is a background detection
                        hv_MaxIoU = 0.0;
                      }
                      else
                      {
                        //We have GT instances to consider.
                        hv_IoUsWithGT = HTuple(hv_IoUs[(hv_GTIdxsNotToIgnore*hv_NumRes)+HTuple(hv_FPResIdxsAllResults[hv_ResIdx])]);
                        hv_MaxIoU = hv_IoUsWithGT.TupleMax();
                        //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                        hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(hv_MaxIoU);
                        hv_GTClassIDMaxIoU = HTuple(hv_GtClassIDs[HTuple(hv_GTIdxsNotToIgnore[hv_MaxIdx])]);
                      }
                      if (0 != (hv_EvaluateOrientation.TupleAnd(int(hv_MaxIoU>0.0))))
                      {
                        //Calculate the absolute orientation difference to the GT instance with maximal IoU.
                        hv_AbsOrientationDiff = (HTuple(hv_ResPhis[HTuple(hv_FPResIdxsAllResults[hv_ResIdx])])-HTuple(hv_GtPhis[HTuple(hv_GTIdxsNotToIgnore[hv_MaxIdx])])).TupleAbs();
                        if (0 != (int(hv_AbsOrientationDiff>(HTuple(180).TupleRad()))))
                        {
                          hv_AbsOrientationDiff = (HTuple(360).TupleRad())-hv_AbsOrientationDiff;
                        }
                      }
                      //Determine false positive type.
                      if (0 != (int(hv_MaxIoU==0.0)))
                      {
                        //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                        hv_ResIsFPBackground[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = 1;
                      }
                      else if (0 != (HTuple(int(hv_MaxIoU>=HTuple(hv_IoUThresholds[hv_ITIdx]))).TupleAnd(int(hv_CurrentClassID!=hv_GTClassIDMaxIoU))))
                      {
                        //False class.
                        //Note that this does not necessarily mean that this detection
                        //would be a true positive if the class was changed. It could still be a duplicate.
                        hv_ResIsFPClass[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = HTuple(hv_ClassIDToClassIdx[hv_GTClassIDMaxIoU]);
                        //Store the absolute orientation difference.
                        if (0 != hv_EvaluateOrientation)
                        {
                          hv_ResAbsOrientationDiffClass[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = hv_AbsOrientationDiff;
                        }
                      }
                      else if (0 != (HTuple(int(hv_MaxIoU>=HTuple(hv_IoUThresholds[hv_ITIdx]))).TupleAnd(int(hv_CurrentClassID==hv_GTClassIDMaxIoU))))
                      {
                        //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                        hv_ResIsFPDuplicate[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = 1;
                        //Store the absolute orientation difference.
                        if (0 != hv_EvaluateOrientation)
                        {
                          hv_ResAbsOrientationDiffDuplicate[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = hv_AbsOrientationDiff;
                        }
                      }
                      else if (0 != (HTuple(int(hv_MaxIoU<HTuple(hv_IoUThresholds[hv_ITIdx]))).TupleAnd(int(hv_CurrentClassID==hv_GTClassIDMaxIoU))))
                      {
                        //Bad localization. Class is correct, but the IoU is too low.
                        hv_ResIsFPLocalization[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = 1;
                        //Store the absolute orientation difference.
                        if (0 != hv_EvaluateOrientation)
                        {
                          hv_ResAbsOrientationDiffLocalization[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = hv_AbsOrientationDiff;
                        }
                      }
                      else if (0 != (HTuple(int(hv_MaxIoU<HTuple(hv_IoUThresholds[hv_ITIdx]))).TupleAnd(int(hv_CurrentClassID!=hv_GTClassIDMaxIoU))))
                      {
                        //Wrong class and bad localization.
                        hv_ResIsFPMultiple[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = 1;
                        //Store the absolute orientation difference.
                        if (0 != hv_EvaluateOrientation)
                        {
                          hv_ResAbsOrientationDiffMultiple[HTuple(hv_FPResIdxsThisClass[hv_ResIdx])] = hv_AbsOrientationDiff;
                        }
                      }
                      else
                      {
                        //This case should never occur.
                        throw HException("Fatal error during detailed evaluation.");
                      }
                    }
                  }
                  }
                }
                //
                //Overwrite the detailed running measures.
                GetDictTuple(hv_PerClassMeasures, "is_fp_class", &hv_IsFPClass);
                GetDictTuple(hv_PerClassMeasures, "is_fp_background", &hv_IsFPBackground);
                GetDictTuple(hv_PerClassMeasures, "is_fp_localization", &hv_IsFPLocalization);
                GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate", &hv_IsFPDuplicate);
                GetDictTuple(hv_PerClassMeasures, "is_fp_multiple", &hv_IsFPMultiple);
                if (0 != hv_EvaluateOrientation)
                {
                  GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple", 
                      &hv_AbsOrientationDiffMultiple);
                  GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate", 
                      &hv_AbsOrientationDiffDuplicate);
                  GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization", 
                      &hv_AbsOrientationDiffLocalization);
                  GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class", 
                      &hv_AbsOrientationDiffClass);
                }
                //Allocate new blocks if necessary (all have the same length).
                if (0 != (int(HTuple(hv_PerClassNumPred[hv_ClsIdx])>(hv_IsFPClass.TupleLength()))))
                {
                  hv_IsFPClass = hv_IsFPClass.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                  hv_IsFPBackground = hv_IsFPBackground.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                  hv_IsFPLocalization = hv_IsFPLocalization.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                  hv_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                  hv_IsFPMultiple = hv_IsFPMultiple.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                  if (0 != hv_EvaluateOrientation)
                  {
                    hv_AbsOrientationDiffMultiple = hv_AbsOrientationDiffMultiple.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                    hv_AbsOrientationDiffDuplicate = hv_AbsOrientationDiffDuplicate.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                    hv_AbsOrientationDiffLocalization = hv_AbsOrientationDiffLocalization.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                    hv_AbsOrientationDiffClass = hv_AbsOrientationDiffClass.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
                  }
                }
                hv_IsFPClass[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResIsFPClass;
                hv_IsFPBackground[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResIsFPBackground;
                hv_IsFPLocalization[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResIsFPLocalization;
                hv_IsFPDuplicate[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResIsFPDuplicate;
                hv_IsFPMultiple[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResIsFPMultiple;
                if (0 != hv_EvaluateOrientation)
                {
                  hv_AbsOrientationDiffMultiple[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResAbsOrientationDiffMultiple;
                  hv_AbsOrientationDiffDuplicate[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResAbsOrientationDiffDuplicate;
                  hv_AbsOrientationDiffLocalization[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResAbsOrientationDiffLocalization;
                  hv_AbsOrientationDiffClass[HTuple::TupleGenSequence(hv_OldNumPred,HTuple(hv_PerClassNumPred[hv_ClsIdx])-1,1)] = hv_ResAbsOrientationDiffClass;
                }
                SetDictTuple(hv_PerClassMeasures, "is_fp_class", hv_IsFPClass);
                SetDictTuple(hv_PerClassMeasures, "is_fp_background", hv_IsFPBackground);
                SetDictTuple(hv_PerClassMeasures, "is_fp_localization", hv_IsFPLocalization);
                SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate", hv_IsFPDuplicate);
                SetDictTuple(hv_PerClassMeasures, "is_fp_multiple", hv_IsFPMultiple);
                if (0 != hv_EvaluateOrientation)
                {
                  SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple", 
                      hv_AbsOrientationDiffMultiple);
                  SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate", 
                      hv_AbsOrientationDiffDuplicate);
                  SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization", 
                      hv_AbsOrientationDiffLocalization);
                  SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class", 
                      hv_AbsOrientationDiffClass);
                }
              }
              //
              //End of detailed evaluation processing.
              //
            }
            }
          }
          else
          {
            if (0 != (hv_DetailedEvaluation.TupleAnd(int(hv_CurrentNumGtNoIgnore>0))))
            {
              //There are false negatives for this class.
              //Loop over IoU thresholds.
              {
              HTuple end_val427 = (hv_IoUThresholds.TupleLength())-1;
              HTuple step_val427 = 1;
              for (hv_ITIdx=0; hv_ITIdx.Continue(end_val427, step_val427); hv_ITIdx += step_val427)
              {
                hv_SampleHasFN[hv_ITIdx] = 1;
              }
              }
            }
          }
        }
        }
        //Update the confidences, num_gt and num_pred.
        SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
        SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
        SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
        SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
        //
        if (0 != hv_DetailedEvaluation)
        {
          //Set values that are calculated over all classes (for each IoU threshold).
          {
          HTuple end_val441 = (hv_IoUThresholds.TupleLength())-1;
          HTuple step_val441 = 1;
          for (hv_ITIdx=0; hv_ITIdx.Continue(end_val441, step_val441); hv_ITIdx += step_val441)
          {
            GetDictTuple(hv_AreaRunningMeasures, "iou_"+((""+HTuple(hv_IoUThresholds[hv_ITIdx])).TupleRegexpReplace("\\.","")), 
                &hv_PerIoUMeasure);
            //Set image IDs with false negatives
            if (0 != (HTuple(hv_SampleHasFN[hv_ITIdx])))
            {
              GetDictTuple(hv_CurrentSample, "image_id", &hv_CurrentImageID);
              GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives", &hv_ImageIDsWithFN);
              GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives", 
                  &hv_NumImageIDsWithFN);
              //Allocate a new block if necessary.
              if (0 != (int((hv_NumImageIDsWithFN+1)>(hv_ImageIDsWithFN.TupleLength()))))
              {
                hv_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
              }
              hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
              SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives", hv_ImageIDsWithFN);
              SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives", 
                  hv_NumImageIDsWithFN+1);
            }
            if (0 != (HTuple(hv_SampleHasFP[hv_ITIdx])))
            {
              GetDictTuple(hv_CurrentSample, "image_id", &hv_CurrentImageID);
              GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives", &hv_ImageIDsWithFP);
              GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives", 
                  &hv_NumImageIDsWithFP);
              //Allocate a new block if necessary.
              if (0 != (int((hv_NumImageIDsWithFP+1)>(hv_ImageIDsWithFP.TupleLength()))))
              {
                hv_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(HTuple(hv_AllocationBlockLength,-1));
              }
              hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
              SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives", hv_ImageIDsWithFP);
              SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives", 
                  hv_NumImageIDsWithFP+1);
            }
          }
          }
        }
      }
      }
      SetDictTuple(hv_CurrentRunningMeasures, "area_"+hv_AreaName, hv_AreaRunningMeasures);
    }
    }
  }
  }
  //
  return;
}

// Chapter: OCR / Deep OCR
// Short Description: Update running measures for an OCR recognition evaluation. 
void update_running_ocr_recognition_measures (HTuple hv_Samples, HTuple hv_Results, 
    HTuple hv_EvalParams, HTuple hv_RunningMeasures)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_N, hv_ImageIDsBatch, hv_WordsPredictionBatch;
  HTuple  hv_WordsGroundTruthBatch, hv_SampleIndex, hv_Sample;
  HTuple  hv_Result;

  //
  //This procedure updates the RunningMeasures for an evaluation for OCR recognition.
  //
  //These measures are stored in the dictionary RunningMeasures and
  //updated by incorporating the Results the model obtained for the Samples.
  //
  //
  hv_N = hv_Samples.TupleLength();
  TupleGenConst(hv_N, 0, &hv_ImageIDsBatch);
  TupleGenConst(hv_N, 0, &hv_WordsPredictionBatch);
  TupleGenConst(hv_N, 0, &hv_WordsGroundTruthBatch);
  //Loop over all samples and update running measures accordingly.
  {
  HTuple end_val12 = hv_N-1;
  HTuple step_val12 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val12, step_val12); hv_SampleIndex += step_val12)
  {
    hv_Sample = HTuple(hv_Samples[hv_SampleIndex]);
    hv_Result = HTuple(hv_Results[hv_SampleIndex]);
    hv_ImageIDsBatch[hv_SampleIndex] = hv_Sample.TupleGetDictTuple("image_id");
    hv_WordsPredictionBatch[hv_SampleIndex] = hv_Result.TupleGetDictTuple("word");
    hv_WordsGroundTruthBatch[hv_SampleIndex] = hv_Sample.TupleGetDictTuple("word");
  }
  }
  //
  //Update running measures
  SetDictTuple(hv_RunningMeasures, "image_ids", (hv_RunningMeasures.TupleGetDictTuple("image_ids")).TupleConcat(hv_ImageIDsBatch));
  SetDictTuple(hv_RunningMeasures, "words_prediction", (hv_RunningMeasures.TupleGetDictTuple("words_prediction")).TupleConcat(hv_WordsPredictionBatch));
  SetDictTuple(hv_RunningMeasures, "words_ground_truth", (hv_RunningMeasures.TupleGetDictTuple("words_ground_truth")).TupleConcat(hv_WordsGroundTruthBatch));
  //
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Update running measures for a pixel-based evaluation. 
void update_running_pixel_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures)
{

  // Local iconic variables
  HObject  ho_Annot, ho_Result, ho_ClsIgnore, ho_ClsIgnoreTmp;
  HObject  ho_ClsAnnot, ho_ClsResult, ho_TPReg, ho_FPReg, ho_FNReg;

  // Local control variables
  HTuple  hv_EvaluationType, hv_Measures, hv_PixelMeasures;
  HTuple  hv_ClassIDs, hv_NumClasses, hv_IgnoreClassIDs, hv_CalcConfMatrix;
  HTuple  hv_SegmentationImageExists, hv_GrippingMapExists;
  HTuple  hv_ResultKey, hv_ClassIDsResult, hv_ConfMatrix;
  HTuple  hv_MapClassIDs, hv_ClsIdToClsIdx, hv_TP, hv_FP;
  HTuple  hv_FN, hv_SampleIndex, hv_Rows, hv_Columns, hv_AnnotVals;
  HTuple  hv_ResultVals, hv_ConfTuple, hv_ConfHist, hv_BinSize;
  HTuple  hv_ConfMatrixTmp, hv_IgnoreIndex, hv_ClsIndex, hv_ClsId;
  HTuple  hv_ClsIdRes, hv_ClsTP, hv_ClsFP, hv_ClsFN;

  //
  //This procedure updates the RunningMeasures for a pixel-
  //based evaluation for segmentation or 3D Gripping Point
  //Detection. These measures are stored in the dictionary
  //RunningMeasures and updated by incorporating the Results
  //the model obtained for the Samples.
  //
  //Get evaluation type.
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
  //Get evaluation measures.
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  //Check if any pixel measures are requested.
  get_requested_pixel_measures(hv_Measures, hv_EvaluationType, &hv_PixelMeasures);
  if (0 != (int((hv_PixelMeasures.TupleLength())==0)))
  {
    return;
  }
  //
  //Get the class IDs.
  GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
  //Get the number of classes.
  GetDictTuple(hv_EvalParams, "num_classes", &hv_NumClasses);
  //Get the ignore class IDs.
  GetDictTuple(hv_EvalParams, "ignore_class_ids", &hv_IgnoreClassIDs);
  //
  //Check if we need to compute/update the confusion matrix.
  hv_CalcConfMatrix = int((hv_PixelMeasures.TupleFind("pixel_confusion_matrix"))>-1);
  //
  //Check and set result type and class IDs.
  GetDictParam(HTuple(hv_Results[0]), "key_exists", "segmentation_image", &hv_SegmentationImageExists);
  GetDictParam(HTuple(hv_Results[0]), "key_exists", "gripping_map", &hv_GrippingMapExists);
  if (0 != hv_SegmentationImageExists)
  {
    hv_ResultKey = "segmentation_image";
    //Class IDs in the result are the same as in the groundtruth.
    hv_ClassIDsResult = hv_ClassIDs;
  }
  else if (0 != hv_GrippingMapExists)
  {
    hv_ResultKey = "gripping_map";
    //Since the result is a binary gripping map, the class ID
    //is always 1.
    hv_ClassIDsResult = 1;
  }
  else
  {
    throw HException("No result available for evaluation");
  }
  //
  if (0 != hv_CalcConfMatrix)
  {
    //Get the current confusion matrix.
    GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", &hv_ConfMatrix);
    //Check if we need to map the class IDs.
    GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping", &hv_MapClassIDs);
    if (0 != hv_MapClassIDs)
    {
      GetDictTuple(hv_EvalParams, "class_id_mapping", &hv_ClsIdToClsIdx);
      hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax())+1;
    }
  }
  else
  {
    //Get the tuples for TP/FP/FN
    GetDictTuple(hv_RunningMeasures, "tp", &hv_TP);
    GetDictTuple(hv_RunningMeasures, "fp", &hv_FP);
    GetDictTuple(hv_RunningMeasures, "fn", &hv_FN);
  }
  //
  //Loop over images, i.e. sample dictionaries.
  {
  HTuple end_val60 = (hv_Samples.TupleLength())-1;
  HTuple step_val60 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val60, step_val60); hv_SampleIndex += step_val60)
  {
    //Get annotation.
    GetDictObject(&ho_Annot, HTuple(hv_Samples[hv_SampleIndex]), "segmentation_image");
    //Get result.
    GetDictObject(&ho_Result, HTuple(hv_Results[hv_SampleIndex]), hv_ResultKey);
    //
    //Update the measures.
    if (0 != hv_CalcConfMatrix)
    {
      //Get the ground truth and predicted class IDs of all pixels.
      GetRegionPoints(ho_Annot, &hv_Rows, &hv_Columns);
      GetGrayval(ho_Annot, hv_Rows, hv_Columns, &hv_AnnotVals);
      GetGrayval(ho_Result, hv_Rows, hv_Columns, &hv_ResultVals);
      //Map the class IDs to class indices.
      if (0 != hv_MapClassIDs)
      {
        hv_AnnotVals = HTuple(hv_ClsIdToClsIdx[hv_AnnotVals]);
        hv_ResultVals = HTuple(hv_ClsIdToClsIdx[hv_ResultVals]);
      }
      //The ground truth and predicted IDs are accumulated
      //such that each confusion pair (class_i <-> class_j) gets a unique value.
      hv_ConfTuple = (hv_NumClasses*hv_AnnotVals)+hv_ResultVals;
      //Compute the histogram of this confusion tuple.
      TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses*hv_NumClasses)-1, hv_NumClasses*hv_NumClasses, 
          &hv_ConfHist, &hv_BinSize);
      CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, &hv_ConfMatrixTmp);
      TransposeMatrix(hv_ConfMatrixTmp, &hv_ConfMatrixTmp);
      AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, &hv_ConfMatrix);
    }
    else
    {
      //Get the ignore region.
      GenEmptyRegion(&ho_ClsIgnore);
      {
      HTuple end_val88 = (hv_IgnoreClassIDs.TupleLength())-1;
      HTuple step_val88 = 1;
      for (hv_IgnoreIndex=0; hv_IgnoreIndex.Continue(end_val88, step_val88); hv_IgnoreIndex += step_val88)
      {
        Threshold(ho_Annot, &ho_ClsIgnoreTmp, HTuple(hv_IgnoreClassIDs[hv_IgnoreIndex]), 
            HTuple(hv_IgnoreClassIDs[hv_IgnoreIndex]));
        Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, &ho_ClsIgnore);
      }
      }
      //
      //Go through model classes.
      {
      HTuple end_val94 = (hv_ClassIDs.TupleLength())-1;
      HTuple step_val94 = 1;
      for (hv_ClsIndex=0; hv_ClsIndex.Continue(end_val94, step_val94); hv_ClsIndex += step_val94)
      {
        hv_ClsId = HTuple(hv_ClassIDs[hv_ClsIndex]);
        hv_ClsIdRes = HTuple(hv_ClassIDsResult[hv_ClsIndex]);
        //Get the annotated region for this class.
        Threshold(ho_Annot, &ho_ClsAnnot, hv_ClsId, hv_ClsId);
        //Get the result region for this class.
        Threshold(ho_Result, &ho_ClsResult, hv_ClsIdRes, hv_ClsIdRes);
        //The pixels in the ignore region should not be considered.
        Difference(ho_ClsResult, ho_ClsIgnore, &ho_ClsResult);
        //Get TP/FP/FN.
        Intersection(ho_ClsAnnot, ho_ClsResult, &ho_TPReg);
        Difference(ho_ClsResult, ho_ClsAnnot, &ho_FPReg);
        //We define false negatives as pixels that have been labeled as this class,
        //but not been correctly predicted.
        Difference(ho_ClsAnnot, ho_ClsResult, &ho_FNReg);
        //Get corresponding pixel numbers and update.
        RegionFeatures(ho_TPReg, "area", &hv_ClsTP);
        RegionFeatures(ho_FPReg, "area", &hv_ClsFP);
        RegionFeatures(ho_FNReg, "area", &hv_ClsFN);
        hv_TP[hv_ClsIndex] = HTuple(hv_TP[hv_ClsIndex])+hv_ClsTP;
        hv_FP[hv_ClsIndex] = HTuple(hv_FP[hv_ClsIndex])+hv_ClsFP;
        hv_FN[hv_ClsIndex] = HTuple(hv_FN[hv_ClsIndex])+hv_ClsFN;
      }
      }
    }
  }
  }
  //
  //Update running measures.
  if (0 != hv_CalcConfMatrix)
  {
    SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
  }
  else
  {
    SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
    SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
    SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Update running measures for a region-based evaluation. 
void update_running_region_measures (HTuple hv_Samples, HTuple hv_Results, HTuple hv_EvalParams, 
    HTuple hv_RunningMeasures)
{

  // Local iconic variables
  HObject  ho_Annot, ho_Result, ho_ClsAnnot, ho_ClsResult;
  HObject  ho_ClsAnnotConnected, ho_ClsAnnotSelected, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_Measures, hv_CalcRegionMeasures, hv_ClassIDs;
  HTuple  hv_GrippingMapExists, hv_ResultKey, hv_ClassIDsResult;
  HTuple  hv_SampleIndex, hv_ClsIndex, hv_ClsId, hv_ClsIdRes;
  HTuple  hv_NumRegions, hv_RegionIndex, hv_AreaIntersection;
  HTuple  hv_AreaGroundtruth, hv_RegionOverlap;

  //
  //This procedure updates the RunningMeasures for a region-
  //based evaluation for 3D Gripping Point Detection.
  //These measures are stored in the dictionary RunningMeasures
  //and updated by incorporating the Results the model obtained
  //for the Samples.
  //
  //Check if we need to compute any region measures.
  GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
  hv_CalcRegionMeasures = HTuple(int((hv_Measures.TupleFind("mean_pro"))>-1)).TupleOr(int((hv_Measures.TupleFind("all"))>-1));
  if (0 != (hv_CalcRegionMeasures.TupleNot()))
  {
    return;
  }
  //
  //Get the class IDs.
  GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
  //
  //Check and set result type and class IDs.
  GetDictParam(HTuple(hv_Results[0]), "key_exists", "gripping_map", &hv_GrippingMapExists);
  if (0 != hv_GrippingMapExists)
  {
    hv_ResultKey = "gripping_map";
    //Since the result is a binary gripping map, the class ID
    //is always 1.
    hv_ClassIDsResult = 1;
  }
  else
  {
    throw HException("No result available for evaluation");
  }
  //
  //Loop over images, i.e. sample dictionaries.
  {
  HTuple end_val29 = (hv_Samples.TupleLength())-1;
  HTuple step_val29 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val29, step_val29); hv_SampleIndex += step_val29)
  {
    //Get annotation.
    GetDictObject(&ho_Annot, HTuple(hv_Samples[hv_SampleIndex]), "segmentation_image");
    //Get result.
    GetDictObject(&ho_Result, HTuple(hv_Results[hv_SampleIndex]), hv_ResultKey);
    //
    //Go through model classes.
    {
    HTuple end_val36 = (hv_ClassIDs.TupleLength())-1;
    HTuple step_val36 = 1;
    for (hv_ClsIndex=0; hv_ClsIndex.Continue(end_val36, step_val36); hv_ClsIndex += step_val36)
    {
      hv_ClsId = HTuple(hv_ClassIDs[hv_ClsIndex]);
      hv_ClsIdRes = HTuple(hv_ClassIDsResult[hv_ClsIndex]);
      //Get the annotated region for this class.
      Threshold(ho_Annot, &ho_ClsAnnot, hv_ClsId, hv_ClsId);
      //Get the result region for this class.
      Threshold(ho_Result, &ho_ClsResult, hv_ClsIdRes, hv_ClsIdRes);
      //
      Connection(ho_ClsAnnot, &ho_ClsAnnotConnected);
      SelectShape(ho_ClsAnnotConnected, &ho_ClsAnnotConnected, "area", "and", 1, 
          "max");
      CountObj(ho_ClsAnnotConnected, &hv_NumRegions);
      {
      HTuple end_val47 = hv_NumRegions;
      HTuple step_val47 = 1;
      for (hv_RegionIndex=1; hv_RegionIndex.Continue(end_val47, step_val47); hv_RegionIndex += step_val47)
      {
        SelectObj(ho_ClsAnnotConnected, &ho_ClsAnnotSelected, hv_RegionIndex);
        Intersection(ho_ClsResult, ho_ClsAnnotSelected, &ho_RegionIntersection);
        RegionFeatures(ho_RegionIntersection, "area", &hv_AreaIntersection);
        RegionFeatures(ho_ClsAnnotSelected, "area", &hv_AreaGroundtruth);
        hv_RegionOverlap = (hv_AreaIntersection.TupleReal())/(hv_AreaGroundtruth.TupleReal());
        SetDictTupleAt(hv_RunningMeasures, "gt_overlap", hv_ClsIndex, HTuple((hv_RunningMeasures.TupleGetDictTuple("gt_overlap"))[hv_ClsIndex])+hv_RegionOverlap);
        SetDictTupleAt(hv_RunningMeasures, "num_gt_regions", hv_ClsIndex, HTuple((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))[hv_ClsIndex])+1);
      }
      }
    }
    }
  }
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Check that all given entries in EvalParams are valid. 
void validate_evaluation_param (HTuple hv_EvalParams, HTuple *hv_Valid, HTuple *hv_Exception)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ClassIDsExist, hv_ClassIDs, hv_NumClassesExist;
  HTuple  hv_NumClasses, hv_EvalInstancesExists, hv_EvaluationTypeExists;
  HTuple  hv_EvaluationType, hv_Indices, hv_MeasuresExists;
  HTuple  hv_Measures, hv_ValidMeasures, hv_Ks, hv_KeysExist;
  HTuple  hv_ClassNames, hv_ClassesToEvaluate, hv_ClassIDsToEvaluate;
  HTuple  hv_IouThreshExists, hv_IouThresholds, hv_MaxNumDetectionsExists;
  HTuple  hv_MaxNumDetections, hv_AreaRangesExist, hv_AreaRanges;
  HTuple  hv_AreaKeysExist, hv_AreaNames, hv_MinAreas, hv_MaxAreas;
  HTuple  hv_InstanceTypeExists, hv_InstanceType, hv_ValidInstanceTypes;
  HTuple  hv_AllocationBlockLengthExists, hv_AllocationBlockLength;
  HTuple  hv_DetailedEvaluationExists, hv_DetailedEvaluation;
  HTuple  hv_KeyExists, hv_InterpolatePRCurves, hv_IgnoreClassIDsExist;
  HTuple  hv_ValidMeasuresString, hv_Idx, hv_ValidMeasure;

  //
  //This procedure checks if the dictionary EvalParams
  //contains all necessary parameters and if they are valid (type, range, ...).
  //
  (*hv_Valid) = 0;
  (*hv_Exception) = "";
  //Check class IDs.
  GetDictParam(hv_EvalParams, "key_exists", "class_ids", &hv_ClassIDsExist);
  if (0 != (hv_ClassIDsExist.TupleNot()))
  {
    (*hv_Exception) = "The evaluation parameters need a key-value pair for 'class_ids'";
    return;
  }
  else
  {
    GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
    if (0 != (int((hv_ClassIDs.TupleLength())<1)))
    {
      (*hv_Exception) = "'class_ids' should have at least length 1";
      return;
    }
    if (0 != (int((hv_ClassIDs.TupleIsIntElem())!=HTuple(hv_ClassIDs.TupleLength(),1))))
    {
      (*hv_Exception) = "'class_ids' should be of type int";
      return;
    }
    if (0 != (int(((hv_ClassIDs.TupleLessElem(0)).TupleFind(1))>-1)))
    {
      (*hv_Exception) = "'class_ids' should be positive or zero";
      return;
    }
  }
  //Check the entry num_classes.
  GetDictParam(hv_EvalParams, "key_exists", "num_classes", &hv_NumClassesExist);
  if (0 != (hv_NumClassesExist.TupleNot()))
  {
    (*hv_Exception) = "The evaluation parameters need a key-value pair for 'num_classes'";
    return;
  }
  else
  {
    GetDictTuple(hv_EvalParams, "num_classes", &hv_NumClasses);
    if (0 != (int((hv_NumClasses.TupleLength())!=1)))
    {
      (*hv_Exception) = "'num_classes' should have length 1";
      return;
    }
    if (0 != (int((hv_NumClasses.TupleType())!=(HTuple(HTuple(1).TupleInt()).TupleType()))))
    {
      (*hv_Exception) = "'num_classes' should be of type int";
      return;
    }
    if (0 != (int(hv_NumClasses<1)))
    {
      (*hv_Exception) = "'num_classes' should be at least 1";
      return;
    }
  }
  //Check that num_classes is equal to |class_ids|.
  if (0 != (int(hv_NumClasses!=(hv_ClassIDs.TupleLength()))))
  {
    (*hv_Exception) = "'num_classes' has to be set to the number of 'class_ids'";
    return;
  }
  //Check the entry 'evaluate_instances'.
  GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances", &hv_EvalInstancesExists);
  if (0 != (hv_EvalInstancesExists.TupleNot()))
  {
    (*hv_Exception) = "The evaluation parameters need a key-value pair for 'evaluate_instances'";
    return;
  }
  //Check the entry 'evaluation_type'.
  GetDictParam(hv_EvalParams, "key_exists", "evaluation_type", &hv_EvaluationTypeExists);
  if (0 != (hv_EvaluationTypeExists.TupleNot()))
  {
    (*hv_Exception) = "The evaluation parameters need a key-value pair for 'evaluation_type'";
    return;
  }
  else
  {
    GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
    TupleFind((((((((HTuple("3d_gripping_point_detection").Append("anomaly_detection")).Append("classification")).Append("detection")).Append("gc_anomaly_detection")).Append("ocr_recognition")).Append("ocr_detection")).Append("segmentation")), 
        hv_EvaluationType, &hv_Indices);
    if (0 != (HTuple(int(hv_Indices==-1)).TupleOr(int(hv_Indices==HTuple()))))
    {
      (*hv_Exception) = "Invalid entry for 'evaluation_type': "+hv_EvaluationType;
      return;
    }
  }
  //Check the entry 'measures'.
  GetDictParam(hv_EvalParams, "key_exists", "measures", &hv_MeasuresExists);
  if (0 != (hv_MeasuresExists.TupleNot()))
  {
    (*hv_Exception) = "The evaluation parameters need a key-value pair for 'measures'";
    return;
  }
  else
  {
    GetDictTuple(hv_EvalParams, "measures", &hv_Measures);
    if (0 != (int((hv_Measures.TupleLength())==0)))
    {
      (*hv_Exception) = "'measures' should contain at least one entry";
      return;
    }
  }
  //Check evaluation type specific entries of EvalParams.
  GetDictTuple(hv_EvalParams, "evaluation_type", &hv_EvaluationType);
  if (0 != (int(hv_EvaluationType==HTuple("3d_gripping_point_detection"))))
  {
    //Pixel- and region-based evaluation.
    get_valid_pixel_measures(hv_EvaluationType, &hv_ValidMeasures);
    hv_ValidMeasures = hv_ValidMeasures.TupleConcat(((((HTuple("mean_pro").Append("gripping_point_precision")).Append("gripping_point_recall")).Append("gripping_point_f_score")).Append("all")));
  }
  else if (0 != (HTuple(int(hv_EvaluationType==HTuple("anomaly_detection"))).TupleOr(int(hv_EvaluationType==HTuple("gc_anomaly_detection")))))
  {
    //
    //Check for correct number of classes.
    if (0 != (int((hv_ClassIDs.TupleLength())!=2)))
    {
      throw HException("The number of classes must be 2 for model type 'anomaly_detection' or 'gc_anomaly_detection'.");
    }
    //
    hv_ValidMeasures.Clear();
    hv_ValidMeasures[0] = "anomaly_score_histogram";
    hv_ValidMeasures[1] = "precision";
    hv_ValidMeasures[2] = "recall";
    hv_ValidMeasures[3] = "absolute_confusion_matrix";
    hv_ValidMeasures[4] = "relative_confusion_matrix";
    hv_ValidMeasures[5] = "all";
  }
  else if (0 != (int(hv_EvaluationType==HTuple("classification"))))
  {
    TupleGenSequence(1, hv_ClassIDs.TupleLength(), 1, &hv_Ks);
    hv_ValidMeasures.Clear();
    hv_ValidMeasures[0] = "all";
    hv_ValidMeasures.Append(("top"+hv_Ks)+"_error");
    hv_ValidMeasures = hv_ValidMeasures.TupleConcat(((((HTuple("precision").Append("recall")).Append("f_score")).Append("absolute_confusion_matrix")).Append("relative_confusion_matrix")));
    //
    //Check if not both of the two options to specify the evaluated classes are chosen.
    GetDictParam(hv_EvalParams, "key_exists", (HTuple("class_names_to_evaluate").Append("class_ids_to_evaluate")), 
        &hv_KeysExist);
    if (0 != (int((hv_KeysExist.TupleSum())==2)))
    {
      (*hv_Exception) = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";
      return;
    }
    if (0 != (HTuple(hv_KeysExist[0])))
    {
      GetDictTuple(hv_EvalParams, "class_names", &hv_ClassNames);
      GetDictTuple(hv_EvalParams, "class_names_to_evaluate", &hv_ClassesToEvaluate);
      if (0 != (int((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat("global")))!=HTuple())))
      {
        (*hv_Exception) = "Invalid entry in 'class_names_to_evaluate'";
        return;
      }
    }
    if (0 != (HTuple(hv_KeysExist[1])))
    {
      GetDictTuple(hv_EvalParams, "class_ids", &hv_ClassIDs);
      GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", &hv_ClassIDsToEvaluate);
      if (0 != (int((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat("global")))!=HTuple())))
      {
        (*hv_Exception) = "Invalid entry in 'class_ids_to_evaluate'";
        return;
      }
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("detection"))))
  {
    //Instance-based evaluation.
    //Add instance measures.
    hv_ValidMeasures.Clear();
    hv_ValidMeasures[0] = "all";
    hv_ValidMeasures[1] = "mean_ap";
    //
    //Check if the entry 'iou_threshold' is present.
    GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", &hv_IouThreshExists);
    if (0 != (hv_IouThreshExists.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'iou_threshold'";
      return;
    }
    else
    {
      GetDictTuple(hv_EvalParams, "iou_threshold", &hv_IouThresholds);
      //Check the length of 'iou_threshold'.
      if (0 != (int((hv_IouThresholds.TupleLength())<1)))
      {
        (*hv_Exception) = "'iou_threshold' is empty";
        return;
      }
      if (0 != (int((hv_IouThresholds.TupleIsRealElem())!=HTuple(hv_IouThresholds.TupleLength(),1))))
      {
        (*hv_Exception) = "'iou_threshold' should be of type real";
        return;
      }
      //Check if the IoU thresholds are within (0.0, 1.0).
      if (0 != (HTuple(int((hv_IouThresholds.TupleMin())<=0.0)).TupleOr(int((hv_IouThresholds.TupleMax())>=1.0))))
      {
        (*hv_Exception) = HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");
        return;
      }
    }
    //
    //Check if the entry 'max_num_detections' is present.
    GetDictParam(hv_EvalParams, "key_exists", "max_num_detections", &hv_MaxNumDetectionsExists);
    if (0 != (hv_MaxNumDetectionsExists.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'max_num_detections'";
      return;
    }
    else
    {
      GetDictTuple(hv_EvalParams, "max_num_detections", &hv_MaxNumDetections);
      //Check the length of 'max_num_detections'.
      if (0 != (int((hv_MaxNumDetections.TupleLength())<1)))
      {
        (*hv_Exception) = "'max_num_detections' is empty";
        return;
      }
      if (0 != (int((hv_MaxNumDetections.TupleIsIntElem())!=HTuple(hv_MaxNumDetections.TupleLength(),1))))
      {
        (*hv_Exception) = "'max_num_detections' should be of type int";
        return;
      }
      //Check if 'max_num_detections' is -1 (to use all detections) or positive.
      if (0 != (HTuple(int((hv_MaxNumDetections.TupleMin())<-1)).TupleOr(int((hv_MaxNumDetections.TupleFind(0))>-1))))
      {
        (*hv_Exception) = "'max_num_detections' should be -1 or positive";
        return;
      }
    }
    //
    //Check if the entry 'area_ranges' is present.
    GetDictParam(hv_EvalParams, "key_exists", "area_ranges", &hv_AreaRangesExist);
    if (0 != (hv_AreaRangesExist.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'area_ranges'";
      return;
    }
    else
    {
      //Check if the entry 'area_ranges' is a dict.
      GetDictTuple(hv_EvalParams, "area_ranges", &hv_AreaRanges);
      if (0 != (int((hv_AreaRanges.TupleSemType())!=HTuple("dict"))))
      {
        (*hv_Exception) = "'area_ranges' must be a dict";
        return;
      }
      //Check that the necessary keys exist.
      GetDictParam(hv_AreaRanges, "key_exists", ((HTuple("name").Append("min")).Append("max")), 
          &hv_AreaKeysExist);
      if (0 != (HTuple(hv_AreaKeysExist[0]).TupleNot()))
      {
        (*hv_Exception) = "'area_ranges' need a key-value pair for 'name'";
        return;
      }
      if (0 != (HTuple(hv_AreaKeysExist[1]).TupleNot()))
      {
        (*hv_Exception) = "'area_ranges' need a key-value pair for 'min'";
        return;
      }
      if (0 != (HTuple(hv_AreaKeysExist[2]).TupleNot()))
      {
        (*hv_Exception) = "'area_ranges' need a key-value pair for 'max'";
        return;
      }
      //Check the lengths of the area keys.
      GetDictTuple(hv_AreaRanges, "name", &hv_AreaNames);
      if (0 != (int((hv_AreaNames.TupleLength())<1)))
      {
        (*hv_Exception) = "'area_ranges': 'name' is empty";
        return;
      }
      GetDictTuple(hv_AreaRanges, "min", &hv_MinAreas);
      if (0 != (int((hv_MinAreas.TupleLength())<1)))
      {
        (*hv_Exception) = "'area_ranges': 'min' is empty";
        return;
      }
      GetDictTuple(hv_AreaRanges, "max", &hv_MaxAreas);
      if (0 != (int((hv_MaxAreas.TupleLength())<1)))
      {
        (*hv_Exception) = "'area_ranges': 'max' is empty";
        return;
      }
      if (0 != (HTuple(int((hv_AreaNames.TupleLength())!=(hv_MinAreas.TupleLength()))).TupleOr(int((hv_AreaNames.TupleLength())!=(hv_MaxAreas.TupleLength())))))
      {
        (*hv_Exception) = HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");
        return;
      }
      //Check values of min, max.
      if (0 != (int(((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas)).TupleFind(1))>-1)))
      {
        (*hv_Exception) = "'area_ranges': 'min' must be elementwise smaller than 'max'";
        return;
      }
    }
    //
    //Check if instance-type is valid.
    GetDictParam(hv_EvalParams, "key_exists", "instance_type", &hv_InstanceTypeExists);
    if (0 != (hv_InstanceTypeExists.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'instance_type'";
      return;
    }
    else
    {
      GetDictTuple(hv_EvalParams, "instance_type", &hv_InstanceType);
      hv_ValidInstanceTypes.Clear();
      hv_ValidInstanceTypes[0] = "rectangle1";
      hv_ValidInstanceTypes[1] = "rectangle2";
      hv_ValidInstanceTypes[2] = "mask";
      if (0 != (int((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))==-1)))
      {
        (*hv_Exception) = ("Invalid instance type '"+hv_InstanceType)+"'";
        return;
      }
    }
    //
    //Check if the entry 'allocation_block_length' is present and valid.
    GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length", &hv_AllocationBlockLengthExists);
    if (0 != (hv_AllocationBlockLengthExists.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'allocation_block_length'";
      return;
    }
    else
    {
      GetDictTuple(hv_EvalParams, "allocation_block_length", &hv_AllocationBlockLength);
      //Check the length of 'allocation_block_length'.
      if (0 != (int((hv_AllocationBlockLength.TupleLength())!=1)))
      {
        (*hv_Exception) = "'allocation_block_length' should have length 1";
        return;
      }
      //Check the type of 'allocation_block_length'.
      if (0 != (int((hv_AllocationBlockLength.TupleType())!=(HTuple(HTuple(0).TupleInt()).TupleType()))))
      {
        (*hv_Exception) = "'allocation_block_length' should be of type int";
        return;
      }
      //Check if 'allocation_block_length' is larger than zero.
      if (0 != (int(hv_AllocationBlockLength<1)))
      {
        (*hv_Exception) = "'allocation_block_length' should be positive";
        return;
      }
    }
    //
    //Check if the entry 'detailed_evaluation' is valid if present.
    GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation", &hv_DetailedEvaluationExists);
    if (0 != (hv_DetailedEvaluationExists.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";
      return;
    }
    else
    {
      GetDictTuple(hv_EvalParams, "detailed_evaluation", &hv_DetailedEvaluation);
      //Check the length of 'detailed_evaluation'.
      if (0 != (int((hv_DetailedEvaluation.TupleLength())!=1)))
      {
        (*hv_Exception) = "'detailed_evaluation' should have length 1";
        return;
      }
      //Check the type of 'detailed_evaluation'.
      if (0 != (int((hv_DetailedEvaluation.TupleType())!=(HTuple(1).TupleType()))))
      {
        (*hv_Exception) = "'detailed_evaluation' should be of type int";
        return;
      }
      //Check if 'detailed_evaluation' is true or false.
      if (0 != (HTuple(int(hv_DetailedEvaluation!=0)).TupleAnd(int(hv_DetailedEvaluation!=1))))
      {
        (*hv_Exception) = "'detailed_evaluation' should be zero or one";
        return;
      }
    }
    //
    //Check if the entry 'interpolate_pr_curves' is valid if present.
    GetDictParam(hv_EvalParams, "key_exists", "interpolate_pr_curves", &hv_KeyExists);
    if (0 != (hv_KeyExists.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'interpolate_pr_curves'";
      return;
    }
    else
    {
      GetDictTuple(hv_EvalParams, "interpolate_pr_curves", &hv_InterpolatePRCurves);
      //Check the length of 'interpolate_pr_curves'.
      if (0 != (int((hv_InterpolatePRCurves.TupleLength())!=1)))
      {
        (*hv_Exception) = "'interpolate_pr_curves' should have length 1";
        return;
      }
      //Check the type of 'interpolate_pr_curves'.
      if (0 != (int((hv_InterpolatePRCurves.TupleType())!=(HTuple(1).TupleType()))))
      {
        (*hv_Exception) = "'interpolate_pr_curves' should be of type int";
        return;
      }
      //Check if 'interpolate_pr_curves' is true or false.
      if (0 != (HTuple(int(hv_InterpolatePRCurves!=0)).TupleAnd(int(hv_InterpolatePRCurves!=1))))
      {
        (*hv_Exception) = "'interpolate_pr_curves' should be zero or one";
        return;
      }
    }
    //
    //Add valid measure 'soap' if instance_type is 'rectangle2'.
    if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      hv_ValidMeasures = hv_ValidMeasures.TupleConcat("soap");
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("segmentation"))))
  {
    //Pixel-based evaluation.
    get_valid_pixel_measures(hv_EvaluationType, &hv_ValidMeasures);
    hv_ValidMeasures = hv_ValidMeasures.TupleConcat("all");
    //
    //Check if the entry 'ignore_class_ids' exists.
    GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids", &hv_IgnoreClassIDsExist);
    if (0 != (hv_IgnoreClassIDsExist.TupleNot()))
    {
      (*hv_Exception) = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";
      return;
    }
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_recognition"))))
  {
    //OCR recognition evaluation.
    hv_ValidMeasures = "accuracy";
  }
  else if (0 != (int(hv_EvaluationType==HTuple("ocr_detection"))))
  {
    //OCR detection evaluation.
    hv_ValidMeasures.Clear();
    hv_ValidMeasures[0] = "all";
    hv_ValidMeasures[1] = "recall";
    hv_ValidMeasures[2] = "precision";
    hv_ValidMeasures[3] = "f_score";
    hv_ValidMeasures[4] = "soap";
  }
  else
  {
    (*hv_Exception) = "Unknown evaluation_type: "+hv_EvaluationType;
    return;
  }
  //Check measures.
  hv_ValidMeasuresString = HTuple(((hv_ValidMeasures.TupleLength())*2)-1,HTuple("','"));
  hv_ValidMeasuresString[HTuple::TupleGenSequence(0,(hv_ValidMeasuresString.TupleLength())-1,2)] = hv_ValidMeasures;
  hv_ValidMeasuresString = hv_ValidMeasuresString.TupleSum();
  {
  HTuple end_val342 = (hv_Measures.TupleLength())-1;
  HTuple step_val342 = 1;
  for (hv_Idx=0; hv_Idx.Continue(end_val342, step_val342); hv_Idx += step_val342)
  {
    hv_ValidMeasure = (hv_ValidMeasures.TupleFind(HTuple(hv_Measures[hv_Idx]))).TupleGreaterElem(-1);
    if (0 != (hv_ValidMeasure.TupleNot()))
    {
      (*hv_Exception) = ((("Invalid measure '"+HTuple(hv_Measures[hv_Idx]))+HTuple("', choose one of ['"))+hv_ValidMeasuresString)+"']";
      return;
    }
  }
  }
  //
  //Done with checks.
  (*hv_Valid) = 1;
  return;
}

// Local procedures 
// Short Description: Local example procedure for cleaning up files written by example script. 
void clean_up_output (HTuple hv_OutputDir, HTuple hv_RemoveResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_WindowHandle, hv_WarningCleanup;

  //This local example procedure cleans up the output of the example.

  if (0 != (hv_RemoveResults.TupleNot()))
  {
    return;
  }
  //Display a warning.
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,600,300,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
  hv_WarningCleanup.Clear();
  hv_WarningCleanup[0] = "Congratulations, you have finished the example.";
  hv_WarningCleanup[1] = "";
  hv_WarningCleanup[2] = "Unless you would like to use the output data / model,";
  hv_WarningCleanup[3] = "press F5 to clean up.";
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_WarningCleanup, "window", "center", 
        "center", ((((HTuple("black").Append("black")).Append("coral")).Append("coral")).Append("coral")), 
        HTuple(), HTuple());

  // stop(...); only in hdevelop
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());

  //Delete all outputs of the example.
  remove_dir_recursively(hv_OutputDir);
  return;
}

// Short Description: This procedure displays the accuracy comparison of 2 models. 
void dev_display_evaluation_comparison (HTuple hv_ModelNames, HTuple hv_EvaluationResults, 
    HTuple hv_WindowColumn, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_WindowWidth, hv_WindowHeight, hv_PieColors;
  HTuple  hv_ContentStart, hv_AvailableHeight, hv_PieRadius;
  HTuple  hv_Eval, hv_Split, hv_NumSamples, hv_NumSamplesSplit;
  HTuple  hv_Percentage, hv_Headline, hv_Footer, hv_PieParams;
  HTuple  hv_PieColumnDelta, hv_PieColumnStart, hv_M, hv_Value;
  HTuple  hv_Space, hv_PieRow, hv_MetricName, hv_PieRatios;
  HTuple  hv_PieColumn;

  //This procedure displays the accuracy comparison of 2 models.
  //
  if (0 != (HTuple(int((hv_ModelNames.TupleLength())!=2)).TupleOr(int((hv_EvaluationResults.TupleLength())!=2))))
  {
    throw HException("This procedure works only with 2 models.");
  }
  hv_WindowWidth = 470;
  hv_WindowHeight = 512;
  hv_PieColors.Clear();
  hv_PieColors[0] = "#008000";
  hv_PieColors[1] = "#800000";
  hv_ContentStart = hv_WindowHeight*0.12;
  hv_AvailableHeight = hv_WindowHeight*0.70;
  hv_PieRadius = hv_AvailableHeight*0.12;

  SetWindowAttr("background_color","black");
  OpenWindow(0,hv_WindowColumn,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  set_display_font((*hv_WindowHandle), 14, "mono", "true", "false");
  hv_Eval = ((const HTuple&)hv_EvaluationResults)[0];
  hv_Split = hv_Eval.TupleGetDictTuple("split");
  hv_NumSamples = hv_Eval.TupleGetDictTuple("num_samples_eval");
  hv_NumSamplesSplit = hv_Eval.TupleGetDictTuple("num_samples_split");
  hv_Percentage = (hv_NumSamples/(hv_NumSamplesSplit.TupleReal()))*100;
  if (0 != (int(hv_Percentage==100)))
  {
    hv_Headline = ("Evaluation on the '"+hv_Split)+"' split:";
    hv_Footer = ("The evaluation was computed on "+hv_NumSamples)+" samples.";
  }
  else
  {
    hv_Headline = ((("Evaluation on "+(hv_Percentage.TupleRound()))+"% of the '")+hv_Split)+"' split:";
    hv_Footer = ((("The evaluation was computed on "+hv_NumSamples)+" of ")+hv_NumSamplesSplit)+" samples.";
  }
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Headline, "window", "top", "left", "yellow", 
        "box", "false");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Footer, "window", "bottom", "left", 
        "white", "box", "false");
  CreateDict(&hv_PieParams);
  SetDictTuple(hv_PieParams, "title_color", "white");
  SetDictTuple(hv_PieParams, "footnote_color", "green");
  hv_PieColumnDelta = hv_WindowWidth/2;
  hv_PieColumnStart = hv_WindowWidth/4;
  for (hv_M=0; hv_M<=1; hv_M+=1)
  {
    hv_Eval = HTuple(hv_EvaluationResults[hv_M]);
    hv_Value = hv_Eval.TupleGetDictTuple("recall");

    hv_Space = (hv_PieRadius*2)+(0.12*hv_AvailableHeight);
    hv_PieRow = hv_ContentStart+(hv_Space/2);
    hv_MetricName = "Recall";
    hv_PieRatios.Clear();
    hv_PieRatios.Append(hv_Value);
    hv_PieRatios.Append(1-hv_Value);
    hv_PieColumn = hv_PieColumnStart+(hv_M*hv_PieColumnDelta);
    SetDictTuple(hv_PieParams, "title", HTuple(hv_ModelNames[hv_M]));
    SetDictTuple(hv_PieParams, "footnote", "Recall: "+(hv_Value.TupleString(".2f")));
    dev_display_pie_chart((*hv_WindowHandle), hv_PieRatios, hv_PieRow, hv_PieColumn, 
        hv_PieRadius, hv_PieColors, hv_PieParams);

    hv_PieRow = (hv_ContentStart+hv_Space)+(hv_Space/2);
    hv_Value = hv_Eval.TupleGetDictTuple("precision");
    hv_PieRatios.Clear();
    hv_PieRatios.Append(hv_Value);
    hv_PieRatios.Append(1-hv_Value);
    hv_PieColumn = hv_PieColumnStart+(hv_M*hv_PieColumnDelta);
    SetDictTuple(hv_PieParams, "title", " ");
    SetDictTuple(hv_PieParams, "footnote", "Precision: "+(hv_Value.TupleString(".2f")));
    dev_display_pie_chart((*hv_WindowHandle), hv_PieRatios, hv_PieRow, hv_PieColumn, 
        hv_PieRadius, hv_PieColors, hv_PieParams);


    hv_PieRow = (hv_ContentStart+(hv_Space*2))+(hv_Space/2);
    hv_Value = hv_Eval.TupleGetDictTuple("f_score");
    hv_PieRatios.Clear();
    hv_PieRatios.Append(hv_Value);
    hv_PieRatios.Append(1-hv_Value);
    hv_PieColumn = hv_PieColumnStart+(hv_M*hv_PieColumnDelta);
    SetDictTuple(hv_PieParams, "title", " ");
    SetDictTuple(hv_PieParams, "footnote", "F-Score: "+(hv_Value.TupleString(".2f")));
    dev_display_pie_chart((*hv_WindowHandle), hv_PieRatios, hv_PieRow, hv_PieColumn, 
        hv_PieRadius, hv_PieColors, hv_PieParams);
  }
  return;
}

// Short Description: Evaluates a Deep OCR detection model on a given dataset split. 
void evaluate_ocr_detection (HTuple hv_DLModelHandle, HTuple hv_DLDevice, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple hv_BatchSize, HTuple hv_DLDataset, HTuple hv_EvaluationSplit, 
    HTuple hv_MaxNumSamples, HTuple *hv_EvaluationResult)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_SampleIndices, hv_NumSamplesSplit;
  HTuple  hv_GenParamEval, hv_NumSamples, hv_EvalParamsOrig;

  SetDlModelParam(hv_DLModelHandle, "batch_size", 1);
  SetDlModelParam(hv_DLModelHandle, "image_size", hv_ImageWidth.TupleConcat(hv_ImageHeight));
  SetDlModelParam(hv_DLModelHandle, "device", hv_DLDevice);
  SetDlModelParam(hv_DLModelHandle, "optimize_for_inference", "true");
  SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSize);
  SetDlModelParam(hv_DLModelHandle, "runtime_init", "immediately");

  find_dl_samples(hv_DLDataset.TupleGetDictTuple("samples"), "split", hv_EvaluationSplit, 
      "match", &hv_SampleIndices);
  hv_NumSamplesSplit = hv_SampleIndices.TupleLength();
  if (0 != (int(hv_MaxNumSamples!=-1)))
  {
    if (0 != (int((hv_SampleIndices.TupleLength())>hv_MaxNumSamples)))
    {
      SetSystem("seed_rand", 42);
      tuple_shuffle(hv_SampleIndices, &hv_SampleIndices);
      hv_SampleIndices = hv_SampleIndices.TupleSelectRange(0,hv_MaxNumSamples-1);
    }
  }

  //Show progress during evaluation.
  CreateDict(&hv_GenParamEval);
  SetDictTuple(hv_GenParamEval, "show_progress", 1);
  hv_NumSamples = hv_SampleIndices.TupleLength();
  evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "sample_indices", hv_SampleIndices, 
      hv_GenParamEval, &(*hv_EvaluationResult), &hv_EvalParamsOrig);
  SetDictTuple((*hv_EvaluationResult), "num_samples_eval", hv_NumSamples);
  SetDictTuple((*hv_EvaluationResult), "num_samples_split", hv_NumSamplesSplit);
  SetDictTuple((*hv_EvaluationResult), "split", hv_EvaluationSplit);

  return;
}

// Short Description: This procedure prepares the comparison visualization. 
void prepare_detailed_comparison_visualization (HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
    HTuple *hv_VisualizationDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_WindowDictTop, hv_ImageSize, hv_WindowSize;
  HTuple  hv_ScoreMapSize, hv_WindowHandle, hv_WindowHandleScoreMapChar;
  HTuple  hv_WindowHandleScoreMapLink, hv_WindowDictBottom;
  HTuple  hv_DisplayParam, hv_KeysForDisplay;

  CreateDict(&hv_WindowDictTop);
  hv_ImageSize.Clear();
  hv_ImageSize.Append(hv_ImageWidth);
  hv_ImageSize.Append(hv_ImageHeight);
  hv_WindowSize = (hv_ImageSize*0.9).TupleInt();
  hv_ScoreMapSize = (hv_WindowSize*0.75).TupleInt();
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,HTuple(hv_WindowSize[0]),HTuple(hv_WindowSize[1]),0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  SetWindowAttr("background_color","black");
  OpenWindow(0,HTuple(hv_WindowSize[0])+10,HTuple(hv_ScoreMapSize[0]),HTuple(hv_ScoreMapSize[1]),0,"visible","",&hv_WindowHandleScoreMapChar);
  HDevWindowStack::Push(hv_WindowHandleScoreMapChar);
  SetWindowAttr("background_color","black");
  OpenWindow(0,(HTuple(hv_WindowSize[0])+20)+HTuple(hv_ScoreMapSize[0]),HTuple(hv_ScoreMapSize[0]),HTuple(hv_ScoreMapSize[1]),0,"visible","",&hv_WindowHandleScoreMapLink);
  HDevWindowStack::Push(hv_WindowHandleScoreMapLink);
  SetDictTuple(hv_WindowDictTop, "ocr_detection_both", hv_WindowHandle);
  SetDictTuple(hv_WindowDictTop, "ocr_detection_score_map_character", hv_WindowHandleScoreMapChar);
  SetDictTuple(hv_WindowDictTop, "ocr_detection_score_map_link", hv_WindowHandleScoreMapLink);
  CreateDict(&hv_WindowDictBottom);
  SetWindowAttr("background_color","black");
  OpenWindow(HTuple(hv_WindowSize[1])+80,0,HTuple(hv_WindowSize[0]),HTuple(hv_WindowSize[1]),0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  SetWindowAttr("background_color","black");
  OpenWindow(HTuple(hv_WindowSize[1])+80,HTuple(hv_WindowSize[0])+10,HTuple(hv_ScoreMapSize[0]),HTuple(hv_ScoreMapSize[1]),0,"visible","",&hv_WindowHandleScoreMapChar);
  HDevWindowStack::Push(hv_WindowHandleScoreMapChar);
  SetWindowAttr("background_color","black");
  OpenWindow(HTuple(hv_WindowSize[1])+80,(HTuple(hv_WindowSize[0])+20)+HTuple(hv_ScoreMapSize[0]),HTuple(hv_ScoreMapSize[0]),HTuple(hv_ScoreMapSize[1]),0,"visible","",&hv_WindowHandleScoreMapLink);
  HDevWindowStack::Push(hv_WindowHandleScoreMapLink);
  SetDictTuple(hv_WindowDictBottom, "ocr_detection_both", hv_WindowHandle);
  SetDictTuple(hv_WindowDictBottom, "ocr_detection_score_map_character", hv_WindowHandleScoreMapChar);
  SetDictTuple(hv_WindowDictBottom, "ocr_detection_score_map_link", hv_WindowHandleScoreMapLink);
  CreateDict(&hv_DisplayParam);
  SetDictTuple(hv_DisplayParam, "display_legend", 0);
  //
  hv_KeysForDisplay = "ocr_detection_both";
  hv_KeysForDisplay = hv_KeysForDisplay.TupleConcat("ocr_detection_score_map_character");
  hv_KeysForDisplay = hv_KeysForDisplay.TupleConcat("ocr_detection_score_map_link");
  //
  CreateDict(&(*hv_VisualizationDict));
  SetDictTuple((*hv_VisualizationDict), "keys_for_display", hv_KeysForDisplay);
  SetDictTuple((*hv_VisualizationDict), "display_param", hv_DisplayParam);
  SetDictTuple((*hv_VisualizationDict), "window_dict_top", hv_WindowDictTop);
  SetDictTuple((*hv_VisualizationDict), "window_dict_bottom", hv_WindowDictBottom);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_Rectangle;

  // Local control variables
  HTuple  hv_BestModelFilename, hv_BestModelDeepOCRFilename;
  HTuple  hv_DeepOcrHandle, hv_Alphabet, hv_DLDeviceHandles;
  HTuple  hv_DLDevice, hv_WindowHandle, hv_ImageFiles, hv_Index;
  HTuple  hv_DeepOcrResult, hv_DetectionMode, hv_RecognitionMode;
  HTuple  hv_Words, hv_Width, hv_Height, hv_Wordsrow, hv_Wordscol;
  HTuple  hv_Wordsphi, hv_Wordslength1, hv_Wordslength2, hv_HasRecognition;
  HTuple  hv_RecognizedWord;

  //**   5.) DEEP OCR INTEGRATION AND INFERENCE   ***
  hv_BestModelFilename = HTuple("F:/QtProject/BIN/")+"model_punched_numbers_best.hdl";
  hv_BestModelDeepOCRFilename = HTuple("F:/QtProject/BIN/")+"model_punched_numbers_best.hdo";

  CreateDeepOcr(HTuple(), HTuple(), &hv_DeepOcrHandle);

  // 0-9.
  hv_Alphabet = HTuple::TupleGenSequence(0,9,1)+"";
  SetDeepOcrParam(hv_DeepOcrHandle, "recognition_alphabet", hv_Alphabet);

  //cpu
  QueryAvailableDlDevices("runtime", "cpu", &hv_DLDeviceHandles);
  if (0 != (int((hv_DLDeviceHandles.TupleLength())==0)))
  {
    throw HException("No supported device found to continue this example.");
  }
  hv_DLDevice = ((const HTuple&)hv_DLDeviceHandles)[0];
  SetDeepOcrParam(hv_DeepOcrHandle, "device", hv_DLDevice);

  SetDeepOcrParam(hv_DeepOcrHandle, "detection_model", hv_BestModelFilename);
  SetDeepOcrParam(hv_DeepOcrHandle, "detection_batch_size", 1);
  SetDeepOcrParam(hv_DeepOcrHandle, "detection_optimize_for_inference", "true");

  //For convenience we write the Deep OCR model to the output
  //directory. That way it can be easily read via read_deep_ocr.

  ReadDeepOcr(hv_BestModelDeepOCRFilename, &hv_DeepOcrHandle);

  //
  //write_deep_ocr (DeepOcrHandle, BestModelDeepOCRFilename)


  hv_WindowHandle = HTuple();
  ListFiles("D:/Program Files/MVTec/HALCON-23.05-Progress/examples/images/punched_numbers", 
      ((HTuple("files").Append("follow_links")).Append("recursive")), &hv_ImageFiles);
  TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")), 
      &hv_ImageFiles);
  for (hv_Index=0; hv_Index<=10; hv_Index+=1)
  {
    ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index]));
    ApplyDeepOcr(ho_Image, hv_DeepOcrHandle, HTuple(), &hv_DeepOcrResult);
    //if (|WindowHandle| == 0)
      //dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)
    //endif

    //Check whether detection and recognition results are available.
    GetDictParam(hv_DeepOcrResult, "key_exists", "words", &hv_DetectionMode);
    GetDictParam(hv_DeepOcrResult, "key_exists", "word", &hv_RecognitionMode);
    //
    if (0 != hv_DetectionMode)
    {
      //inputsize =  512*384*3

      GetDictTuple(hv_DeepOcrResult, "words", &hv_Words);
      GetImageSize(ho_Image, &hv_Width, &hv_Height);


      GetDictTuple(hv_Words, "row", &hv_Wordsrow);
      GetDictTuple(hv_Words, "col", &hv_Wordscol);
      GetDictTuple(hv_Words, "phi", &hv_Wordsphi);
      GetDictTuple(hv_Words, "length1", &hv_Wordslength1);
      GetDictTuple(hv_Words, "length2", &hv_Wordslength2);
      GenRectangle2(&ho_Rectangle, hv_Wordsrow, hv_Wordscol, hv_Wordsphi, hv_Wordslength1, 
          hv_Wordslength2);


      GetDictParam(hv_Words, "key_exists", "word", &hv_HasRecognition);
      if (0 != hv_HasRecognition)
      {
        GetDictTuple(hv_Words, "word", &hv_RecognizedWord);
      }

      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Rectangle, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_RecognizedWord, "window", hv_Wordsrow, 
            hv_Wordscol, "red", "box", "false");
    }
  }

}


#ifndef NO_EXPORT_APP_MAIN


int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
    ret = 1;
  }
  return ret;
}

#endif


#endif


